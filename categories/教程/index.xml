<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>教程 on STARRY-S&#39; Blog</title>
    <link>https://blog.starry-s.moe/categories/%E6%95%99%E7%A8%8B/</link>
    <description>Recent content in 教程 on STARRY-S&#39; Blog</description>
    <image>
      <title>STARRY-S&#39; Blog</title>
      <url>https://blog.starry-s.moe/avatar.png</url>
      <link>https://blog.starry-s.moe/avatar.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>© 2016 - 2024 STARRY-S | [CC BY-NC-ND 4.0](https://creativecommons.org/licenses/by-nc-nd/4.0/) | Hosted on [GitHub Pages](https://pages.github.com)&lt;br /&gt;</copyright>
    <lastBuildDate>Sun, 12 Nov 2023 01:35:41 +0800</lastBuildDate><atom:link href="https://blog.starry-s.moe/categories/%E6%95%99%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>如何选择 zip 和 tar 文件格式</title>
      <link>https://blog.starry-s.moe/posts/2023/zip-tar/</link>
      <pubDate>Sun, 12 Nov 2023 01:35:41 +0800</pubDate>
      
      <guid>https://blog.starry-s.moe/posts/2023/zip-tar/</guid>
      <description>&lt;p&gt;最近遇到了一个归档文件格式选择的问题，于是顺手记录下来水一篇博客。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>最近遇到了一个归档文件格式选择的问题，于是顺手记录下来水一篇博客。</p>
<meting-js server="netease" type="song" id="27594398" theme="#233333"></meting-js>
<hr>
<h2 id="tar-文件格式">tar 文件格式</h2>
<p>tar 格式早期是为了将数据记录在磁带上的（现在貌似也可以？），这种归档格式很简单，要将一个文件写入 tar 包的时候，首先写入记录文件信息的 header，在 header 之后记录文件的数据（tar 格式不支持压缩所以是直接把文件数据拷贝在了 header 后面）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">+--------+
</span></span><span class="line"><span class="cl">| header |
</span></span><span class="line"><span class="cl">+--------+
</span></span><span class="line"><span class="cl">|  data  |
</span></span><span class="line"><span class="cl">+--------+
</span></span><span class="line"><span class="cl">| header |
</span></span><span class="line"><span class="cl">+--------+
</span></span><span class="line"><span class="cl">|  data  |
</span></span><span class="line"><span class="cl">+--------+
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">+--------+
</span></span><span class="line"><span class="cl">| header |
</span></span><span class="line"><span class="cl">+--------+
</span></span><span class="line"><span class="cl">|  data  |
</span></span><span class="line"><span class="cl">+--------+
</span></span><span class="line"><span class="cl">|  end   |
</span></span><span class="line"><span class="cl">+--------+
</span></span></code></pre></div><p>tar 有多种不同格式的 header。这里可以看 Linux 系统上常用的 <code>tar</code> 工具（GNU tar）代码，
GNU tar 中实现的 header 结构定义文档参考这个 <a href="https://www.gnu.org/software/tar/manual/html_node/Standard.html">Basic Tar Format</a>。</p>
<p>GNU tar 的源码可以通过下面的方式克隆下载下来。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> git clone https://git.savannah.gnu.org/git/tar.git
</span></span></code></pre></div><p>在 <code>src/tar.h</code> 源码中可以找到 header 结构定义，其中 <code>posix_header</code> 的定义为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">posix_header</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>				<span class="cm">/* byte offset */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>		<span class="cm">/*   0 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">mode</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>			<span class="cm">/* 100 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">uid</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>			<span class="cm">/* 108 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">gid</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>			<span class="cm">/* 116 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">size</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>		<span class="cm">/* 124 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">mtime</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>		<span class="cm">/* 136 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">chksum</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>		<span class="cm">/* 148 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">typeflag</span><span class="p">;</span>		<span class="cm">/* 156 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">linkname</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>		<span class="cm">/* 157 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">magic</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>		<span class="cm">/* 257 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">version</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>		<span class="cm">/* 263 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">uname</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>		<span class="cm">/* 265 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">gname</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>		<span class="cm">/* 297 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">devmajor</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>		<span class="cm">/* 329 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">devminor</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>		<span class="cm">/* 337 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">prefix</span><span class="p">[</span><span class="mi">155</span><span class="p">];</span>		<span class="cm">/* 345 */</span>
</span></span><span class="line"><span class="cl">				<span class="cm">/* 500 */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>上面 header 结构可以看出默认情况下文件名 <code>name</code> 长度不能超过 99 (最后一位要存储 <code>\0</code>)，但似乎后面 tar 协议支持了长文件名的情况，至于如何支持的各位感兴趣的可以自行去搜一下。</p>
<p>除了 <code>posix_header</code> 之外，还有 <code>star_header</code>、<code>gnu_header</code> 等 header 结构，header 结构体占据的空间小于 512 字节，而 tar 的每个 block 都是 512 字节，所以一个 header block 占据 512 字节，末尾空余的字节填写 <code>\0</code>，文件也以 512 字节为单位写在 header block 后面，多出来的空间填写 <code>\0</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* tar files are made in basic blocks of this size.  */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define BLOCKSIZE 512
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">union</span> <span class="n">block</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BLOCKSIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">posix_header</span> <span class="n">header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">star_header</span> <span class="n">star_header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">oldgnu_header</span> <span class="n">oldgnu_header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">sparse_header</span> <span class="n">sparse_header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">star_in_header</span> <span class="n">star_in_header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">star_ext_header</span> <span class="n">star_ext_header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>tar 文件的 end 是由至少两个 block size （1024字节）的空白（<code>\0</code>）组成，但是 GNU tar 创建出来的 tar 包的 end 长度可能大于两个 block size，因为似乎它创建的 tar 包的文件体积以 10K 为单位进行了对齐，可以用下面的方式验证一下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&#34;hello world&#34;</span> &gt; 1.txt
</span></span><span class="line"><span class="cl"><span class="gp">$</span> tar -cv 1.txt -f test.tar
</span></span><span class="line"><span class="cl"><span class="go">1.txt
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> ls -al test.tar
</span></span><span class="line"><span class="cl"><span class="go">-rw-r--r-- 1 starry-s starry-s 10K Nov 12 11:42 test.tar
</span></span></span></code></pre></div><p>用 <code>hexdump</code> 可以看一下创建的 tar 包中包含的数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> hexdump -C ./test.tar
</span></span><span class="line"><span class="cl"><span class="go">0000000   1   .   t   x   t  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">0000010  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">*
</span></span></span><span class="line"><span class="cl"><span class="go">0000060  \0  \0  \0  \0   0   0   0   0   6   4   4  \0   0   0   0   1
</span></span></span><span class="line"><span class="cl"><span class="go">0000070   7   5   0  \0   0   0   0   1   7   5   0  \0   0   0   0   0
</span></span></span><span class="line"><span class="cl"><span class="go">0000080   0   0   0   0   0   1   4  \0   1   4   5   2   4   0   4   5
</span></span></span><span class="line"><span class="cl"><span class="go">0000090   3   5   4  \0   0   1   2   1   1   2  \0       0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">00000a0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">*
</span></span></span><span class="line"><span class="cl"><span class="go">0000100  \0   u   s   t   a   r          \0   s   t   a   r   r   y   -
</span></span></span><span class="line"><span class="cl"><span class="go">0000110   s  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">0000120  \0  \0  \0  \0  \0  \0  \0  \0  \0   s   t   a   r   r   y   -
</span></span></span><span class="line"><span class="cl"><span class="go">0000130   s  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">0000140  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">*
</span></span></span><span class="line"><span class="cl"><span class="go">0000200   h   e   l   l   o       w   o   r   l   d  \n  \0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">0000210  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">*
</span></span></span><span class="line"><span class="cl"><span class="go">0002800
</span></span></span></code></pre></div><p>其中前 <code>0x200</code> 长度 (512 bytes) 存储的是 header，<code>0x200</code> ~ <code>0x2800</code> (10240 bytes) 区域存储了文件的数据 (<code>hello world\n</code>)，文件数据后面均为空白 <code>\0</code>，整体的 tar 包文件大小对齐到了 10K。</p>
<h3 id="栗子">栗子</h3>
<p>因此这里可以用上面的 <code>posix_header</code> 结构体简单的写一个创建 tar 归档的程序。</p>
<p>因为 header 中还包含了简易的计算 header 校验和的步骤，所以代码比较长，可以在 <a href="https://github.com/STARRY-S/tar-example-c">这里</a> 找到。</p>
<h3 id="压缩">压缩</h3>
<p>在创建 tar 格式的文件时是不支持压缩的，文件的数据直接写在了 header 后面（除非你想魔改创建 tar 格式的步骤，但没这个必要）。如果需要压缩的话是把整个 tar 归档用 gzip/bzip2/zstd 等其他压缩格式进行压缩，文件后缀为 <code>tar.gz/tar.bz2/tar.zstd</code> 等。因为是先将文件写入 tar 归档，再将 tar 归档进行压缩，所以压缩的效果会比把文件单独压缩再合并成一个 tar 包效果要好一些。</p>
<h3 id="特点">特点</h3>
<p>从上面的 tar 归档文件格式可以看出，tar 包中的文件是一个一个顺序排列起来的，因此 tar 包中是允许两个相同名称的文件存在的。</p>
<p>如果想向 tar 包末尾附加新的文件的话也很简单，只需要找到末尾的 end block，将其覆盖重写新的文件的 header，之后再写入新文件的数据即可，因此向未压缩的 tar 包附加新的文件（甚至是覆盖掉末尾的一些文件）都是可行的。但是如果想向已压缩的 tar 包（例如 <code>tar.gz</code>）附加文件就不太可行了，除非先把 <code>tar.gz</code> 解压为 <code>tar</code> 格式，附加新的文件后再重新压缩成 <code>tar.gz</code>，但这样如果 tar 文件体积很大的话会造成额外的磁盘空间浪费和性能、时间的浪费。</p>
<p>还有一点是 tar 中存储的文件是顺序排列起来的，但他没有一个 index 索引记录了每个文件的 header 所处的 offset。所以如果想知道一个 tar 包里面存了哪些文件的话，要从头到尾的遍历一遍 tar 包，因此如果这个 tar 包文件体积很大且包含很多零散的小文件的话，每次都要遍历读取 tar 包中的所有 header，会很麻烦。</p>
<p>因此 tar 包不适合随机读取，未压缩的 tar 包还好，只要在首次打开文件时遍历一下把每个文件的 header 和 offset 记录下来就行，但如果是压缩过的例如 <code>tar.gz</code> 格式的压缩包，几乎就没办法随机读取（除非你得再去折腾 <code>gzip</code> 数据流，但几乎没人去这么做），如果想随机解压 <code>tar.gz</code> 中的某个文件，要从头开始先解压 <code>gzip</code> 数据流，从解压的数据流中遍历每个 tar header，在查找到待解压的文件 header 后再将其解压存储下来，麻烦得很！</p>
<p>所以 <code>tar</code> 以及 <code>tar.gz</code> 等压缩的 <code>tar</code> 归档格式通常适合用在不需要随机读取，不需要向归档末尾附加文件的场景。</p>
<h2 id="zip-文件格式">zip 文件格式</h2>
<p>zip 压缩包中文件的布局也是依次顺序排列的，文件的 data 可以是未压缩的文件原始数据 (<code>Store</code>)，或者是使用 Deflate 算法压缩后的文件数据。
在 zip 文件末尾还有一块区域，记录了每个文件 header 的索引信息，叫做 <code>directory</code> (<code>central directory record</code>)，<code>directory</code> 后面还有一小块区域用来记录 <code>directory</code> 的长度和数量等信息 (<code>end of central directory record</code>)。</p>
<p>zip 压缩包中文件的数据布局简单描述一下是这个样子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">+---------------+
</span></span><span class="line"><span class="cl">| header        |
</span></span><span class="line"><span class="cl">+---------------+
</span></span><span class="line"><span class="cl">| data          |
</span></span><span class="line"><span class="cl">+---------------+
</span></span><span class="line"><span class="cl">| header        |
</span></span><span class="line"><span class="cl">+---------------+
</span></span><span class="line"><span class="cl">| data          |
</span></span><span class="line"><span class="cl">+---------------+
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">+---------------+
</span></span><span class="line"><span class="cl">| header        |
</span></span><span class="line"><span class="cl">+---------------+
</span></span><span class="line"><span class="cl">| data          |
</span></span><span class="line"><span class="cl">+---------------+
</span></span><span class="line"><span class="cl">| directory     |
</span></span><span class="line"><span class="cl">+---------------+
</span></span><span class="line"><span class="cl">| directory     |
</span></span><span class="line"><span class="cl">+---------------+
</span></span><span class="line"><span class="cl">....
</span></span><span class="line"><span class="cl">+---------------+
</span></span><span class="line"><span class="cl">| directory     |
</span></span><span class="line"><span class="cl">+---------------+
</span></span><span class="line"><span class="cl">| directory end |
</span></span><span class="line"><span class="cl">+---------------+
</span></span></code></pre></div><p>详细的 <code>zip</code> 文件格式定义在 <a href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT">这里</a>，因为 <code>zip</code> 包中，每个文件的 header 长度是不固定，而且还分为早期的 <code>zip</code> 和后续新增的 <code>zip64</code> 两种格式，手搓代码还蛮复杂的，图省事咱就不写样例代码了。</p>
<h3 id="特点-1">特点</h3>
<p>所以 <code>zip</code> 格式支持随机读取，如果想知道 <code>zip</code> 中存储了多少文件的话，只需要读取文件末尾的 <code>directory</code>。和 <code>tar</code> 一样 <code>zip</code> 也允许存在多个重名的文件。
而 <code>zip</code> 中存储的文件如果压缩的话，是每个文件单独压缩再写入到 <code>zip</code> 归档的，所以压缩的效果会较 <code>tar</code> 把所有文件都打包到一起再压缩要差些。</p>
<p>如果想向已有的 <code>zip</code> 压缩包中增加新的文件，需要将新文件 header 和数据从 <code>directory</code> 处覆盖掉，最后重新在文件末尾写入新的 <code>directory record</code>。</p>
<p>所以 zip 看起来比 tar 格式要更灵活一些，支持随机读取，同时还支持在不解压整个压缩包的情况下，增加新的文件。</p>
<p>zip 支持 Deflate 压缩算法或 Store 不压缩仅存储文件原始数据这两种方式。Deflate 压缩算法与 <code>gzip</code> 使用的 Deflate 压缩算法是一个东西。区别就是 zip 是把文件单独用 Deflate 算法压缩，存储起来，而 <code>tar.gz</code> 是将所有文件先打包到一起，再用 Deflate 算法压缩。</p>
<h2 id="背景">背景</h2>
<p>上面说了这么多，zip 和 tar 的区别读着应该都已经清楚了。下面咱讲一下为什么要调查这个问题，写这篇博客，不感兴趣的话可以浏览器右上角关掉这个页面节省时间。</p>
<p>起初是咱写了一个将容器镜像的 Blobs 文件导入/导出成一个压缩包的工具（类似 <code>docker save/load</code>，但是要支持多架构和多平台一起导出）（关于这个工具等咱逐渐完善后有时间的话打算单独再写一篇博客），一开始用的是 <code>tar.gz</code> 格式压缩。导出的逻辑是先把容器镜像的 Blobs (Layers, Manifest 和 Config) 文件先全部下载到本地，之后把这这些巨大的文件打包成一个 <code>tar.gz</code> 压缩包。逻辑上没什么问题，但是容器镜像普遍体积不小，尤其是要导出上百个镜像时，最后创建的 tar 包体积要几十个 GB。所以先把 Blobs 文件下载到本地占用了一次磁盘空间，再把本地未打包的 Blobs 文件打包成一个 tar 包又占用了一次空间。最后搞得磁盘被占据了双倍的空间。</p>
<p>这还不算什么，如果在导出容器镜像时有时会遇到网络问题或其他因素导致某些镜像 Blobs 导出失败，这样导出生成的压缩包是一个不完整的 <code>tar.gz</code> 包，而咱想向已有的 <code>tar.gz</code> 包附加新的镜像 Blobs 文件的话就得把原有的压缩包解压，写入新的文件，再重新打包，体验极其不友好，咱自己用还行，但要是想把工具拿给别人用的话，光是给别人讲背后的逻辑就得磨叽半天，而且本来一个命令就能解决的问题却非要拆成先解压、再追加额外的 Blobs 文件、最后重新压缩这好几个步骤，而且很多时候因为镜像体积太大了解压和压缩很耗时，还会浪费巨多的磁盘空间，很多时候用户根本不知道要给磁盘预留这么大的空间而导致解压到一半失败了。</p>
<p><img loading="lazy" src="images/dev-user.gif" alt="" />

</p>
<p>所以为了解决这个问题，咱想办法在导出镜像时，采用实时写入的方式，在镜像的 Blobs 文件下载到本地后直接写入到压缩包文件中，而不是先把所有镜像的 Blobs 文件下载下来，再把下载的缓存文件夹打一个压缩包。这样导出镜像时消耗双倍磁盘空间的问题倒是解决了，而且还可以用多线程提个速。
但正如上面说的那样，<code>tar.gz</code> 格式的压缩包在创建完成后就没办法增加新的文件了，这期间咱想过要不换成不压缩的 <code>tar</code> 格式而不是 <code>tar.gz</code> 格式，因为大多数镜像的 Layer 文件本身是已经有 <code>gzip</code> 压缩的了，没必要二次压缩，但是镜像的 Config 和 Manifest 通常是未压缩的文本文件，会有一点额外体积开销。
这种方法看似可行，但因为 <code>tar</code> 他缺少文件索引，所以如果我想按照一份镜像列表按顺序依次将 <code>tar</code> 中存储的 Blobs 文件导入到镜像仓库中，就得遍历构建一遍 <code>tar</code> 包中的所有文件 header，程序中自行存一份索引，还是有点麻烦。</p>
<p>所以最后在 Google 上搜有没有带索引、可以随机读取还支持附加文件的压缩归档文件格式时，重新熟悉了一下 <code>zip</code> 的结构和特点。</p>
<p>因为咱的程序是用 Go 写的，Go 官方标准库提供了 <code>archive/tar</code> 和 <code>archive/zip</code>，用来创建/读取 tar 和 zip 归档。但是 Go 标准库不支持向 tar 包和 zip 包中附加额外的文件，tar 附加额外文件的方式蛮简单的所以不需要在修改标准库的基础上就能实现追加文件（只需要移除文件末尾的 end blocks）。但是 zip 想追加文件的话，就得先读取文件末尾存储的 <code>directory</code> 索引记录存储起来，附加完文件后再重新在文件末尾写入新的 <code>directory</code> 索引。</p>
<p>几年前有人向 Go 提过这个 <a href="https://github.com/golang/go/issues/15626">Issue</a>，希望标准库能实现 zip append 文件的功能。
因为 Go 的 <code>zip.Reader</code> 是使用了 Go 的 <code>io.ReaderAt</code> 接口实现的，<code>zip.Writer</code> 是用 <code>io.Writer</code> 实现的。</p>
<p>Go 标准库中提供的 <code>io.ReaderAt</code> 和 <code>io.WriterAt</code> 接口可以看作是参考了 POSIX 协议的 C 接口 <a href="https://man7.org/linux/man-pages/man2/pread.2.html">pread/pwrite</a>（Go 的 Interface 和这个系统调用的 Interface 不是一个东西），<code>pread</code> 可以读取文件中指定 offset 和长度的数据，并不改变文件自身的 seek offset。因为读取 zip 文件时要先读取文件末尾的 <code>directory</code>，所以用 <code>io.ReaderAt</code> 接口实现很合理。而创建 zip 文件时，要按顺序写入文件 header 和 data，最后在文件末尾写入 directory 信息，所以用 <code>io.Writer</code> 也很合理。</p>
<p>但是如果想向 zip 附加文件的话，就得先用一个类似 <code>io.ReaderAt</code> 接口读取文件末尾已有的 <code>directiory</code> 记录，之后用类似 <code>io.WriterAt</code> 接口向文件末尾的位置写数据。而偏偏 Go 标准库没有 <code>io.ReadWriterAt</code> 这样的接口（就是把 <code>io.ReaderAt</code> 和 <code>io.WriterAt</code> 结合一起），所以最终这个 Issue 因为需要涉及到 Go 其他 <code>io</code> 接口的改动而无法实现关闭掉了。这里额外补充一下，Go 的 zip 标准库是用来对数据流进行操作的，而并非单纯的 zip 文件，所以只要实现了 <code>io.ReaderAt</code> 接口的“对象”都可以被 zip 库“解压”，所有实现了 <code>io.Writer</code> 的“对象”都可以写入 zip 数据。</p>
<p>所以最后没办法，为了能够让咱写的工具支持在不解压 zip 文件的前提下增添新的文件的功能，只能自行造轮子，在 Go <code>archive/zip</code> 标准库的基础上增加了一个 <code>zip.Updater</code>。因为 Go 他确实没有 <code>io.ReadWriterAt</code> 这样的接口，但是 Go 他有 <code>io.ReadWriteSeeker</code> 这个接口，所以在不涉及到多线程竞争访问（或者加锁）的情况下，可以用这个接口实现 <code>zip.Updater</code>，向 zip 包附加额外文件的功能。</p>
<p>在搞这些东西的时候刚好赶上公司的 HackWeek，本来咱已经创建了一个 HackWeek Project，就是上面咱说的容器镜像导入/导出工具的开发这些事情。所以咱在这个基础上又创建了一个新的 HackWeek Project，就是在 Go <code>archive/zip</code> 标准库基础上新增 <code>zip.Updater</code> 相关功能，链接我扔在 <a href="https://hackweek.opensuse.org/23/projects/go-zip-updator-appending-new-files-to-zip-archive-without-decompressing-the-whole-file">这里</a>，感兴趣的话可以去瞅瞅。</p>
<p>最终咱实现了 <code>Updater</code> 的代码仓库在 <a href="https://github.com/STARRY-S/zip">这里</a>，感兴趣的可以去看看，点个 star 什么的。因为基于 <code>io.ReadWriteSeeker</code> 实现的 <code>zip.Updater</code> 并不是最优解，最正确的方式是 Go 什么时候出一个类似 <code>io.ReadWriterAt</code> 接口，在不用改变 <code>Seek</code> 的前提下就能读取/写入指定 offset 的数据，加上自认为咱的程序设计水平还赶不上 Go 维护者，所以咱想了一下就还是先不提 PR 给 Go 源码仓库了。</p>]]></content:encoded>
    </item>
    
    <item>
      <title>修复缩小磁盘空间后受损的 GPT 分区表</title>
      <link>https://blog.starry-s.moe/posts/2023/fix-shrunken-disk-broken-partition-table/</link>
      <pubDate>Wed, 18 Oct 2023 21:42:02 +0800</pubDate>
      
      <guid>https://blog.starry-s.moe/posts/2023/fix-shrunken-disk-broken-partition-table/</guid>
      <description>&lt;p&gt;磁盘的扩容和分区的扩/缩容场景很常见，比如分区用着用着快满了，而磁盘有空闲的未分区空间，而这块区域恰好在这块分区的后面，这时可以对分区扩容。
在使用虚拟机（例如 QEMU）时，假设起初虚拟机的磁盘只创建了 20G，但用久了会存在不够用的情况，这时可以对磁盘扩容，之后再调整分区的大小。&lt;/p&gt;
&lt;p&gt;但是最近遇到了一个需要对磁盘缩容的场景，例如把一个 64G 的 U 盘用 &lt;code&gt;dd&lt;/code&gt; 将整个磁盘的数据写入到一个 8G 的 U盘中（当然这个 64G U盘实际使用的分区大小不能大于前 8G）。
或者要把一个原本 50G 的 qcow2 虚拟磁盘缩小成 10G，用来制作别的镜像什么的。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>磁盘的扩容和分区的扩/缩容场景很常见，比如分区用着用着快满了，而磁盘有空闲的未分区空间，而这块区域恰好在这块分区的后面，这时可以对分区扩容。
在使用虚拟机（例如 QEMU）时，假设起初虚拟机的磁盘只创建了 20G，但用久了会存在不够用的情况，这时可以对磁盘扩容，之后再调整分区的大小。</p>
<p>但是最近遇到了一个需要对磁盘缩容的场景，例如把一个 64G 的 U 盘用 <code>dd</code> 将整个磁盘的数据写入到一个 8G 的 U盘中（当然这个 64G U盘实际使用的分区大小不能大于前 8G）。
或者要把一个原本 50G 的 qcow2 虚拟磁盘缩小成 10G，用来制作别的镜像什么的。</p>
<meting-js server="netease" type="song" id="1348679974" theme="#233333"></meting-js>
<p>按照正常的思路，缩小磁盘空间之前要先缩小分区（还要缩小文件系统），确保分区都位于磁盘的前面，这样磁盘在截断后文件系统不会受损，大致步骤可以分为：</p>
<ol>
<li>
<p>缩小文件系统：例如使用 <code>btrfs filesystem resize</code> 缩小 BTRFS 文件系统至待缩小的分区的大小，确保文件系统的大小不超过分区大小。</p>
</li>
<li>
<p>缩小分区：可以使用 <code>fdisk</code> 先删掉待缩小的分区，之后再重新创建新的分区，重建分区时设定新的分区的大小，且不要删除已有的 <code>btrfs</code> 或其他文件系统签名。这样在缩小分区的同时，不需要重新格式化，因此分区中的文件没有丢失。</p>
<p>（除了 <code>fdisk</code>，还可以用 <code>sfdisk</code>，<code>gdisk</code> 或 <code>parted</code> 等工具调整分区）</p>
</li>
<li>
<p>确保分区都位于磁盘的起始位置后，执行磁盘缩小的操作，将磁盘末端未使用的数据截断。</p>
</li>
</ol>
<p>GPT / MBR 分区表咱凭感觉来猜的话，是存储在磁盘的起始位置的，所以如果磁盘缩小时，将磁盘末端一些数据截断正常情况下应该是不会影响到存储在起始位置的分区表的。</p>
<p>但是，在一些情况下，会出现缩小完磁盘空间后分区表受损的情况。</p>
<h2 id="举个栗子">举个栗子</h2>
<ol>
<li>
<p>首先使用 <code>qemu-img create</code> 创建一块 10G 的 QEMU 虚拟机磁盘。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> qemu-img create -f qcow2 disk1.qcow2 10G
</span></span><span class="line"><span class="cl"><span class="go">Formatting &#39;disk1.qcow2&#39;, fmt=qcow2 cluster_size=65536 extended_l2=off compression_type=zlib size=10737418240 lazy_refcounts=off refcount_bits=16
</span></span></span></code></pre></div></li>
<li>
<p>使用 <code>qemu-nbd</code> 工具将 qcow2 磁盘镜像与 Linux 内核通过 <a href="https://www.kernel.org/doc/Documentation/blockdev/nbd.txt">nbd</a> 连接，这样可以在不启动 QEMU 虚拟机的情况下直接对 qcow2 磁盘分区进行操作。</p>
<p>加载 <code>nbd</code> 内核模块，其中 <code>max_part</code> 参数是磁盘允许的最大分区数，默认为 0 所以这里需要把数值改大一点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo modprobe nbd <span class="nv">max_part</span><span class="o">=</span><span class="m">8</span>
</span></span></code></pre></div><p>将创建的 <code>disk1.qcow2</code> 镜像与 <code>/dev/nbd0</code> 连接。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo qemu-nbd -c /dev/nbd0 ./disk1.qcow2
</span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> lsblk /dev/nbd0
</span></span><span class="line"><span class="cl"><span class="go">NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS
</span></span></span><span class="line"><span class="cl"><span class="go">nbd0  43:0    0  10G  0 disk
</span></span></span></code></pre></div><p>使用 <code>fdisk</code> 初始化 GPT 分区表，并随便新建几个分区。</p>
<blockquote>
<p>咱都是 Arch Linux 用户了，fdisk 就不用我再详细说了吧。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo fdisk /dev/nbd0
</span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Welcome to fdisk (util-linux 2.39.2).
</span></span></span><span class="line"><span class="cl"><span class="go">Changes will remain in memory only, until you decide to write them.
</span></span></span><span class="line"><span class="cl"><span class="go">Be careful before using the write command.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Device does not contain a recognized partition table.
</span></span></span><span class="line"><span class="cl"><span class="go">Created a new DOS (MBR) disklabel with disk identifier 0xf5c43a4b.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Command (m for help): g
</span></span></span><span class="line"><span class="cl"><span class="go">Created a new GPT disklabel (GUID: 2EB767AB-0958-461B-B56D-697B3305AC83).
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Command (m for help): n
</span></span></span><span class="line"><span class="cl"><span class="go">Partition number (1-128, default 1):
</span></span></span><span class="line"><span class="cl"><span class="go">First sector (2048-20971486, default 2048):
</span></span></span><span class="line"><span class="cl"><span class="go">Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-20971486, default 20969471): +512M
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Created a new partition 1 of type &#39;Linux filesystem&#39; and of size 512 MiB.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Command (m for help): t
</span></span></span><span class="line"><span class="cl"><span class="go">Selected partition 1
</span></span></span><span class="line"><span class="cl"><span class="go">Partition type or alias (type L to list all): 1
</span></span></span><span class="line"><span class="cl"><span class="go">Changed type of partition &#39;Linux filesystem&#39; to &#39;EFI System&#39;.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Command (m for help): n
</span></span></span><span class="line"><span class="cl"><span class="go">Partition number (2-128, default 2):
</span></span></span><span class="line"><span class="cl"><span class="go">First sector (1050624-20971486, default 1050624):
</span></span></span><span class="line"><span class="cl"><span class="go">Last sector, +/-sectors or +/-size{K,M,G,T,P} (1050624-20971486, default 20969471):
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Created a new partition 2 of type &#39;Linux filesystem&#39; and of size 9.5 GiB.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Command (m for help): w
</span></span></span><span class="line"><span class="cl"><span class="go">The partition table has been altered.
</span></span></span><span class="line"><span class="cl"><span class="go">Calling ioctl() to re-read partition table.
</span></span></span><span class="line"><span class="cl"><span class="go">Syncing disks.
</span></span></span></code></pre></div><p>本栗中，磁盘新建了两个分区，<code>/dev/nbd0p1</code> 是 512M 大小的 EFI 分区，剩余空间 <code>/dev/nbd0p2</code> 是 root 分区。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo fdisk -l /dev/nbd0
</span></span><span class="line"><span class="cl"><span class="go">Disk /dev/nbd0: 10 GiB, 10737418240 bytes, 20971520 sectors
</span></span></span><span class="line"><span class="cl"><span class="go">Units: sectors of 1 * 512 = 512 bytes
</span></span></span><span class="line"><span class="cl"><span class="go">Sector size (logical/physical): 512 bytes / 512 bytes
</span></span></span><span class="line"><span class="cl"><span class="go">I/O size (minimum/optimal): 512 bytes / 512 bytes
</span></span></span><span class="line"><span class="cl"><span class="go">Disklabel type: gpt
</span></span></span><span class="line"><span class="cl"><span class="go">Disk identifier: 2EB767AB-0958-461B-B56D-697B3305AC83
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Device        Start      End  Sectors  Size Type
</span></span></span><span class="line"><span class="cl"><span class="go">/dev/nbd0p1    2048  1050623  1048576  512M EFI System
</span></span></span><span class="line"><span class="cl"><span class="go">/dev/nbd0p2 1050624 20969471 19918848  9.5G Linux filesystem
</span></span></span></code></pre></div><p>之后简单的格式化一下两个分区，挂载并往里面写一些文件进去。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo mkfs.vfat -F <span class="m">32</span> /dev/nbd0p1
</span></span><span class="line"><span class="cl"><span class="go">mkfs.fat 4.2 (2021-01-31)
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> sudo mkfs.btrfs /dev/nbd0p2
</span></span><span class="line"><span class="cl"><span class="go">btrfs-progs v6.5.2
</span></span></span><span class="line"><span class="cl"><span class="go">See https://btrfs.readthedocs.io for more information.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Performing full device TRIM /dev/nbd0p2 (9.50GiB) ...
</span></span></span><span class="line"><span class="cl"><span class="go">NOTE: several default settings have changed in version 5.15, please make sure
</span></span></span><span class="line"><span class="cl"><span class="go">    this does not affect your deployments:
</span></span></span><span class="line"><span class="cl"><span class="go">    - DUP for metadata (-m dup)
</span></span></span><span class="line"><span class="cl"><span class="go">    - enabled no-holes (-O no-holes)
</span></span></span><span class="line"><span class="cl"><span class="go">    - enabled free-space-tree (-R free-space-tree)
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Label:              (null)
</span></span></span><span class="line"><span class="cl"><span class="go">UUID:               a5fb30e5-eb5f-4a0b-8d2a-106e04e1488b
</span></span></span><span class="line"><span class="cl"><span class="go">Node size:          16384
</span></span></span><span class="line"><span class="cl"><span class="go">Sector size:        4096
</span></span></span><span class="line"><span class="cl"><span class="go">Filesystem size:    9.50GiB
</span></span></span><span class="line"><span class="cl"><span class="go">Block group profiles:
</span></span></span><span class="line"><span class="cl"><span class="go">Data:             single            8.00MiB
</span></span></span><span class="line"><span class="cl"><span class="go">Metadata:         DUP             256.00MiB
</span></span></span><span class="line"><span class="cl"><span class="go">System:           DUP               8.00MiB
</span></span></span><span class="line"><span class="cl"><span class="go">SSD detected:       yes
</span></span></span><span class="line"><span class="cl"><span class="go">Zoned device:       no
</span></span></span><span class="line"><span class="cl"><span class="go">Incompat features:  extref, skinny-metadata, no-holes, free-space-tree
</span></span></span><span class="line"><span class="cl"><span class="go">Runtime features:   free-space-tree
</span></span></span><span class="line"><span class="cl"><span class="go">Checksum:           crc32c
</span></span></span><span class="line"><span class="cl"><span class="go">Number of devices:  1
</span></span></span><span class="line"><span class="cl"><span class="go">Devices:
</span></span></span><span class="line"><span class="cl"><span class="go">   ID        SIZE  PATH
</span></span></span><span class="line"><span class="cl"><span class="go">    1     9.50GiB  /dev/nbd0p2
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> mkdir -p mnt
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo mount /dev/nbd0p2 mnt
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo mkdir ./mnt/<span class="o">{</span>boot,home<span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo mount /dev/nbd0p1 mnt/boot
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo touch ./mnt/example.txt
</span></span></code></pre></div></li>
<li>
<p>使用 <code>btrfs filesystem resize</code> 缩小 root 分区中的 BTRFS 文件系统大小至 7G，之后使用 <code>fdisk</code> 缩小 root 分区大小至 7G。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo btrfs filesystem resize 7G mnt
</span></span><span class="line"><span class="cl"><span class="go">Resize device id 1 (/dev/nbd0p2) from 9.50GiB to 7.00GiB
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> sudo sync
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo umount -R ./mnt
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo fdisk /dev/nbd0
</span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Welcome to fdisk (util-linux 2.39.2).
</span></span></span><span class="line"><span class="cl"><span class="go">Changes will remain in memory only, until you decide to write them.
</span></span></span><span class="line"><span class="cl"><span class="go">Be careful before using the write command.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Command (m for help): d
</span></span></span><span class="line"><span class="cl"><span class="go">Partition number (1,2, default 2): 2
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Partition 2 has been deleted.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Command (m for help): n
</span></span></span><span class="line"><span class="cl"><span class="go">Partition number (2-128, default 2):
</span></span></span><span class="line"><span class="cl"><span class="go">First sector (1050624-20971486, default 1050624):
</span></span></span><span class="line"><span class="cl"><span class="go">Last sector, +/-sectors or +/-size{K,M,G,T,P} (1050624-20971486, default 20969471): +7G
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Created a new partition 2 of type &#39;Linux filesystem&#39; and of size 7 GiB.
</span></span></span><span class="line"><span class="cl"><span class="go">Partition #2 contains a btrfs signature.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Do you want to remove the signature? [Y]es/[N]o: N
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Command (m for help): w
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">The partition table has been altered.
</span></span></span><span class="line"><span class="cl"><span class="go">Calling ioctl() to re-read partition table.
</span></span></span><span class="line"><span class="cl"><span class="go">Syncing disks.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> sudo fdisk -l /dev/nbd0
</span></span><span class="line"><span class="cl"><span class="go">Disk /dev/nbd0: 10 GiB, 10737418240 bytes, 20971520 sectors
</span></span></span><span class="line"><span class="cl"><span class="go">Units: sectors of 1 * 512 = 512 bytes
</span></span></span><span class="line"><span class="cl"><span class="go">Sector size (logical/physical): 512 bytes / 512 bytes
</span></span></span><span class="line"><span class="cl"><span class="go">I/O size (minimum/optimal): 512 bytes / 512 bytes
</span></span></span><span class="line"><span class="cl"><span class="go">Disklabel type: gpt
</span></span></span><span class="line"><span class="cl"><span class="go">Disk identifier: 2EB767AB-0958-461B-B56D-697B3305AC83
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Device        Start      End  Sectors  Size Type
</span></span></span><span class="line"><span class="cl"><span class="go">/dev/nbd0p1    2048  1050623  1048576  512M EFI System
</span></span></span><span class="line"><span class="cl"><span class="go">/dev/nbd0p2 1050624 15730687 14680064    7G Linux filesystem
</span></span></span></code></pre></div><p>调整完分区大小后，因为这里没有移除 BTRFS 签名，所以分区的文件没有被删除，执行 <code>lsblk -no NAME,UUID /dev/nbd0</code> 可以看到 <code>/dev/nbd0p2</code> 的 UUID 也没有变化，和上面执行 <code>mkfs.btrfs</code> 时输出的一致。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> lsblk -no NAME,UUID /dev/nbd0
</span></span><span class="line"><span class="cl"><span class="go">nbd0
</span></span></span><span class="line"><span class="cl"><span class="go">├─nbd0p1 C6B7-EF70
</span></span></span><span class="line"><span class="cl"><span class="go">└─nbd0p2 a5fb30e5-eb5f-4a0b-8d2a-106e04e1488b
</span></span></span></code></pre></div></li>
<li>
<p>断开 NBD 连接，缩小 qcow2 磁盘大小到 8G。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo qemu-nbd -d /dev/nbd0
</span></span><span class="line"><span class="cl"><span class="go">/dev/nbd0 disconnected
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> qemu-img resize ./disk1.qcow2 --shrink 8G
</span></span><span class="line"><span class="cl"><span class="go">Image resized.
</span></span></span></code></pre></div></li>
<li>
<p>重新将 qcow2 磁盘连接到 <code>/dev/nbd0</code>，会发现上面创建的磁盘中的几块分区不见了！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo qemu-nbd -c /dev/nbd0 ./disk1.qcow2
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo fdisk -l /dev/nbd0
</span></span><span class="line"><span class="cl"><span class="go">GPT PMBR size mismatch (20971519 != 16777215) will be corrected by write.
</span></span></span><span class="line"><span class="cl"><span class="go">Disk /dev/nbd0: 8 GiB, 8589934592 bytes, 16777216 sectors
</span></span></span><span class="line"><span class="cl"><span class="go">Units: sectors of 1 * 512 = 512 bytes
</span></span></span><span class="line"><span class="cl"><span class="go">Sector size (logical/physical): 512 bytes / 512 bytes
</span></span></span><span class="line"><span class="cl"><span class="go">I/O size (minimum/optimal): 512 bytes / 512 bytes
</span></span></span><span class="line"><span class="cl"><span class="go">Disklabel type: dos
</span></span></span><span class="line"><span class="cl"><span class="go">Disk identifier: 0x00000000
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Device      Boot Start      End  Sectors Size Id Type
</span></span></span><span class="line"><span class="cl"><span class="go">/dev/nbd0p1          1 16777215 16777215   8G ee GPT
</span></span></span></code></pre></div><p><code>fdisk</code> 输出中包含一条错误提示：<code>GPT PMBR size mismatch (20971519 != 16777215) will be corrected by write.</code>，大致意思是 GPT 分区表中记录的区块数量 (sectors) 和磁盘实际的区块数不一致。</p>
</li>
</ol>
<h2 id="修复受损的分区表">修复受损的分区表</h2>
<p>所以修复上面栗子中受损的 GPT 分区表的办法是，重新建一个 GPT 分区表，并按照之前的分区位置，重建分区。</p>
<p>这里重建分区时要注意，需要输入精确的区块位置，而不是类似 <code>+50M</code> 这样模糊的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo fdisk /dev/nbd0
</span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Welcome to fdisk (util-linux 2.39.2).
</span></span></span><span class="line"><span class="cl"><span class="go">Changes will remain in memory only, until you decide to write them.
</span></span></span><span class="line"><span class="cl"><span class="go">Be careful before using the write command.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">GPT PMBR size mismatch (20971519 != 16777215) will be corrected by write.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Command (m for help): g
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Created a new GPT disklabel (GUID: 3C587DB1-5978-45D2-AB05-9135D273D06D).
</span></span></span><span class="line"><span class="cl"><span class="go">The device contains &#39;PMBR&#39; signature and it will be removed by a write command. See fdisk(8) man page and --wipe option for more details.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Command (m for help): n
</span></span></span><span class="line"><span class="cl"><span class="go">Partition number (1-128, default 1):
</span></span></span><span class="line"><span class="cl"><span class="go">First sector (2048-16777182, default 2048):
</span></span></span><span class="line"><span class="cl"><span class="go">Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-16777182, default 16775167): 1050623
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Created a new partition 1 of type &#39;Linux filesystem&#39; and of size 512 MiB.
</span></span></span><span class="line"><span class="cl"><span class="go">Partition #1 contains a vfat signature.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Do you want to remove the signature? [Y]es/[N]o: N
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Command (m for help): n
</span></span></span><span class="line"><span class="cl"><span class="go">Partition number (2-128, default 2):
</span></span></span><span class="line"><span class="cl"><span class="go">First sector (1050624-16777182, default 1050624):
</span></span></span><span class="line"><span class="cl"><span class="go">Last sector, +/-sectors or +/-size{K,M,G,T,P} (1050624-16777182, default 16775167): 15730687
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Created a new partition 2 of type &#39;Linux filesystem&#39; and of size 7 GiB.
</span></span></span><span class="line"><span class="cl"><span class="go">Partition #2 contains a btrfs signature.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Do you want to remove the signature? [Y]es/[N]o: N
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Command (m for help): t
</span></span></span><span class="line"><span class="cl"><span class="go">Partition number (1,2, default 2): 1
</span></span></span><span class="line"><span class="cl"><span class="go">Partition type or alias (type L to list all): 1
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Changed type of partition &#39;Linux filesystem&#39; to &#39;EFI System&#39;.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Command (m for help): w
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">The partition table has been altered.
</span></span></span><span class="line"><span class="cl"><span class="go">Calling ioctl() to re-read partition table.
</span></span></span><span class="line"><span class="cl"><span class="go">Syncing disks.
</span></span></span></code></pre></div><p>重建分区表后，不出意外的话，重新挂载分区是能访问分区中的文件的，分区的 UUID 也没有发生改动。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> lsblk -no NAME,UUID /dev/nbd0
</span></span><span class="line"><span class="cl"><span class="go">nbd0
</span></span></span><span class="line"><span class="cl"><span class="go">├─nbd0p1 C6B7-EF70
</span></span></span><span class="line"><span class="cl"><span class="go">└─nbd0p2 a5fb30e5-eb5f-4a0b-8d2a-106e04e1488b
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> sudo -l fdisk /dev/nbd0
</span></span><span class="line"><span class="cl"><span class="go">Disk /dev/nbd0: 8 GiB, 8589934592 bytes, 16777216 sectors
</span></span></span><span class="line"><span class="cl"><span class="go">Units: sectors of 1 * 512 = 512 bytes
</span></span></span><span class="line"><span class="cl"><span class="go">Sector size (logical/physical): 512 bytes / 512 bytes
</span></span></span><span class="line"><span class="cl"><span class="go">I/O size (minimum/optimal): 512 bytes / 512 bytes
</span></span></span><span class="line"><span class="cl"><span class="go">Disklabel type: gpt
</span></span></span><span class="line"><span class="cl"><span class="go">Disk identifier: 3C587DB1-5978-45D2-AB05-9135D273D06D
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Device        Start      End  Sectors  Size Type
</span></span></span><span class="line"><span class="cl"><span class="go">/dev/nbd0p1    2048  1050623  1048576  512M EFI System
</span></span></span><span class="line"><span class="cl"><span class="go">/dev/nbd0p2 1050624 15730687 14680064    7G Linux filesystem
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> sudo mount /dev/nbd0p2 mnt
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo mount /dev/nbd0p1 mnt/boot
</span></span><span class="line"><span class="cl"><span class="gp">$</span> ls -alh mnt
</span></span><span class="line"><span class="cl"><span class="go">total 20K
</span></span></span><span class="line"><span class="cl"><span class="go">drwxr-xr-x 2 root     root     4.0K Jan  1  1970 boot
</span></span></span><span class="line"><span class="cl"><span class="go">-rw-r--r-- 1 root     root        0 Oct 18 22:36 example.txt
</span></span></span><span class="line"><span class="cl"><span class="go">drwxr-xr-x 1 root     root        0 Oct 18 22:34 home
</span></span></span></code></pre></div><h2 id="sfdisk-备份分区表">sfdisk 备份分区表</h2>
<p>如果觉得重建分区表时，分区的位置记不住的话（废话正常人谁能背下来这一串数字），<code>sfdisk</code> 的 <code>--dump</code> 参数可以备份分区表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo sfdisk --dump /dev/nbd0
</span></span><span class="line"><span class="cl"><span class="go">label: gpt
</span></span></span><span class="line"><span class="cl"><span class="go">label-id: 3C587DB1-5978-45D2-AB05-9135D273D06D
</span></span></span><span class="line"><span class="cl"><span class="go">device: /dev/nbd0
</span></span></span><span class="line"><span class="cl"><span class="go">unit: sectors
</span></span></span><span class="line"><span class="cl"><span class="go">first-lba: 2048
</span></span></span><span class="line"><span class="cl"><span class="go">last-lba: 16777182
</span></span></span><span class="line"><span class="cl"><span class="go">sector-size: 512
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">/dev/nbd0p1 : start=        2048, size=     1048576, type=C12A7328-F81F-11D2-BA4B-00A0C93EC93B, uuid=496140B3-C491-470B-98D7-BB95F55266A7
</span></span></span><span class="line"><span class="cl"><span class="go">/dev/nbd0p2 : start=     1050624, size=    14680064, type=0FC63DAF-8483-4772-8E79-3D69D8477DE4, uuid=F918E93D-FB1D-4652-9657-CE24A29ADEA5
</span></span></span></code></pre></div><p>在执行磁盘缩小操作之前，可以先使用 <code>sfdisk</code> 导出分区表，缩小磁盘后再恢复。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="go">Backup partition table
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> sudo sfdisk --dump /dev/nbd0 &gt; nbd0.txt
</span></span><span class="line"><span class="cl"><span class="go">Remove the `last-lba` line
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> grep -v last-lba nbd0.txt &gt; partition-backup.txt
</span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">After shrinking the disk size...
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Restore the backup partition table
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> sudo sfdisk /dev/nbd0 &lt; partition-backup.txt
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>yuzu - Switch 虚拟机</title>
      <link>https://blog.starry-s.moe/posts/2022/switch-emulator/</link>
      <pubDate>Sun, 16 Oct 2022 15:48:46 +0800</pubDate>
      
      <guid>https://blog.starry-s.moe/posts/2022/switch-emulator/</guid>
      <description>&lt;p&gt;一直想玩的游戏没有官方汉化，Switch 的游戏文件没破解的话是没办法装汉化插件的，尽管咱有 Switch OLED 港版主机，但是破解有被封的可能而且过程过于麻烦，破解后就不能联网了，所以咱在买了正版游戏但是看不懂日语后无奈之下选择了虚拟机，正好水一篇博客。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>一直想玩的游戏没有官方汉化，Switch 的游戏文件没破解的话是没办法装汉化插件的，尽管咱有 Switch OLED 港版主机，但是破解有被封的可能而且过程过于麻烦，破解后就不能联网了，所以咱在买了正版游戏但是看不懂日语后无奈之下选择了虚拟机，正好水一篇博客。</p>
<meting-js server="netease" type="song" id="590443" theme="#233333"></meting-js>
<p>目前有两个虚拟机可选，一个是 由 C# 编写的 <a href="https://github.com/Ryujinx/Ryujinx">Ryujinx</a>，另一个是由 C++ 编写的 <a href="https://github.com/yuzu-emu/yuzu">yuzu</a>，这俩都是开源软件而且都能在 Linux 上运行，咱选的是后者。</p>
<hr>
<p>yuzu 提供的教程需要短接器和一张TF卡以及 switch 本体，从 switch 中获取 <code>prod.keys</code> 和 <code>title.keys</code> （非必须），喜欢折腾的可以买个短接器慢慢鼓捣，教程链接：<a href="https://yuzu-emu.org/help/quickstart/">https://yuzu-emu.org/help/quickstart/</a>。如果懒得折腾的话从网上找个现成的 key 文件也能用。</p>
<p>Arch Linux 可以从 archlinuxcn 源或者 AUR 中获取。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">sudo pacman -S yuzu-git
</span></span></code></pre></div><p>第一次启动时会提示缺少 keys，可先忽略，选择左上角 <code>File-&gt;Open yuzu Folder</code>，新建一个 <code>keys</code> 文件夹，将 <code>prod.keys</code> 复制进去后重启软件。</p>
<p>yuzu 可以在不手动安装系统的情况下运行游戏，所以添加了游戏所在的文件夹就能玩了。</p>
<p><img loading="lazy" src="images/1.png" alt="" />

</p>
<p>然后就是在设置里面改一下手柄的按键布局，因为用习惯了 Xbox 手柄，所以咱把 A 和 B 位置对调了一下。</p>
<p><img loading="lazy" src="images/2.png" alt="" />

</p>
<hr>
<p>后续：</p>
<p>Yuzu 2023-05-21 之后的版本对宝可梦做了些优化导致玩月姬时文字花屏乱码，玩月姬的话不要下载 2023-05-21 (1440) 之后的版本。</p>
<p>然后 Arch Linux 最近滚完系统后遇到了 yuzu 的 Qt 启动失败报错：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Warning: Ignoring XDG_SESSION_TYPE=wayland on Gnome. Use QT_QPA_PLATFORM=wayland to run on Wayland anyway.
</span></span><span class="line"><span class="cl">qt.qpa.plugin: Could not find the Qt platform plugin &#34;wayland&#34; in &#34;&#34;
</span></span><span class="line"><span class="cl">This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Available platform plugins are: xcb.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">zsh: IOT instruction (core dumped)  yuzu
</span></span></code></pre></div><p>查了一阵子找到的解决办法是设置 <code>QT_PLUGIN_PATH=/usr/lib/qt/plugins</code> 环境变量，覆盖掉 yuzu 安装包自带的 Qt 插件而是改用系统的。</p>]]></content:encoded>
    </item>
    
    <item>
      <title>移动GM220-S光猫改桥接小记</title>
      <link>https://blog.starry-s.moe/posts/2022/gm220-s-bridge-mode/</link>
      <pubDate>Thu, 07 Jul 2022 17:54:35 +0800</pubDate>
      
      <guid>https://blog.starry-s.moe/posts/2022/gm220-s-bridge-mode/</guid>
      <description>&lt;p&gt;最近搬了新的住处，用的是移动的宽带，因此尝试着把移动的光猫改成桥接，接到我的软路由上面。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>最近搬了新的住处，用的是移动的宽带，因此尝试着把移动的光猫改成桥接，接到我的软路由上面。</p>
<p>因为我不知道PPPoE拨号的帐号和密码，尽管这个光猫的超级密码网上一搜就能找到，但是我不知道PPPoE帐号的密码就算改了桥接也没办法拨号。
于是先借助网上能搜到的资料尝试把宽带帐号的密码给搞出来。</p>
<hr>
<p>一开始尝试着登录光猫的后台页面，在设置拨号上网的页面那里F12大法，把<code>input</code>元素的<code>type=&quot;password&quot;</code>改成<code>type=&quot;text&quot;</code>，
但是发现这里预填写的密码已经是加密过的<code>******</code>，因此这个方法行不通。</p>
<p>然后看教程有说尝试打开光猫的telnet，把配置文件用ftp传出来，但是试了一下所有的尝试打开telnet的方式在这个光猫上都不好使，于是这个方法也行不通。</p>
<p>之后在光猫登录管理员帐号之后，在“管理-&gt;设备管理-&gt;USB备份配置&quot;这里找到了可以把配置文件备份到U盘的地方，
于是找了一张空内存卡格式化成<code>FAT32</code>，放读卡器里插在光猫上，把配置文件备份到U盘上。</p>
<p><img loading="lazy" src="images/1.png" alt="" />
<p style="margin-bottom: -0.8em;" class="image-title">备份至USB</p>
</p>
<blockquote>
<p>这里备份之后不要立即把U盘拔下来，貌似光猫在备份完配置文件后没有立即把数据<code>sync</code>到U盘中，需要等一阵子再拔U盘。
等多久我也不确定，反复试几次直到U盘上出现了<code>e8_Config_Backup</code>文件夹就可以了。</p>
</blockquote>
<p>然后下载<a href="http://www.nirsoft.net/utils/router_password_recovery.html#DownloadLinks">RouterPassView</a>，
用这个工具打开配置文件，就可以找到里面光猫上的所有配置了，包括宽带帐号和密码。</p>
<p>之后在网络设置里面改桥接，就可以用软路由拨号上网辣。</p>
<hr>
<p>使用了一下移动的宽带发现貌似他们把所有的ICMP的ECHO回显请求屏蔽掉了，所以尝试ping任何IP都是不通的。别的貌似没什么问题。</p>]]></content:encoded>
    </item>
    
    <item>
      <title>在Arch Linux上配置软路由</title>
      <link>https://blog.starry-s.moe/posts/2022/archlinux-router/</link>
      <pubDate>Wed, 08 Jun 2022 00:49:34 +0800</pubDate>
      
      <guid>https://blog.starry-s.moe/posts/2022/archlinux-router/</guid>
      <description>&lt;p&gt;之前买了个NanoPi R4S，当时给他装了Arch Linux ARM并用&lt;code&gt;systemd-networkd&lt;/code&gt;配置了一个简易的软路由。不过&lt;code&gt;systemd-networkd&lt;/code&gt;不支持PPPoE，所以当时我是把R4S接在租的房子的主路由下做子路由的，然后再给R4S接了一个小米路由器当作无线AP。最近从北京搬回家了所以想直接使用R4S做家里的主路由，因为&lt;a href=&#34;https://blog.starry-s.moe/posts/2022/nanopi-r4s/&#34;&gt;R4S上手体验&lt;/a&gt;的那篇文章已经写完很久了，所以就不打算在那篇博客上做修改了，而是新开（水）了一篇博客。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>之前买了个NanoPi R4S，当时给他装了Arch Linux ARM并用<code>systemd-networkd</code>配置了一个简易的软路由。不过<code>systemd-networkd</code>不支持PPPoE，所以当时我是把R4S接在租的房子的主路由下做子路由的，然后再给R4S接了一个小米路由器当作无线AP。最近从北京搬回家了所以想直接使用R4S做家里的主路由，因为<a href="/posts/2022/nanopi-r4s/">R4S上手体验</a>的那篇文章已经写完很久了，所以就不打算在那篇博客上做修改了，而是新开（水）了一篇博客。</p>
<blockquote>
<p>这里偷偷骂一下长城宽带没人反对吧</p>
</blockquote>
<h2 id="准备工作">准备工作</h2>
<p>按照Arch Wiki的<a href="https://wiki.archlinux.org/title/Router#Connection_sharing">Router页面</a>，你的电脑需要符合安装Arch Linux的基础硬件要求，且至少具备俩物理网口。</p>
<p>个人觉得软路由没必要非得刷*WRT或者其他路由器专用系统，也没必要搞个爱快群辉什么的系统，我只想给他装我喜欢的发行版，然后我自己配置我需要的服务，只要有两个以上的物理网口就可以配置路由功能，给他们配置DHCP和流量转发就完事了，这样搞出来的路由器更符合咱自己的需求，相对来讲也更灵活一些，不用受限于那些路由器/NAS定制的系统，而缺点则是比较折腾，有可能不稳定。</p>
<p>安装系统的步骤咱跳过不讲了，Wiki上有的东西没必要在这里重复一遍。</p>
<h2 id="配置ip地址">配置IP地址</h2>
<p>首先，将你电脑的两个物理网口一个用作WAN口（连接广域网），一个用作LAN口（连接局域网），有需要的可以自行修改网口的名称（通常默认的网卡名字为<code>eth*</code>，或者<code>enp*s*</code>）。
为了和Wiki同步，这里假设WAN口的名字为<code>extern0</code>，用来指连接到广域网的网口，LAN口的名字为<code>intern0</code>，代指连接到局域网的网口。</p>
<p>本篇使用<code>netctl</code>配置网络，在修改配置文件之前，需要先停掉其他配置网络的服务。</p>
<p>给LAN口配置一个静态IP地址。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># /etc/netctl/intern0-profile
</span></span><span class="line"><span class="cl"># Config file for intern0 (LAN)
</span></span><span class="line"><span class="cl">Description=&#39;Private Interface. (LAN)&#39;
</span></span><span class="line"><span class="cl">Interface=intern0
</span></span><span class="line"><span class="cl">Connection=ethernet
</span></span><span class="line"><span class="cl">IP=&#39;static&#39;
</span></span><span class="line"><span class="cl">Address=(&#39;10.10.10.1/24&#39;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">IP6=&#39;static&#39;
</span></span><span class="line"><span class="cl">Address6=(&#39;fdaa:aaaa:bbbb::0001/64&#39;)
</span></span><span class="line"><span class="cl">SkipNoCarrier=yes
</span></span></code></pre></div><p>以上配置将为LAN口设定IPv4的地址为<code>10.10.10.1</code>，IPv6的地址为<code>fdaa:aaaa:bbbb::0001</code>。
你可以给这个网口设定任意的局域网IP地址，通常为<code>10.*</code>，<code>172.*</code>，<code>192.168.*</code>这些网段的任意一个地址，
IPv6的局域网网段为<code>fd00::/8</code>，通俗一点讲就是<code>fd**</code>开头的一般都是局域网的IP地址。</p>
<p>之后给WAN口配置DHCP或PPPoE协议。</p>
<blockquote>
<p>配置DHCP的方式自行翻Wiki或者看example，这里不重复讲了。</p>
</blockquote>
<p>在配置PPPoE之前需要安装<code>ppp</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># /etc/netctl/extern0-profile
</span></span><span class="line"><span class="cl"># Config file for public interface (WAN)
</span></span><span class="line"><span class="cl">Description=&#39;Public Interface. (WAN)&#39;
</span></span><span class="line"><span class="cl">Interface=extern0
</span></span><span class="line"><span class="cl">Connection=pppoe
</span></span><span class="line"><span class="cl">User=&#39;username&#39;
</span></span><span class="line"><span class="cl">Password=&#39;samplepasswd&#39;
</span></span><span class="line"><span class="cl"># IP6=stateless
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Always keep a connection established
</span></span><span class="line"><span class="cl">ConnectionMode=&#39;persist&#39;
</span></span></code></pre></div><p>使用以下命令启动<code>netctl</code>的配置文件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">netctl enable intern0-profile
</span></span><span class="line"><span class="cl">netctl enable extern0-profile
</span></span></code></pre></div><p>重启路由器，将WAN口与光猫的网口连接，使用<code>ip addr</code>查看网络设备的IP地址，顺利的话，可以看到一个名为<code>ppp0</code>的网口，并获取了一个运营商分给你的IP地址。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1: intern0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000
</span></span><span class="line"><span class="cl">    link/ether fa:97:da:d8:9d:8a brd ff:ff:ff:ff:ff:ff
</span></span><span class="line"><span class="cl">    inet 10.10.10.1/24 brd 10.10.10.255 scope global intern0
</span></span><span class="line"><span class="cl">       valid_lft forever preferred_lft forever
</span></span><span class="line"><span class="cl">    inet6 fdaa:aaaa:bbbb::1/64 scope global nodad
</span></span><span class="line"><span class="cl">       valid_lft forever preferred_lft forever
</span></span><span class="line"><span class="cl">    inet6 fe80::f897:daff:fed8:9d8a/64 scope link
</span></span><span class="line"><span class="cl">       valid_lft forever preferred_lft forever
</span></span><span class="line"><span class="cl">2: extern0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000
</span></span><span class="line"><span class="cl">    link/ether ca:1f:4a:9b:29:df brd ff:ff:ff:ff:ff:ff
</span></span><span class="line"><span class="cl">    inet6 fe80::c81f:4aff:fe9b:29df/64 scope link
</span></span><span class="line"><span class="cl">       valid_lft forever preferred_lft forever
</span></span><span class="line"><span class="cl">3: ppp0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1492 qdisc fq_codel state UNKNOWN group default qlen 3
</span></span><span class="line"><span class="cl">    link/ppp
</span></span><span class="line"><span class="cl">    inet 123.123.123.123 peer 123.123.123.1/32 scope global ppp0
</span></span><span class="line"><span class="cl">       valid_lft forever preferred_lft forever
</span></span><span class="line"><span class="cl">    inet6 240e:aaaa:bbbb:cccc:::eeee/64 scope global dynamic mngtmpaddr
</span></span><span class="line"><span class="cl">       valid_lft 259132sec preferred_lft 172732sec
</span></span><span class="line"><span class="cl">    inet6 fe80::aaaa:bbbb:cccc:dddd peer fe80::aaaa:bbbb:cccc:dddd/128 scope link
</span></span><span class="line"><span class="cl">       valid_lft forever preferred_lft forever
</span></span></code></pre></div><p>如果遇到了问题，可以使用<code>systemctl status netctl@extern0\\x2dprofile.service</code>查看一下错误信息。
如果是认证失败的话，重启几次这个service说不定就好了。</p>
<h2 id="配置dns和dhcp">配置DNS和DHCP</h2>
<p>安装<code>dnsmasq</code>，编辑<code>/etc/dnsmasq.conf</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># Setup listen address
</span></span><span class="line"><span class="cl">listen-address=10.10.10.1,127.0.0.1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Do not read /etc/resolv.conf
</span></span><span class="line"><span class="cl">no-resolv
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Use following dns servers
</span></span><span class="line"><span class="cl">server=114.114.114.114
</span></span><span class="line"><span class="cl">server=8.8.8.8
</span></span><span class="line"><span class="cl">server=8.8.4.4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Bind interface
</span></span><span class="line"><span class="cl">interface=intern0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Setup domain
</span></span><span class="line"><span class="cl">expand-hosts
</span></span><span class="line"><span class="cl">domain=foo.bar
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Setup IPv4 DHCP
</span></span><span class="line"><span class="cl">dhcp-range=10.10.10.100,10.10.10.255,255.255.255.0,12h
</span></span><span class="line"><span class="cl"># Setup IPv6 DHCP
</span></span><span class="line"><span class="cl">dhcp-range=fdaa:aaaa:bbbb::000a, fdaa:aaaa:bbbb::ffff, 64, 12h
</span></span></code></pre></div><p>使用<code>systemctl enable --now dnsmasq.service</code>启动<code>dnsmasq</code>，
之后重启路由器，使用网线连接将电脑连接到路由器的LAN口，顺利的话可以自动获取一个IP地址。</p>
<p>如果没获取到IP地址的话，有可能是DHCP服务器的问题，先尝试在电脑上手动设置一个IP地址，之后尝试ping路由器的IP（<code>10.10.10.1</code>）。
如果还是无法连接到路由器的话，就需要重新检查一下路由器的配置了。</p>
<h2 id="网络共享">网络共享</h2>
<p>首先<a href="https://wiki.archlinux.org/title/Internet_sharing#Enable_packet_forwarding">参照Wiki</a>，开启数据包转发的功能。</p>
<p>之后安装<code>iptables</code>，配置ipv4和ipv6的流量伪装。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">iptables -A FORWARD -i intern0 -j ACCEPT
</span></span><span class="line"><span class="cl">iptables -A FORWARD -o intern0 -j ACCEPT
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE
</span></span><span class="line"><span class="cl">iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
</span></span><span class="line"><span class="cl">iptables -A FORWARD -i intern0 -o ppp0 -j ACCEPT
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">iptables -t mangle -A FORWARD -o ppp0 -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ip6tables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE
</span></span></code></pre></div><p>之后可使用<code>iptables-save -f /etc/iptables/iptables.rules</code>和
<code>ip6tables-save -f /etc/iptables/ip6tables.rules</code>将ip桌子的规则保存下来。</p>
<h2 id="done">Done</h2>
<p>以上配置完成后，按理来说路由器就已经配置好了。</p>
<p>调试的过程为首先在路由器上尝试ping一个广域网的域名或IP地址（<code>8.8.8.8</code>），之后将路由器与电脑用网线连接，
电脑应当通过DHCP自动获取到一个随机的IP地址。
之后在电脑上尝试打开一些理应能打开的网站，应该是能打开的。</p>
<p>如果能电脑可以ping通一个广域网的IP，但是打不开网站的话，就检查一下路由器DNS配置，
如果路由器上能ping通一个广域网的IP，但电脑连IP地址都ping不通，那就去检查一下ip桌子的流量伪装规则，检查一下网口名字有没有写对之类的。</p>
<p>之后如果一切都调试成功的话，就可以把家里的无线路由器改成“有线中继”模式了，这样家里的无线路由器将只作为一个无线AP使用，路由的功能将全部由刚刚配置好的软路由实现。</p>
<p>配置好“有线中继”模式后，电脑连接无线WIFI后获得的IP地址应当是软路由分配的IP地址，网段为刚刚咱们设置的<code>10.10.10.*</code>，
而不再是<code>192.168.*</code>的IP地址了。</p>]]></content:encoded>
    </item>
    
    <item>
      <title>NanoPi R4S上手 &amp; 安装Arch Linux ARM</title>
      <link>https://blog.starry-s.moe/posts/2022/nanopi-r4s/</link>
      <pubDate>Fri, 13 May 2022 00:32:40 +0800</pubDate>
      
      <guid>https://blog.starry-s.moe/posts/2022/nanopi-r4s/</guid>
      <description>&lt;p&gt;前两天下单了个Nano Pi R4S，4G内存的版本。通常情况下这玩意别人都把他当软路由用，但是今天咱收到货后想了一会拍大腿一寻思这玩意不就是个ARM架构的小电脑嘛~&lt;/p&gt;
&lt;p&gt;所以咱暂时先不打算给这玩意装OpenWRT或 *WRT这类的路由器系统了，而是把它当成一个超小号的带俩网口的mini主机折腾。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>前两天下单了个Nano Pi R4S，4G内存的版本。通常情况下这玩意别人都把他当软路由用，但是今天咱收到货后想了一会拍大腿一寻思这玩意不就是个ARM架构的小电脑嘛~</p>
<p>所以咱暂时先不打算给这玩意装OpenWRT或 *WRT这类的路由器系统了，而是把它当成一个超小号的带俩网口的mini主机折腾。</p>
<meting-js server="netease" type="song" id="19563215" theme="#233333"></meting-js>
<h2 id="开箱">开箱</h2>
<p><img loading="lazy" src="images/nanopi_1.jpg" alt="&amp;ldquo;USB 3.0、SD卡插槽以及三脚架接口&amp;rdquo;" />
<p style="margin-bottom: -0.8em;" class="image-title">USB 3.0、SD卡插槽以及三脚架接口</p>
</p>
<p><img loading="lazy" src="images/nanopi_2.jpg" alt="&amp;ldquo;供电接口和网口&amp;rdquo;" />
<p style="margin-bottom: -0.8em;" class="image-title">供电接口和网口</p>
</p>
<p><img loading="lazy" src="images/nanopi_3.jpg" alt="&amp;ldquo;正面&amp;rdquo;" />
<p style="margin-bottom: -0.8em;" class="image-title">正面</p>
</p>
<h2 id="拆解">拆解</h2>
<p>咱收到货后第一件事就是找螺丝刀和塑料卡片把这漏油器拆开看看（</p>
<p><img loading="lazy" src="images/nanopi_7.jpg" alt="" />
<p style="margin-bottom: -0.8em;" class="image-title">主板正面</p>
</p>
<p>芯片的布局可以在<a href="https://www.friendlyelec.com/index.php?route=product/product&amp;product_id=284">R4S的商品页面</a>查到，<a href="https://wiki.friendlyelec.com/wiki/index.php/NanoPi_R4S">官方Wiki</a>上也有更多关于R4S的介绍。</p>
<h2 id="arch-linux-arm">Arch Linux ARM</h2>
<p>在Arch Linux ARM (简称alarm) 官网上没找到对R4S的官方的支持，简单搜了一下armbian有对R4S的官方支持。</p>
<p>因为用惯了<strong>滚动更新</strong>发行版，所以不想用*bian系统，而*WRT系统的软件包相对其他发行版而言更少一些，系统也相当于被魔改过，所以除了做漏油器之外几乎干不了别的，所以这是我想安装Arch Linux的理由。</p>
<p>然后咱搜到了一篇给<a href="https://gist.github.com/larsch/a8f13faa2163984bb945d02efb897e6d">NanoPi R2S安装alarm的教程</a>，评论里有人提到了给R4S安装也是可以的。</p>
<p>所以咱大致把这个教程翻译一下，再修改一些R2S和R4S在安装时的区别。</p>
<p>以下内容需结合alarm的 <a href="https://archlinuxarm.org/platforms/armv8/generic">aarch64通用安装教程</a>食用，像更新pacman-key，ssh的密码之类的部分咱就不在这里重复了。</p>
<h3 id="准备sd卡">准备SD卡</h3>
<ol start="0">
<li>
<p>下载armbian的镜像，下载链接自行谷歌。</p>
<blockquote>
<p>通常下载好的文件是<code>xz</code>格式的压缩文件，需要使用<code>unxz</code>解压成<code>img</code>镜像。</p>
</blockquote>
</li>
<li>
<p>将armbian镜像的<code>bootloader</code>和<code>uboot</code>(32-32767区块的部分)用<code>dd</code>写到SD卡中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># Clean the sector before 32
</span></span><span class="line"><span class="cl">dd if=/dev/zero of=/dev/sdX bs=1M count=32
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Write uBoot and bootloader
</span></span><span class="line"><span class="cl">dd if=Armbian_*.img of=/dev/sdX skip=31 seek=31 bs=512 count=32736
</span></span></code></pre></div><blockquote>
<p>其实可以直接用<code>dd</code>把armbian的整个镜像写到内存卡中然后插入R4S开机，第一次开机后他会自动重新给内存卡分区，然后只需把<code>/dev/sdX1</code>格式化成ext4就能安装alarm了。</p>
</blockquote>
</li>
<li>
<p>使用<code>fdisk</code>给内存卡分区并格式化文件系统</p>
<p>创建分区时先按<code>o</code>创建个MBR分区表，然后按<code>n</code>添加分区。第一个分区的起始区块(sector)需要设置为32768，通常情况下分一个区就够用了，或者你可以像我这样分俩区，一个给swap，不过实际没啥必要。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Disk /dev/mmcblk1: 29.72 GiB, 31914983424 bytes, 62333952 sectors
</span></span><span class="line"><span class="cl">Units: sectors of 1 * 512 = 512 bytes
</span></span><span class="line"><span class="cl">Sector size (logical/physical): 512 bytes / 512 bytes
</span></span><span class="line"><span class="cl">I/O size (minimum/optimal): 512 bytes / 512 bytes
</span></span><span class="line"><span class="cl">Disklabel type: dos
</span></span><span class="line"><span class="cl">Disk identifier: 0x33fc535e
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Device         Boot    Start      End  Sectors  Size Id Type
</span></span><span class="line"><span class="cl">/dev/mmcblk1p1         32768 53944319 53911552 25.7G 83 Linux
</span></span><span class="line"><span class="cl">/dev/mmcblk1p2      53944320 62333951  8389632    4G 82 Linux swap / Solaris
</span></span></code></pre></div><p>创建完分区后，把<code>root</code>分区<code>mkfs.ext4</code>格式化成ext4，swap分区用<code>mkswap</code>格式化。</p>
</li>
<li>
<p>解压alarm系统文件到root分区中</p>
</li>
<li>
<p>复制并替换armbian的<code>/boot</code>中的文件到新建分区的<code>/boot</code>文件夹中。</p>
</li>
<li>
<p>编辑<code>/boot/armbianEnv.txt</code>，更新<code>rootdev</code>的UUID
使用<code>blkid</code>或者<code>lsblk -o+UUID</code>可以查看UUID，注意是<strong>UUID</strong>不是PARTUUID。</p>
</li>
<li>
<p>插电，开机 (<del>此处不会出现五安大电牛</del>)，网线连接R4S的WAN口到路由器的LAN口，第一次开机需要生成SSH Key所以时间会久一些，然后就可以ssh到R4S上去辣。</p>
</li>
</ol>
<h3 id="内核">内核</h3>
<p>上述的安装步骤使用的armbian的内核，可以正常开机，但是想用Arch Linux stock aarch64内核的话，得替换一下DTB文件。（DTB文件是啥我目前还不清楚，如果后续弄明白了再更新到博客上吧）</p>
<ol>
<li>
<p>ssh到R4S中，安装<code>linux-aarch64</code>。</p>
</li>
<li>
<p>修改使用的DTB文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cd /boot
</span></span><span class="line"><span class="cl">rm dtb
</span></span><span class="line"><span class="cl">ln -sf dtbs dtb
</span></span></code></pre></div><p>编辑<code>armbianEnv.txt</code>，在末尾添加一行<code>fdtfile=rockchip/rk3399-rockpro64.dtb</code>。</p>
<blockquote>
<p>在<code>/boot/dtb/rockchip</code>目录下是可以找到<code>rk3399-nanopi-r4s.dtb</code>文件的，但是目前用这个DTB的话会导致PCIE不能正常工作，导致LAN口无法使用。
<code>dmesg</code>的输出为：</p>
</blockquote>
<blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-prolog" data-lang="prolog"><span class="line"><span class="cl"><span class="s">dmesg</span> <span class="p">|</span> <span class="s">grep</span> <span class="s">pci</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span>    <span class="mf">0.538310</span><span class="p">]</span> <span class="s">ehci</span><span class="o">-</span><span class="nn">pci</span><span class="p">:</span> <span class="nv">EHCI</span> <span class="nv">PCI</span> <span class="s">platform</span> <span class="s">driver</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span>    <span class="mf">0.559708</span><span class="p">]</span> <span class="s">ohci</span><span class="o">-</span><span class="nn">pci</span><span class="p">:</span> <span class="nv">OHCI</span> <span class="nv">PCI</span> <span class="s">platform</span> <span class="s">driver</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span>    <span class="mf">2.999933</span><span class="p">]</span> <span class="s">rockchip</span><span class="o">-</span><span class="s">pcie</span> <span class="s">f8000000</span><span class="p">.</span><span class="nn">pcie</span><span class="p">:</span> <span class="s">host</span> <span class="s">bridge</span> <span class="o">/</span><span class="s">pcie@f8000000</span> <span class="nn">ranges</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span>    <span class="mf">2.999974</span><span class="p">]</span> <span class="s">rockchip</span><span class="o">-</span><span class="s">pcie</span> <span class="s">f8000000</span><span class="p">.</span><span class="nn">pcie</span><span class="p">:</span>      <span class="nv">MEM</span> <span class="mh">0x00fa000000</span><span class="p">.</span><span class="mf">.0</span><span class="s">x00fbdfffff</span> <span class="s">-&gt;</span> <span class="mh">0x00fa000000</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span>    <span class="mf">2.999987</span><span class="p">]</span> <span class="s">rockchip</span><span class="o">-</span><span class="s">pcie</span> <span class="s">f8000000</span><span class="p">.</span><span class="nn">pcie</span><span class="p">:</span>       <span class="nv">IO</span> <span class="mh">0x00fbe00000</span><span class="p">.</span><span class="mf">.0</span><span class="s">x00fbefffff</span> <span class="s">-&gt;</span> <span class="mh">0x00fbe00000</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span>    <span class="mf">3.000410</span><span class="p">]</span> <span class="s">rockchip</span><span class="o">-</span><span class="s">pcie</span> <span class="s">f8000000</span><span class="p">.</span><span class="nn">pcie</span><span class="p">:</span> <span class="s">no</span> <span class="s">vpcie12v</span> <span class="s">regulator</span> <span class="s">found</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span>    <span class="mf">3.500881</span><span class="p">]</span> <span class="s">rockchip</span><span class="o">-</span><span class="s">pcie</span> <span class="s">f8000000</span><span class="p">.</span><span class="nn">pcie</span><span class="p">:</span> <span class="nv">PCIe</span> <span class="s">link</span> <span class="s">training</span> <span class="s">gen1</span> <span class="s">timeout</span><span class="p">!</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span>    <span class="mf">3.500944</span><span class="p">]</span> <span class="s">rockchip</span><span class="o">-</span><span class="nn">pcie</span><span class="p">:</span> <span class="s">probe</span> <span class="s">of</span> <span class="s">f8000000</span><span class="p">.</span><span class="s">pcie</span> <span class="s">failed</span> <span class="s">with</span> <span class="s">error</span> <span class="o">-</span><span class="mi">110</span>
</span></span></code></pre></div><p>于是就先用rockpro64的DTB文件了。</p>
</blockquote>
</li>
<li>
<p>创建uBoot镜像和initramfs。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pacman -S uboot-tools
</span></span><span class="line"><span class="cl">mkimage -A arm64 -T ramdisk -n uInitrd -d /boot/initramfs-linux.img /boot/uInitrd-initramfs-linux.img
</span></span><span class="line"><span class="cl">ln -sf /boot/uInitrd-initramfs-linux.img /boot/uInitrd
</span></span></code></pre></div><p>创建个<code>pacman</code>的钩子，在以后更新<code>linux-aarch64</code>的时候自动的重新构建uboot和initramfs。</p>
<p>在<code>mkdir -p /etc/pacman.d/hooks</code>目录下创建<code>/etc/pacman.d/hooks/initramfs.hook</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pacmanconf" data-lang="pacmanconf"><span class="line"><span class="cl"><span class="k">[Trigger]</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">Operation</span> <span class="o">=</span> Install<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">Operation</span> <span class="o">=</span> Upgrade<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">Type</span> <span class="o">=</span> Package<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">Target</span> <span class="o">=</span> linux-aarch64<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">
</span></span></span><span class="line"><span class="cl"><span class="k">[Action]</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">Description</span> <span class="o">=</span> Generate uInitrd<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">Exec</span> <span class="o">=</span> /usr/bin/mkimage -A arm64 -T ramdisk -n uInitrd -d /boot/initramfs-linux.img /boot/uInitrd-initramfs-linux.img<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">When</span> <span class="o">=</span> PostTransaction<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">Depends</span> <span class="o">=</span> uboot-tools<span class="err">
</span></span></span></code></pre></div></li>
<li>
<p>重启，<code>uname -a</code>输出的应该是新版本的内核了。</p>
<p>有个细节，用armbian的DTB文件时，开机后SYS LED灯是闪烁的，但是换到rockpro60的DTB文件后只有PWR灯长亮，别的灯都不闪了。</p>
</li>
</ol>
<h2 id="router">Router</h2>
<p>虽然装的是Arch Linux ARM系统，但是这并不代表它不能作为一个路由器使用。</p>
<p>系统默认用的是<code>systemd-networkd</code>管理网络，所以以下内容使用<code>systemd-networkd</code>配置路由器，暂时没遇到问题，如果不行的话我再换别的。</p>
<blockquote>
<p>参考: <a href="https://wiki.archlinux.org/title/Router">Router - ArchWiki</a></p>
</blockquote>
<h3 id="重命名网络接口">重命名网络接口</h3>
<blockquote>
<p>这一步并非必须，但是我有遇到重启系统后网口从<code>eth0</code>变成<code>eth1</code>的情况，所以还是给网口重命个名好一些。</p>
</blockquote>
<p>首先移除并备份<code>/etc/systemd/network</code>中原有的配置文件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">cd</span> /etc/systemd/network
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># backup config files</span>
</span></span><span class="line"><span class="cl">mv ./* /root/
</span></span></code></pre></div><p>获取WAN口的mac地址。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cat /sys/class/net/eth0/address
</span></span><span class="line"><span class="cl">12:34:56:78:90:ab
</span></span></code></pre></div><p>创建<code>10-extern0.link</code>，重命名<code>eth0</code>到<code>extern0</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pacmanconf" data-lang="pacmanconf"><span class="line"><span class="cl"><span class="k">[Match]</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">MACAddress</span><span class="o">=</span>12:34:56:78:90:ab<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">
</span></span></span><span class="line"><span class="cl"><span class="k">[Link]</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">Description</span><span class="o">=</span>WAN<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">Name</span><span class="o">=</span>extern0<span class="err">
</span></span></span></code></pre></div><p>另一个网口(LAN)在开机时<code>systemd-networkd</code>会自动给他重命名为<code>enp1s0</code>。</p>
<h3 id="wan口配置dhcp客户端">WAN口配置DHCP客户端</h3>
<p>这里我是把R4S的WAN口接到另一台路由器的LAN上，所以配置的是DHCP客户端。如果你打算直接把路由器接光猫，而且你的猫设置了桥接，那么你可能需要配置PPPOE。</p>
<p>创建<code>20-extern0.network</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pacmanconf" data-lang="pacmanconf"><span class="line"><span class="cl"><span class="k">[Match]</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">Name</span><span class="o">=</span>extern0<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">
</span></span></span><span class="line"><span class="cl"><span class="k">[Network]</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">DHCP</span><span class="o">=</span>yes<span class="err">
</span></span></span></code></pre></div><h3 id="lan口配置静态ip和dhcp服务器">LAN口配置静态IP和DHCP服务器</h3>
<p>给LAN口设置成另一个网络的静态IP地址，并配置DHCP服务器，给连接到LAN口的机器分配同一个网络下的其他IP地址。</p>
<p>创建<code>20-enp1s0.network</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-pacmanconf" data-lang="pacmanconf"><span class="line"><span class="cl"><span class="k">[Match]</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">Name</span><span class="o">=</span>enp1s0<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">
</span></span></span><span class="line"><span class="cl"><span class="k">[Network]</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">Address</span><span class="o">=</span>10.0.0.1/24<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">DHCPServer</span><span class="o">=</span>true<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">IPMasquerade</span><span class="o">=</span>both<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">
</span></span></span><span class="line"><span class="cl"><span class="k">[DHCPServer]</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">PoolOffset</span><span class="o">=</span>100<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">PoolSize</span><span class="o">=</span>100<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="na">EmitDNS</span><span class="o">=</span>yes<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c1"># DNS=8.8.8.8</span><span class="err">
</span></span></span></code></pre></div><p>我这个配置是给LAN口设置了静态IP地址<code>10.0.0.1</code>，掩码<code>255.255.255.0</code>，启用了DHCP服务器，
设置了IPv4数据“伪装”(packets forwarded from the network interface will be appear as coming from the local host)。</p>
<p>有关配置文件的参数可以使用<code>man systemd.network</code>查询。</p>
<p>暂时还没搞懂怎么折腾IPv6，如果配置好IPv6的话我再补上……</p>
<h2 id="后续">后续</h2>
<p>之后咱装了JDK以及一堆我常用的小组件。为了测试性能，我把我以前备份的Minecraft服务器复制到R4S上跑了一下试试。我的服务器之前是在疼讯云学生主机上跑的(1核2G)，装了好多性能优化插件(lithium，phosphor，carpet&hellip;)，版本是1.16.4，抱着尝试的心态跑了一下这个服务器结果发现很流畅，一开始区块加载的时候CPU的6个核心全跑满，之后就恢复到正常水平了。刚才尝试了一下长时间的生成区块貌似没什么大的问题，只要别一直用鞘翅跑图就行，应该是内存够用了所以运行效果要好一些，不过单核性能来讲的话肯定还是X86吊打R4S的。</p>
<p>毕竟这就是半个巴掌大小的机器，跑MC的时候CPU温度才不到50度，应该不需要主动散热，功耗才十多瓦……</p>
<p><img loading="lazy" src="images/nanopi_performance.png" alt="&amp;ldquo;MineCraft Server Performance&amp;rdquo;" />
<p style="margin-bottom: -0.8em;" class="image-title">MineCraft Server Performance</p>
</p>
<p><img loading="lazy" src="images/nanopi_neofetch.png" alt="&amp;ldquo;Arch Linux ARM&amp;rdquo;" />
<p style="margin-bottom: -0.8em;" class="image-title">Arch Linux ARM</p>
</p>
<h2 id="参烤链接">参烤链接</h2>
<ul>
<li><a href="https://www.friendlyelec.com/index.php?route=product/product&amp;product_id=284">NanoPi R4S</a></li>
<li><a href="https://wiki.friendlyelec.com/wiki/index.php/NanoPi_R4S">NanoPi R4S - FriendlyELEC WiKi</a></li>
<li><a href="https://gist.github.com/larsch/a8f13faa2163984bb945d02efb897e6d">Installing Arch Linux AArch64 on the NanoPi R2S</a></li>
<li><a href="https://archlinuxarm.org/platforms/armv8/generic">Generic AArch64 Installation | Arch Linux ARM</a></li>
<li><a href="https://wiki.archlinux.org/title/Router">Router - ArchWiki</a></li>
<li><a href="https://wiki.archlinux.org/title/Systemd-networkd">systemd-networkd - ArchWiki</a></li>
<li><a href="https://man.archlinux.org/man/systemd.network.5">systemd.network(5) — Arch manual pages</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/392619184">在 NanoPi R2S 上安装 Archlinuxarm - 知乎</a></li>
</ul>]]></content:encoded>
    </item>
    
    <item>
      <title>自建RSS服务器：Miniflux</title>
      <link>https://blog.starry-s.moe/posts/2022/miniflux-build/</link>
      <pubDate>Tue, 01 Mar 2022 22:24:17 +0800</pubDate>
      
      <guid>https://blog.starry-s.moe/posts/2022/miniflux-build/</guid>
      <description>&lt;p&gt;之前咱自己搭过一个Miniflux服务器，不过当时用得并不频繁，逐渐的被咱弃用了。&lt;/p&gt;
&lt;p&gt;最近想订阅一些网站，因为使用RSS订阅的话，能收到更新提醒，不用经常的翻收藏夹去看页面内容有没有更新，使用RSS订阅的话也方便集中管理一些，
而且还能绕开推荐算法，只看自己想看的内容，这点还是蛮重要的。&lt;/p&gt;
&lt;p&gt;思考了几天发现我确实需要一个RSS订阅服务器后，于是决定这次把搭建过程记录下来，省得以后又忘了。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>之前咱自己搭过一个Miniflux服务器，不过当时用得并不频繁，逐渐的被咱弃用了。</p>
<p>最近想订阅一些网站，因为使用RSS订阅的话，能收到更新提醒，不用经常的翻收藏夹去看页面内容有没有更新，使用RSS订阅的话也方便集中管理一些，
而且还能绕开推荐算法，只看自己想看的内容，这点还是蛮重要的。</p>
<p>思考了几天发现我确实需要一个RSS订阅服务器后，于是决定这次把搭建过程记录下来，省得以后又忘了。</p>
<hr>
<h2 id="准备">准备</h2>
<p>Miniflux官方文档（EN）：<a href="https://miniflux.app/docs/index.html">https://miniflux.app/docs/index.html</a></p>
<h2 id="安装">安装</h2>
<p>此部分配合官方文档食用：<a href="https://miniflux.app/docs/installation.html">https://miniflux.app/docs/installation.html</a></p>
<h3 id="配置数据库">配置数据库：</h3>
<p>首先需要安装postgresql数据库。安装方法因发行版而异，网上一搜就有。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># Switch to the postgres user
</span></span><span class="line"><span class="cl">$ sudo su - postgres
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Create a database user for miniflux
</span></span><span class="line"><span class="cl">$ createuser -P miniflux
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Create a database for miniflux that belongs to our user
</span></span><span class="line"><span class="cl">$ createdb -O miniflux miniflux
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Create the extension hstore as superuser
</span></span><span class="line"><span class="cl">$ psql miniflux -c &#39;create extension hstore&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Change postgres password
</span></span><span class="line"><span class="cl">$ psql
</span></span><span class="line"><span class="cl">&gt; \password
</span></span></code></pre></div><h3 id="安装miniflux">安装Miniflux：</h3>
<p>不同的发行版使用方法不一样，咱的这台服务器为Ubuntu，所以参照<a href="https://miniflux.app/docs/howto.html#apt-repo">这里的教程</a>配置APT源，安装Miniflux。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">curl -s https://apt.miniflux.app/KEY.gpg | sudo apt-key add -
</span></span><span class="line"><span class="cl">echo &#34;deb https://apt.miniflux.app/ /&#34; | sudo tee /etc/apt/sources.list.d/miniflux.list &gt; /dev/null
</span></span><span class="line"><span class="cl">apt update
</span></span><span class="line"><span class="cl">apt install miniflux
</span></span></code></pre></div><h2 id="配置miniflux">配置Miniflux</h2>
<p>默认配置文件为：<code>/etc/miniflux.conf</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># See https://miniflux.app/docs/configuration.html
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">LISTEN_ADDR=0.0.0.0:8080
</span></span><span class="line"><span class="cl">LOG_DATE_TIME=yes
</span></span><span class="line"><span class="cl">DATABASE_URL=user=postgres password=&lt;YOURPASSWORD&gt; dbname=miniflux sslmode=disable
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Run SQL migrations automatically
</span></span><span class="line"><span class="cl"># RUN_MIGRATIONS=1
</span></span></code></pre></div><p>之后线将刚刚创建的数据库用户<code>miniflux</code>设置为超级用户。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ sudo su - postgres
</span></span><span class="line"><span class="cl">$ psql
</span></span><span class="line"><span class="cl">&gt; ALTER USER miniflux WITH SUPERUSER;
</span></span></code></pre></div><p>使用以下指令创建数据库表，并创建用户：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ miniflux -c /etc/miniflux.conf -migrate
</span></span><span class="line"><span class="cl">$ miniflux -c /etc/miniflux.conf -create-admin
</span></span></code></pre></div><p>之后将<code>miniflux</code>切换回普通用户。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ sudo su - postgres
</span></span><span class="line"><span class="cl">$ psql
</span></span><span class="line"><span class="cl">&gt; ALTER USER miniflux WITH NOSUPERUSER;
</span></span></code></pre></div><p>最后重新启动<code>miniflux</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ sudo systemctl restart miniflux
</span></span></code></pre></div><h2 id="配置ssl可选">配置SSL（可选）</h2>
<p>使用nginx转发流量，可以将服务器套在Cloudflare下面。</p>
<p>编辑nginx的服务器配置文件，创建一个端口为443的服务器，并指定SSL key的位置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">server {
</span></span><span class="line"><span class="cl">	listen 443 ssl default_server;
</span></span><span class="line"><span class="cl">	listen [::]:443 ssl default_server;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	server_name miniflux;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	ssl_certificate /path/to/server.crt;
</span></span><span class="line"><span class="cl">	ssl_certificate_key /path/to/server.key;
</span></span><span class="line"><span class="cl">	ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	location / {
</span></span><span class="line"><span class="cl">    		proxy_pass  http://127.0.0.1:8080;
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>之后执行<code>sudo systemctl restart nginx</code>，访问服务器地址即可。</p>
<h2 id="others">Others</h2>
<p>Miniflux支持Fever和Google Reader等第三方服务，参考<a href="https://miniflux.app/docs/services.html">官方文档</a>，可以在服务器的设置-&gt;集成页面中配置，之后在别的设备中安装客户端，可以阅读订阅的文章，比网页版好用一些。</p>
<p><strong>STARRY-S</strong></p>]]></content:encoded>
    </item>
    
    <item>
      <title>使用树莓派搭建一个NAS</title>
      <link>https://blog.starry-s.moe/posts/2021/raspberry_pi_nas/</link>
      <pubDate>Sat, 25 Sep 2021 22:20:03 +0800</pubDate>
      
      <guid>https://blog.starry-s.moe/posts/2021/raspberry_pi_nas/</guid>
      <description>&lt;p&gt;把吃灰了好久的树莓派带了过来，打算搞个NAS玩一下，简短的记录一下整个过程。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>把吃灰了好久的树莓派带了过来，打算搞个NAS玩一下，简短的记录一下整个过程。</p>
<meting-js server="netease" type="song" id="750905" theme="#233333"></meting-js>
<blockquote>
<p>这歌太魔性了哈哈哈哈哈……</p>
</blockquote>
<h2 id="准备工作">准备工作</h2>
<ul>
<li>树莓派以及所需的电源（废话）</li>
<li>16G以上的高速内存卡用来写系统镜像</li>
<li>硬盘（可以选择买移动硬盘或者直接买硬盘盒和机械硬盘自己组装）</li>
<li>网络设备：路由器、网线</li>
<li>（非必须）键盘、显示器、连接线等</li>
</ul>
<p>树莓派我使用的是高一时买的树莓派3B（满满的回忆），硬盘是上半年为了存照片而买的西数2T移动硬盘，因为暂时闲置所以拿来一起组个云盘玩。</p>
<p>内存卡需要质量好的不容易坏而且读写比较快的卡。</p>
<h2 id="装系统">装系统</h2>
<p>系统咱安装的是<a href="https://archlinuxarm.org/platforms/armv8/broadcom/raspberry-pi-3">ArchLinux ARM</a>，安装教程直接看官方文档即可。</p>
<p>一开始咱为了发挥树莓派3B的64位CPU的性能，我下载了64位的系统镜像，但是在配置无线连接的时候（可能是）驱动问题卡死，因为急着睡觉所以重新格式化内存卡后被迫安装32位的系统。</p>
<p>安装教程咱就不重复写到博客里了，直接翻Wiki，尽管是纯英文的但是不难，都能看懂。咱就不打算在这翻译了。</p>
<p>在格式化<code>root</code>分区时一开始想尝试一下树莓派上跑<code>btrfs</code>，但是开机时进了linux的救援(rescue)模式，懒得折腾还是老老实实换回了<code>ext4</code>，<del>不然我一晚上不用睡觉了</del>。</p>
<p>在分区时除了<code>boot</code>和<code>root</code>之外，我额外分了2G的<code>swap</code>分区，树莓派1G内存有些小不过只是搭个人用的NAS的话实际上是不影响使用的。（<del>这话咋读着这么别扭呢</del>）</p>
<p>因为咱要做NAS肯定得往树莓派上外接个硬盘之类的，树莓派3B只有USB 2.0 + 百兆网口，尽管速度很慢但是作为个人网盘来说不到10MB/S的速度还是比某些恶心网盘快很多的，在线看个1080P视频还是蛮轻松的，BD蓝光想想还是算了。</p>
<p>把移动硬盘接到树莓派后<code>lsblk</code>查看一下分区表。因为咱这是块几乎全新的硬盘所以需要重新分区并格式化一下。</p>
<p>如果你不熟悉在命令行上进行分区格式化的话，建议自行翻阅<a href="https://wiki.archlinux.org/title/fdisk">Wiki (fdisk)</a>，因为往博客上写的话太难理解了别人肯定看不懂。</p>
<p>最后咱把2T移动硬盘格式化成这个样子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl"># fdisk -l /dev/sda
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Device          Start        End    Sectors  Size Type
</span></span><span class="line"><span class="cl">/dev/sda1        2048 2147485695 2147483648    1T Linux filesystem
</span></span><span class="line"><span class="cl">/dev/sda2  2147485696 3907029133 1759543438  839G Microsoft basic data
</span></span></code></pre></div><p>其中的1T打算格式化为<code>btrfs</code>给Samba用，其余的800G打算格式化为<code>NTFS</code>留着给Windows当个移动硬盘。</p>
<p>创建分区时别忘了更改分区类型，给Linux用的就是<code>Linux filesystem</code>，给Windows用的就是<code>Microsoft basic data</code>，
不然机械硬盘连接到Windows系统中将不显示分区，或者就是一直提醒你：该分区不可用，然后让你格式化，到时候一不小心点错了可是会丢数据的。</p>
<p>安装<code>btrfs-progs</code>和<code>ntfs-3g</code>，之后格式化硬盘（NTFS还是建议到Windows系统中格式化）。</p>
<p>格式化btrfs的时候加个<code>-L</code>参数设置分区的标签，这样方便在fstab中设置开机自动挂载。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">$ lsblk                                # 一定要看清楚自己格式化的分区名字
</span></span><span class="line"><span class="cl">$ sudo mkfs.btrfs /dev/sdaX -L samba   # -L 参数设置分区的标签
</span></span></code></pre></div><p>最后改一下<code>/etc/fstab</code>让设备在开机时自动挂载交换分区和移动硬盘。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># &lt;file system&gt; &lt;dir&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;
</span></span><span class="line"><span class="cl">/dev/mmcblk0p1  /boot   vfat    defaults        0       0
</span></span><span class="line"><span class="cl">LABEL=swap      none    swap    defaults        0       0
</span></span><span class="line"><span class="cl">LABEL=samba     /samba  btrfs   defaults        0       0
</span></span></code></pre></div><p>重启系统后如果正常的话，分区会被自动挂载。</p>
<h2 id="配置网络">配置网络</h2>
<blockquote>
<p>配置网络部分不适合在SSH中操作，建议使用显示器和键盘连接到树莓派上操作。</p>
<p>除非你能保证你执行的每个命令都肥肠正确。</p>
</blockquote>
<h3 id="无线网络">无线网络</h3>
<p>因为我电脑离路由器肥肠远，所以为了方便我还要给树莓派配置无线网络。首先照着<a href="https://wiki.archlinux.org/title/Netctl">Wiki上的netctl页面</a>安装了<code>wifi-menu</code>所需要用的<code>dialog</code>，然后就用<code>wifi-menu</code>连接wifi了。不过为了方便以后连接，我需要给他设置静态IP：</p>
<p>首先使用你比较喜欢的文本编辑器打开<code>wifi-menu</code>自动生成的配置文件，并修改成以下的样子</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># /etc/netctl.d/wlan0-YourWifiName
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Description=&#39;Automatically generated profile by wifi-menu&#39;
</span></span><span class="line"><span class="cl">Interface=wlan0
</span></span><span class="line"><span class="cl">Connection=wireless
</span></span><span class="line"><span class="cl">Security=wpa
</span></span><span class="line"><span class="cl">ESSID=Your Wifi Name
</span></span><span class="line"><span class="cl">IP=static
</span></span><span class="line"><span class="cl">Address=(&#39;192.168.xxx.xxx/24&#39;)
</span></span><span class="line"><span class="cl">Gateway=&#39;192.168.xxx.1&#39;
</span></span><span class="line"><span class="cl">DNS=&#39;8.8.8.8&#39;
</span></span><span class="line"><span class="cl">Key=YOUR WIFI PASSWORD
</span></span></code></pre></div><p>其中修改<code>Address</code>为你想设置的CIDR地址、<code>Gateway</code>为默认网关、以及<code>DNS</code>。</p>
<p>最后修改<code>Key</code>为Wifi密码（明文），如果需要加密的话可以去wiki上找相应方法。</p>
<p>之后<code>sudo netctl enable wlan0-YourWifiName</code>设置好开机自动连接即可。</p>
<p>这时候聪明的小伙伴会想到：我想使用网线联网并配置静态IP，该怎么办呢？</p>
<h3 id="配置有线网络">配置有线网络</h3>
<p>默认情况下，有线接口<code>eth0</code>使用<code>systemd-network</code>配置了<code>DHCP</code>，所以我们不需要改<code>netctl</code>的配置文件，只编辑<code>/etc/systemd/network/eth0.network</code>这个配置文件改成静态IP地址就好了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[Match]
</span></span><span class="line"><span class="cl">Name=eth0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[Network]
</span></span><span class="line"><span class="cl">Address=192.168.xxx.xxx/24
</span></span><span class="line"><span class="cl">Gateway=192.168.xxx.1
</span></span><span class="line"><span class="cl">DNS=8.8.8.8
</span></span></code></pre></div><p>重启系统后，使用<code>ip addr</code>检查设备的IP地址是否正确。</p>
<h3 id="配置防火墙">配置防火墙</h3>
<p>首先安装<code>ufw</code>。（因为对iptables不是十分熟悉，ufw比ip桌子好用一些，毕竟他叫<strong>Uncomplicated Filewall</strong>，所以咱先用ufw配置防火墙）</p>
<p>食用方法请参见<a href="https://wiki.archlinux.org/title/Uncomplicated_Firewall">Wiki页面</a>。</p>
<p>因为咱打算搭一个Samba服务器，所以别忘了配置防火墙允许Samba的端口，按照Arch Linux Wiki：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># Create or Edit /etc/ufw/applications.d/samba, add following content:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[Samba]
</span></span><span class="line"><span class="cl">title=LanManager-like file and printer server for Unix
</span></span><span class="line"><span class="cl">description=Samba
</span></span><span class="line"><span class="cl">ports=137,138/udp|139,445/tcp
</span></span></code></pre></div><p>之后root账户执行<code>ufw app update Samba</code>加载配置文件，然后<code>ufw allow Samba</code>允许Samba的端口。</p>
<p>如果你的树莓派上还装有其他服务（比如http，https等），别忘了<code>ufw allow PORT</code>开放端口，尤其是别忘了开SSH端口。</p>
<p>最后<code>ufw status</code>查看防火墙状态信息，<code>ufw enable</code>开启防火墙。</p>
<h2 id="samba">Samba</h2>
<p>配合<a href="https://wiki.archlinux.org/title/Samba">Arch Wiki</a>食用。</p>
<p>首先我们需要新建一个分组，然后在挂载的分区中新建一个文件夹作为Samba服务器的共享目录：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ sudo groupadd -r sambausers          # 新建用户组
</span></span><span class="line"><span class="cl">$ sudo usermod -aG sambausers username # 添加当前用户至分组中
</span></span><span class="line"><span class="cl">$ sudo smbpasswd -a sambausers         # 设置Samba用户的密码
</span></span><span class="line"><span class="cl">$ sudo mkdir /samba/sharefolder        # 新建文件夹用来存储共享的文件
</span></span><span class="line"><span class="cl">$ sudo chown :username /samba/sharefolder   # 修改文件夹的所属分组
</span></span><span class="line"><span class="cl">$ sudo chmod 0770 /samba/sharefolder   # 修改权限
</span></span></code></pre></div><p>（咱写的很详细了吧</p>
<h3 id="配置服务器">配置服务器</h3>
<p>安装好<code>samba</code>安装包后，需要手动去<code>/etc/samba/</code>创建<code>smb.conf</code>配置文件，可以到<a href="https://git.samba.org/samba.git/?p=samba.git;a=blob_plain;f=examples/smb.conf.default;hb=HEAD">Samba git repository</a>中获取样例配置文件，咱只需要把它复制粘贴再简单修改一下就好了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># /etc/samba/smb.conf
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[global]
</span></span><span class="line"><span class="cl"># 修改工作组的名字
</span></span><span class="line"><span class="cl">workgroup = MYGROUP
</span></span><span class="line"><span class="cl"># 服务器描述
</span></span><span class="line"><span class="cl">server string = Raspberry pi Samba Server
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 在文件末尾添加共享文件夹目录及相关配置
</span></span><span class="line"><span class="cl">[sambashare]
</span></span><span class="line"><span class="cl">comment = Sample share file.
</span></span><span class="line"><span class="cl">path = /path/to/your/samba/folder
</span></span><span class="line"><span class="cl">writable = yes
</span></span><span class="line"><span class="cl">browsable = yes
</span></span><span class="line"><span class="cl">create mask = 0755
</span></span><span class="line"><span class="cl">directory mask = 0755
</span></span><span class="line"><span class="cl">read only = no
</span></span><span class="line"><span class="cl">guest ok = no  # 允许访客随意登录
</span></span></code></pre></div><p>配置好文件后，启动<code>smb.service</code>和<code>nmb.service</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ sudo systemctl <span class="nb">enable</span> --now smb.service
</span></span><span class="line"><span class="cl">$ sudo systemctl <span class="nb">enable</span> --now nmb.service
</span></span></code></pre></div><h3 id="访问服务器">访问服务器</h3>
<p>咱GNOME用户直接打开文件管理器，选择左边的“+ Other Locations”，在底部输入服务器连接<code>smb://192.168.xxx.xxx</code>，
输入用户组、用户名和密码登录就可以访问共享文件夹。</p>
<p>Windows系统中，首先需要到 控制面板-&gt;程序-&gt;启用或关闭Windows功能 里面，选中 SMB1.0/CIFS文件共享直通，保存后等一会安装完，
打开文件资源管理器输入地址<code>\\192.168.xxx.xxx\</code>，登录后就能访问共享文件夹了。</p>
<h2 id="frp内网穿透">Frp内网穿透</h2>
<blockquote>
<p>配合<a href="https://gofrp.org/docs/">frp文档</a>食用更佳</p>
</blockquote>
<p>首先在frp的<a href="https://github.com/fatedier/frp/releases">GitHub Release</a>页面下载安装包。</p>
<p>如果是树莓派用的话就下载<code>arm</code>版本的安装包即可。Arch Linux可以在ArchLinux CN源或AUR中安装<code>frpc</code>和<code>frps</code>作为客户端和服务端。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># 树莓派上下载编译好的文件</span>
</span></span><span class="line"><span class="cl">$ wget https://github.com/fatedier/frp/releases/download/v0.37.1/frp_0.37.1_linux_arm.tar.gz
</span></span><span class="line"><span class="cl"><span class="c1"># 解压</span>
</span></span><span class="line"><span class="cl">$ tar -zxvf ./frp_0.37.1_linux_arm.tar.gz
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> frp_0.37.1_linux_arm/
</span></span><span class="line"><span class="cl"><span class="c1"># 编辑配置文件</span>
</span></span><span class="line"><span class="cl">$ vim ./frpc.ini
</span></span><span class="line"><span class="cl">$ ./frpc -c ./frpc.ini
</span></span></code></pre></div><p>客户端配置文件的格式可参考如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[common]
</span></span><span class="line"><span class="cl">server_addr = server ip
</span></span><span class="line"><span class="cl">server_port = 6000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[samba]
</span></span><span class="line"><span class="cl">type = tcp
</span></span><span class="line"><span class="cl">local_ip = 127.0.0.1
</span></span><span class="line"><span class="cl">local_port = 445
</span></span><span class="line"><span class="cl">remote_port = 6003
</span></span></code></pre></div><p>其中端口号和<code>token</code>按需要自行更改，Samba服务的<code>tcp</code>端口号为<code>445</code>。</p>
<p>服务端配置文件格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[common]
</span></span><span class="line"><span class="cl">bind_port = 6000
</span></span></code></pre></div><p>为了安全，别忘了配置<a href="https://gofrp.org/docs/reference/server-configures/#%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81">权限验证</a>，同时别忘了修改服务器的防火墙设置。</p>
<h2 id="others">Others</h2>
<p>所以到此为止，咱的Samba服务器就搭建好了。</p>
<p>随便传了个大文件试了一下，内网上传速度在6MB/S左右，有些慢但是还没搞清楚到底是什么原因导致的。</p>]]></content:encoded>
    </item>
    
    <item>
      <title>小米路由器3G之使用TTL串口刷机救砖</title>
      <link>https://blog.starry-s.moe/posts/2021/xiaomi-r3g-ttl-flash/</link>
      <pubDate>Fri, 22 Jan 2021 22:10:01 +0800</pubDate>
      
      <guid>https://blog.starry-s.moe/posts/2021/xiaomi-r3g-ttl-flash/</guid>
      <description>&lt;p&gt;本来路由器闲置了一年了都没咋用了，前两天想把OpenWrt系统刷回原厂系统。&lt;/p&gt;
&lt;p&gt;然鹅刷原厂固件时忘记改环境变量了，因为第三方Boot Loader也被我顺带刷回了原厂的所以现在开机无限重启。&lt;/p&gt;
&lt;p&gt;之前买单片机套件时赠了一条usb转ttl线的，但是被我放学校了。只好再从万能的某宝再买一条线，尝试着救砖了。&lt;/p&gt;
&lt;p&gt;(在某宝发现了一家店啥元件都有，还特别便宜。于是我还顺带买了很多杜邦线、电阻、LED灯、面包板等小玩意&amp;hellip;)&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>本来路由器闲置了一年了都没咋用了，前两天想把OpenWrt系统刷回原厂系统。</p>
<p>然鹅刷原厂固件时忘记改环境变量了，因为第三方Boot Loader也被我顺带刷回了原厂的所以现在开机无限重启。</p>
<p>之前买单片机套件时赠了一条usb转ttl线的，但是被我放学校了。只好再从万能的某宝再买一条线，尝试着救砖了。</p>
<p>(在某宝发现了一家店啥元件都有，还特别便宜。于是我还顺带买了很多杜邦线、电阻、LED灯、面包板等小玩意&hellip;)</p>
<meting-js server="netease" type="song" id="409931672" theme="#233333"></meting-js>
<h2 id="砖了">砖了</h2>
<h2 id="拆机">拆机</h2>
<p><img loading="lazy" src="images/1.jpg" alt="&amp;ldquo;路由器主板&amp;rdquo;" />
<p style="margin-bottom: -0.8em;" class="image-title">Are You OK?</p>
</p>
<blockquote>
<p>北方冬季气候干燥，拆机时记得放静电，找根铁丝把自己连地线上 (找个金属外壳是接地的电器和自己连上也行)。</p>
</blockquote>
<p>拆开路由器外壳，卸下主板，顺手拆掉了散热片（屏蔽罩）。</p>
<p>串口在图片上主板的左侧，旁边有标记，从上到下依次是<code>TX</code>、<code>GND</code>、<code>RX</code>、<code>1</code>。需要注意的是主板上的<code>TX</code>要接到usb串口的<code>RX</code>，主板上的<code>RX</code>要接到usb串口的<code>TX</code>，<code>GND</code>连<code>GND</code>，VCC不用连。为了防止接错线，小米还十分贴心的标注了每个接口对应的连接线的颜色。</p>
<p><img loading="lazy" src="images/2.jpg" alt="" />
<p style="margin-bottom: -0.8em;" class="image-title">I&#39;m very OK!</p>
</p>
<p>找出家里吃灰好几年差点被我扔掉的电烙铁，刮刀头刮了半天电烙铁才上锡，把新买的杜邦线母线焊到主板上，和ttl串口线相连。</p>
<p>(电烙铁太破了根本焊不上锡，焊得很丑，emmm)</p>
<p>实际上可以买个4PIN单排针焊上去，把串口接到排针上就可以，我直接把电线焊到上面以后用起来会很麻烦。</p>
<h2 id="刷机">刷机</h2>
<blockquote>
<p>以下部分基于Arch Linux，其他系统的操作方式可能不一样（例如Windows可能需要超级终端访问串口，再想办法开一个tftp服务器）
刷机的原理: 通过ttl串口线连接路由器的主板，让路由器访问电脑上的tftp服务器，刷第三方Boot Loader。</p>
</blockquote>
<ol>
<li>首先电脑上装一个tftp服务器。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ sudo pacman -S tftp-hpa
</span></span><span class="line"><span class="cl">$ sudo systemctl start tftpd.service
</span></span></code></pre></div><p>tftp的默认目录为<code>/srv/tftp</code>。</p>
<p>这里使用HackPascal制作的Breed（第三方Boot Loader），<a href="https://breed.hackpascal.net/">下载链接</a>，把下载好的Breed重命名为<code>breed.bin</code>，复制到tftp的默认目录。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ cd /srv/tftp
</span></span><span class="line"><span class="cl">$ sudo cp ~/Downloads/breed-mt7620-xiaomi-r3g.bin breed.bin
</span></span></code></pre></div><ol start="2">
<li>
<p>路由器插网线连电脑，设置静态ip地址192.168.1.3/24，将串口和电脑连接，先不给路由器通电，通常情况下usb串口的设备名称为<code>/dev/ttyUSB0</code>，如果不确定的话可以<code>dmesg</code>查一下。</p>
</li>
<li>
<p>使用<code>screen</code>连接串口，波特率为115200。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ sudo pacman -S screen
</span></span><span class="line"><span class="cl">$ sudo screen /dev/ttyUSB0 115200
</span></span></code></pre></div><p>路由器通电，终端上会显示路由器启动的信息，等几秒后在选择启动项的时候按9，通过TFTP加载Boot Loader。</p>
<blockquote>
<p>如果串口在连接到电脑的情况下主板通电时没有响应，那就断开usb串口先给主板通电后再连接串口。
(我语文不好别骂我)
如果路由器没有变砖可以正常启动（蓝灯长亮），在正常开机过程中不能选择启动项。此时可以尝试在路由器开机后长按reset按钮7s以上直到主板重启，便可以选择启动项。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Please choose the operation:
</span></span><span class="line"><span class="cl"> 1: Load system code to SDRAM via TFTP.
</span></span><span class="line"><span class="cl"> 2: Load system code then write to Flash via TFTP.
</span></span><span class="line"><span class="cl"> 3: Boot system code via Flash (default).
</span></span><span class="line"><span class="cl"> 4: Entr boot command line interface.
</span></span><span class="line"><span class="cl"> 7: Load Boot Loader code then write to Flash via Serial.
</span></span><span class="line"><span class="cl"> 9: Load Boot Loader code then write to Flash via TFTP.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">You choosed 9
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">9: System Load Boot Loader then write to Flash via TFTP.
</span></span><span class="line"><span class="cl">Warning!! Erase Boot Loader in Flash then burn new one. Are you sure?(Y/N)y
</span></span></code></pre></div><p>之后设置路由器主机地址（192.168.1.1）和TFTP服务器地址(192.168.1.3)以及文件名称(breed.bin)。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Please Input new ones /or Ctrl-C to discard
</span></span><span class="line"><span class="cl">          Input device IP (192.168.31.1) ==:192.168.1.1
</span></span><span class="line"><span class="cl">          Input server IP (192.168.31.3) ==:192.168.1.3
</span></span><span class="line"><span class="cl">          Input Uboot filename (uboot.bin) ==:breed.bin
</span></span></code></pre></div><p>按回车后开始刷机，过几秒钟后路由器会自动重启，第三方Boot Loader刷写完成。</p>
<p>路由器断电，长按reset键的同时通电开机，灯闪烁后打开浏览器输入网址<code>http://192.168.1.1</code>便可访问breed后台。</p>
<h2 id="done">Done</h2>
<p>第三方Breed刷完后，先用Breed刷小米官方的开发版固件，开启ssh，之后按照<a href="/posts/2019/xiaomi_r3g_openwrt/#%E4%BD%BF%E7%94%A8Breed%E7%9A%84%E5%88%B7%E6%9C%BA%E6%96%B9%E6%B3%95">小米路由器3G折腾之刷OpenWrt记录</a>这篇文章刷OpenWrt。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">BusyBox v1.19.4 (2018-10-29 07:52:03 UTC) built-in shell (ash)
</span></span><span class="line"><span class="cl">Enter &#39;help&#39; for a list of built-in commands.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> -----------------------------------------------------
</span></span><span class="line"><span class="cl">       Welcome to XiaoQiang!
</span></span><span class="line"><span class="cl"> -----------------------------------------------------
</span></span><span class="line"><span class="cl">  $$$$$$\  $$$$$$$\  $$$$$$$$\      $$\      $$\        $$$$$$\  $$\   $$\
</span></span><span class="line"><span class="cl"> $$  __$$\ $$  __$$\ $$  _____|     $$ |     $$ |      $$  __$$\ $$ | $$  |
</span></span><span class="line"><span class="cl"> $$ /  $$ |$$ |  $$ |$$ |           $$ |     $$ |      $$ /  $$ |$$ |$$  /
</span></span><span class="line"><span class="cl"> $$$$$$$$ |$$$$$$$  |$$$$$\         $$ |     $$ |      $$ |  $$ |$$$$$  /
</span></span><span class="line"><span class="cl"> $$  __$$ |$$  __$$&lt; $$  __|        $$ |     $$ |      $$ |  $$ |$$  $$&lt;
</span></span><span class="line"><span class="cl"> $$ |  $$ |$$ |  $$ |$$ |           $$ |     $$ |      $$ |  $$ |$$ |\$$\
</span></span><span class="line"><span class="cl"> $$ |  $$ |$$ |  $$ |$$$$$$$$\       $$$$$$$$$  |       $$$$$$  |$$ | \$$\
</span></span><span class="line"><span class="cl"> \__|  \__|\__|  \__|\________|      \_________/        \______/ \__|  \__|
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">root@XiaoQiang:~#
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>小米路由器3G折腾之刷OpenWrt记录</title>
      <link>https://blog.starry-s.moe/posts/2019/xiaomi_r3g_openwrt/</link>
      <pubDate>Tue, 19 Feb 2019 00:49:20 +0800</pubDate>
      
      <guid>https://blog.starry-s.moe/posts/2019/xiaomi_r3g_openwrt/</guid>
      <description>&lt;p&gt;生命不息, 折腾不止&amp;hellip;&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>生命不息, 折腾不止&hellip;</p>
<hr>
<meting-js server="netease" type="song" id="22802176" theme="#233333"></meting-js>
<blockquote>
<p>本篇由于创作时间过于久远，部分下载链接可能失效，因长期未更新，教程仅供参考。</p>
</blockquote>
<h2 id="准备工作">准备工作</h2>
<p>你至少需要以下工具：</p>
<ul>
<li>路由器本体</li>
<li>网线</li>
<li>一个已格式化为FAT/FAT32格式的U盘, 用来刷开发者固件和ssh激活工具</li>
<li>一根怼<code>Reset</code>钮的针</li>
<li>Windows用户需要一个SSH软件（例如：<a href="https://putty.org">putty</a>）</li>
<li><a href="http://www1.miwifi.com/miwifi_download.html">小米路由器客户端</a>, 用来绑定你的小米账号</li>
</ul>
<h2 id="ssh到路由器">SSH到路由器</h2>
<blockquote>
<p>路由器重启后指示灯会变为蓝色, 若变为红色则为刷机失败。</p>
</blockquote>
<p>安装开发者固件并开启SSH权限：</p>
<ol>
<li>
<p>在<a href="http://www1.miwifi.com/miwifi_download.html">MiWiFi下载页面</a>下载所需要的路由器开发者固件（ROM -&gt; ROM for R3G开发版）,命名为<code>miwifi.bin</code>。</p>
</li>
<li>
<p>路由器断电, 将下载好的开发者固件放入U盘插入路由器USB接口, 捅住reset扭接上电源后待指示灯为黄色闪烁时松开, 数分钟后路由器会自动重启, 此过程不要乱动路由器。</p>
</li>
<li>
<p>小米路由器客户端登陆小米账号绑定路由器设备, 此过程需要路由器联网。</p>
</li>
<li>
<p><a href="http://www1.miwifi.com/miwifi_open.html">MiWiFi开放平台</a>登陆小米账号下载ssh激活工具命名为<code>miwifi_ssh.bin</code>, 记下root密码。</p>
</li>
<li>
<p>操作方式同第二步骤, 刷入ssh激活工具。</p>
</li>
</ol>
<p>SSH到路由器:</p>
<ul>
<li>
<p>Windows系统用putty, ip为<code>191.168.31.1</code>, 用户名：<code>root</code>, 密码为下载激活ssh工具时记下的密码。</p>
</li>
<li>
<p>Unix/Linux系统终端执行：<code>ssh root@191.168.31.1</code></p>
<p>如果在ssh到路由器时遇到no matching key exchange method found错误，编辑<code>~/.ssh/config</code>, 加入下面两行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Host *
</span></span><span class="line"><span class="cl">    KexAlgorithms +diffie-hellman-group1-sha1
</span></span></code></pre></div></li>
</ul>
<h2 id="刷入bootloader推荐可选">刷入Bootloader（推荐/可选）</h2>
<blockquote>
<p>该步骤可选是因为Breed不支持直接刷入Openwrt固件, 可参考<a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=267455">这篇帖子</a>, 不过为了防止变砖, 还是推荐刷Breed。</p>
</blockquote>
<p>Breed原作者为hackpascal, <a href="https://breed.hackpascal.net/">此处为下载地址</a>, 文件名为<code>breed-mt7621-xiaomi-r3g.bin</code></p>
<p>第一种方法是ssh到路由器后通过<code>wget</code>下载breed文件再刷入（需要确保路由器联网）, 下载地址为https所以需要加上<code>--no-check-certificate</code>参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cd /tmp
</span></span><span class="line"><span class="cl">wget --no-check-certificate https://breed.hackpascal.net/breed-mt7621-xiaomi-r3g.bin -O breed.bin
</span></span><span class="line"><span class="cl">mtd -r write breed.bin Bootloader
</span></span></code></pre></div><p>另一种方法是将breed通过U盘拷贝到路由器再刷入。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mkdir /tmp/sdcard
</span></span><span class="line"><span class="cl">mount /dev/sda1 /tmp/sdcard
</span></span><span class="line"><span class="cl">mtd -r write /tmp/sdcard/breed.bin Bootloader
</span></span></code></pre></div><p>路由器刷写完毕后会自动重启, <strong>在写入Breed的过程中不要动路由器</strong>。</p>
<h2 id="刷机">刷机</h2>
<p>下载所需固件：</p>
<ul>
<li>
<p>tuna镜像站的OpenWrt下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/lede/releases/">https://mirrors.tuna.tsinghua.edu.cn/lede/releases/</a></p>
</li>
<li>
<p>官方下载地址: <a href="https://downloads.openwrt.org/releases/">https://downloads.openwrt.org/releases/</a></p>
</li>
</ul>
<h3 id="使用breed的刷机方法">使用Breed的刷机方法</h3>
<p>按照hackpascal的说法是：</p>
<blockquote>
<p>如果kernel0存在kernel1不存在, 那么启动kernel0
如果kernel1存在kernel0不存在, 那么启动kernel1
如果kernel0和kernel1都存在, 那么检查环境变量 <code>xiaomi.r3g.bootfw</code> 的值, 如果存在且值为 2, 那么启动kernel1, 否则启动kernel0</p>
</blockquote>
<p>简单来说就是：路由器有两个内核, 需要在Breed里设置环境变量让路由器启动kernel1。</p>
<ol>
<li>刷入Openwrt固件到Kernel1</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mtd write openwrt-18.06.2-ramips-mt7621-mir3g-squashfs-kernel1.bin kernel1
</span></span><span class="line"><span class="cl">mtd write openwrt-18.06.2-ramips-mt7621-mir3g-squashfs-rootfs0.bin rootfs0
</span></span></code></pre></div><ol start="2">
<li>
<p>路由器断电, 捅住reset按钮后通电, 待指示灯变为蓝色闪烁后用网线连接路由器到电脑, 浏览器打开网址<code>192.168.1.1</code>, 进入Breed界面。</p>
</li>
<li>
<p>在环境变量编辑里添加<code>xiaomi.r3g.bootfw</code>字段, 值为<code>2</code>,保存后重启即可进入Openwrt。</p>
</li>
</ol>
<h3 id="没有刷入breed的刷机方法">没有刷入Breed的刷机方法</h3>
<blockquote>
<p><a href="https://openwrt.org/toh/xiaomi/mir3g">OpenWrt官网提供的教程</a>是在没有刷入Breed的情况下刷入OpenWrt固件的。</p>
</blockquote>
<p>ssh到路由器, 导入固件后刷机。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mtd write openwrt-18.06.2-ramips-mt7621-mir3g-squashfs-kernel1.bin kernel1
</span></span><span class="line"><span class="cl">mtd write openwrt-18.06.2-ramips-mt7621-mir3g-squashfs-rootfs0.bin rootfs0
</span></span><span class="line"><span class="cl">nvram set flag_try_sys1_failed=1
</span></span><span class="line"><span class="cl">nvram commit
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">reboot
</span></span></code></pre></div><hr>
<h2 id="others">Others</h2>
<ol>
<li>
<p>如果刷了Breed + Pandavan/PandoraBox后想换回OpenWrt的话, 首先在Breed中刷回小米路由器开发版的官方固件, 然后SSH到路由器按照上述的使用Breed的刷机方法再刷机。</p>
</li>
<li>
<p>USB3.0会对路由器的2.4G频段信号造成干扰。</p>
</li>
<li>
<p>OpenWrt默认语言为英文, 可安装<code>luci-i18n-base-zh-cn</code>,<code>luci-i18n-base-zh-tw</code>安装简体/繁体中文。</p>
</li>
<li>
<p><a href="http://openwrt-dist.sourceforge.net">OpenWrt-dist</a>可拓展更多功能。</p>
</li>
<li>
<p>为优化软件包安装速度, 可将opkg源改为国内：</p>
</li>
</ol>
<p>LuCI -&gt; System -&gt; Software -&gt; Configuration 中将 Distribution feeds 的<code>http://downloads.openwrt.org</code>替换为<code>http://mirrors.tuna.tsinghua.edu.cn/lede</code>。</p>
<ol start="6">
<li>OpenWrt可安装软件包<code>libustream-openssl</code> <code>libustream-mbedtls</code>解决<code>wget</code>无法访问https服务器问题。</li>
</ol>
<p>然后建议把opkg源能改为https的都改为https。</p>]]></content:encoded>
    </item>
    
  </channel>
</rss>
