<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>51单片机习题整理 | STARRY-S' Blog</title><meta name=keywords content="单片机,学习资料"><meta name=description content="赶在期中考试(骑磨烤柿)前把单片机的课后习题整理出来&mldr;
(实在是没什么可拿来更新博客的了, 就干脆写点复习资料吧&mldr;)"><meta name=author content="STARRY-S"><link rel=canonical href=https://blog.starry-s.moe/posts/2020/learn-mcs8051/><link crossorigin=anonymous href=/assets/css/stylesheet.6c90a77e0bb06670e5068e51e589ed8b237ada0173c304780a7491b96adcf310.css integrity="sha256-bJCnfguwZnDlBo5R5YntiyN62gFzwwR4CnSRuWrc8xA=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.starry-s.moe/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://blog.starry-s.moe/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.starry-s.moe/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.starry-s.moe/apple-touch-icon.png><link rel=mask-icon href=https://blog.starry-s.moe/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.starry-s.moe/posts/2020/learn-mcs8051/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>.has-mathjax{visibility:hidden}</style><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={startup:{pageReady:()=>MathJax.startup.defaultPageReady().then(()=>{for(let e of document.getElementsByClassName("has-mathjax"))e.style.visibility="visible"})}}</script><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/aplayer/dist/APlayer.min.css><script src=https://fastly.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><script src=https://fastly.jsdelivr.net/npm/meting/dist/Meting.min.js></script><script>var meting_api="https://api.injahow.cn/meting/?server=:server&type=:type&id=:id&auth=:auth&r=:r"</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#232323"><meta property="og:url" content="https://blog.starry-s.moe/posts/2020/learn-mcs8051/"><meta property="og:site_name" content="STARRY-S' Blog"><meta property="og:title" content="51单片机习题整理"><meta property="og:description" content="赶在期中考试(骑磨烤柿)前把单片机的课后习题整理出来…
(实在是没什么可拿来更新博客的了, 就干脆写点复习资料吧…)"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-03T20:19:36+08:00"><meta property="article:modified_time" content="2020-12-09T12:31:15+08:00"><meta property="article:tag" content="单片机"><meta property="article:tag" content="学习资料"><meta property="og:image" content="https://blog.starry-s.moe/avatar.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.starry-s.moe/avatar.png"><meta name=twitter:title content="51单片机习题整理"><meta name=twitter:description content="赶在期中考试(骑磨烤柿)前把单片机的课后习题整理出来&mldr;
(实在是没什么可拿来更新博客的了, 就干脆写点复习资料吧&mldr;)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.starry-s.moe/posts/"},{"@type":"ListItem","position":2,"name":"51单片机习题整理","item":"https://blog.starry-s.moe/posts/2020/learn-mcs8051/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"51单片机习题整理","name":"51单片机习题整理","description":"赶在期中考试(骑磨烤柿)前把单片机的课后习题整理出来\u0026hellip;\n(实在是没什么可拿来更新博客的了, 就干脆写点复习资料吧\u0026hellip;)\n","keywords":["单片机","学习资料"],"articleBody":"赶在期中考试(骑磨烤柿)前把单片机的课后习题整理出来…\n(实在是没什么可拿来更新博客的了, 就干脆写点复习资料吧…)\n本篇内容为作者整理资料所得, 仅供学习使用。如需转载请务必遵循CC BY-NC-ND 4.0协议。 请勿将本篇内容作为权威的教学辅导资料使用, 因无法保证100%准确, 仅供参考。\n如果发现了本篇存在的错误, 欢迎在页面下方提issue指正。\n本篇文章使用MathJax显示数学公式，在使用RSS阅读器时会出现无法正确显示的情况。\n硬件结构\u0026指令系统 8051复位后从地址0000H开始执行程序, SP的值为07H。\nPC: 两字节(16位)寄存器, 也称程序计数器。\nSP: 堆栈指针, 指示出堆栈顶部在内部RAM块中的位置。\n单片机的堆栈设在了内部RAM区, 单片机复位后, SP中的内容为07H(指向第0组工作寄存器的R7), 堆栈实际上从08H开始。\n若SP被初始化为39H, 则堆栈实际上是从3AH开始的。\n执行LCALL addr16指令时，单片机先将PC的低字节压栈，再将PC的高字节压栈，最后把转移地址送入PC中。\n与之类似的LJMP类无条件转移指令，单片机只修改PC的值，并不堆栈保存跳转前的PC中保存的地址。\n执行RET指令后, SP值减2 (因为PC为2字节寄存器), 进行两次出栈操作，第一次出栈送PC的高位，第二次出栈送PC的低位。\n中断服务程序结束指令RETI不仅将堆栈中保存的2字节地址分别送入PC的高位和低位中，而且复位中断系统。因此RET和RETI不同。\nRET和RETI对堆栈的操作是相同的。\nPSW中的RS1 RS0=10B时, R2的RAM地址为12H。\nPSW： 程序状态字寄存器, 从PSW.7至PSW.0分别为Cy(进位标志位), Ac(辅助进位标志位), F0(标志位), RS1和RS0(寄存器区选择控制位), OV(溢出位), 保留位, P(奇偶标志位, 奇数为1, 偶数为0)。\nD7 D6 D5 D4 D3 D2 D1 D0 PSW Cy Ac F0 RS1 RS0 OV P RS1 RS0 = 10B时, 使用第二组工作寄存器区, 第0组工作寄存器区R0-R7的地址为00H-07H, 第1组为08H-0FH, 第2组为10H-17H, 第3组为18H-1FH(每组长度为8个字节, 每个寄存器占1个字节)。\n因此, 当A为01110010B时, PSW中P为0(偶数个1)。\nINC A指令不改变PSW中的Cy，只有可能改变奇偶标志位P。\n假设PSW为18H, 即00011000B, 此时使用第3组工作寄存器, R0地址为18H, R7地址为1FH。\n复位后, 默认选择的寄存器区是0区。\n8051片外数据存储器的寻址空间为0000H~0FFFFH\n位地址07H位于字节地址20H, 位地址7FH位于字节地址2FH。\n片内RAM中20H~2FH这16个单元即可进行共128位的位寻址, 也可进行字节寻址。\n字节地址及其位地址见下表所示：\n字节地址 D7 D6 D5 D4 D3 D2 D1 D0 2FH 7FH 7EH 7DH 7CH 7BH 7AH 79H 78H 2EH 77H 76H 75H 74H 73H 72H 71H 70H 2DH 6FH 6EH 6DH 6CH 6BH 6AH 69H 68H … … … … … … … … … 21H 0FH 0EH 0DH 0CH 0BH 0AH 09H 08H 20H 07H 06H 05H 04H 03H 02H 01H 00H 因此00H~07H位于字节地址20H, 78H-7FH位于字节地址2FH。\n除此之外，一些特殊功能寄存器（SFR）可进行位寻址（字节地址能够被8整除），SFR中位地址有83个（共有88个，5个未用），能够位寻址的SFR的字节地址末位均为0H或8H。\n访问外部存储器时, P0口用来传输低8位地址和数据, P2口用来传送高8位地址。\n访问外部存储器时, ALE的输出用于锁存低8位地址。\n一个机器周期为12个震荡周期\n为保证读入数据正确, 在读一个端口引脚之前应先向相应的端口锁存器写1。\n如果在读一个端口引脚之前向对应的输出锁存器写了0, 将总是读到0。\n8051访问片外存储器时, 利用ALE信号锁存来自P0的低8位地址信号。\n只能用直接寻址方式访问特殊功能寄存器。\n如果为8052单片机, 在访问高128字节的RAM时, 只能用间接寻址方式寻址。\n访问片外数据存储器64Kbyte时, 使用DPTR做间接寻址寄存器。\n使用MOVX @DPTR类指令访问外部扩展存储器时, P2口输出高8位地址, P0口传送低8位地址和数据。\n8051中, PC和DPTR都用于提供地址时, PC是用户程序不可访问的, DPTR可以分为两个8位寄存器DPH和DPL使用。\n累加器A的值为30H, 指令MOVC A, @A+PC位于地址3000H。执行该指令时, 程序存储器地址3031H的内容被传送至累加器A。\n指令MOVC A, @A+PC长度为1字节, 位于地址3000H, 因此PC值为3001H, 故A+PC为3031H。\n设SP的值为5FH, 指令LCALL DELAY所在地址为2030H, 子程序DELAY所在地址为20A0H, 则该指令完成的操作是将地址2033H压入堆栈保存, 将地址20A0H送入PC, SP的值应在该指令执行结束后变成61H。 单片机执行子程序或中断服务程序时, 需要保护现场, 即将PC当前的值压栈保存, 当子程序或中断服务程序运行结束后再进行出栈。(所以如果子程序修改了栈的内容, 在子程序运行结束后程序有可能会运行错误)。\nPC是16字节寄存器, 所以SP需要加2, 以此分别保存PC的高、低8位的数据。\nLCALL addr16这条指令占3字节, 其中addr16占两字节, 因此程序可跳转64KB范围内的地址。\n(ACALL指令只能跳转当前所在的2K范围内的地址, 如果不涉及到片外数据存储器的话, 通常只用SJMP和AJMP)\n在网上搜到的答案「将3500H送入PC」是错误的, 实际是将20A0H送入PC, 因为DELAY所在的地址为20A0H, 和3500H一点关系都没有。\nMOVC访问 程序(ROM) 存储器, MOVX指令访问 外部数据 存储器。 MOVC为查表指令, 只有MOVC @A+PC和MOVC @A+DPTR这两条, 均为单字节指令。\nMOVX用于累加器A与外部数据存储器进行传送。\n可以是MOVX A, @DPTR, MOVX A, @Ri, MOVX @DPTR, A, MOVX @Ri, A，其中i为0或1.\n当使用MOVX @Ri类指令时，只有P0口用来传送地址和数据，P2口的状态不会发生改变，因此可使用MOV P2, #12H指令设定高8位的地址。\n当采用Ri作间接寻址时, 只能寻找片外256个单元的数据存储器, 此时8位地址和数据均由P0口传送，P2口的状态不发生改变。\n假设指令DJNZ R7, rel位于005FH, 如果在执行该指令前寄存器R7值为00H, 偏移量rel为02H, 则该指令执行后下一条要执行的指令所在的地址是005FH。 DJNZ R7, rel位于005FH, 该指令长度为2字节 (书上写的3字节是错的), 所以在执行这条指令开始时PC值在原来的基础上 + 2 变为0061H。又因为rel为02H, 所以执行这条指令后, PC值变为0063H。\n分析下面子程序的功能, 假设8051单片机的震荡频率为6MHz。 DL: MOV R7, #0AH L0: MOV R6, #250 L1: NOP NOP DJNZ R6, L1 DJNZ R7, L0 RET R7为10, R6为250, 因此两个NOP加上一个DJNZ一共循环了250次, 该250次的循环一共执行了10次。\nNOP为1周期指令, DJNZ为2周期指令, 两个NOP加一个DJNZ共4周期。\n6MHz下一个机器周期为\\(12 \\div (6 \\times 10^6)= 2{\\mu}s\\), 12MHz下一个机器周期为1微秒。\n故程序该子程序延时了\\((4 \\times 250 \\times 10 \\times 12) \\div (6 \\times 10^6) = 20(ms)\\)\n(实际上有10次MOV R6, #250和10次DJNZ R7, L0造成的30个机器周期的约0.6ms的误差)\n以下部分写于2020年11月25日\n汇编语言程序 编写一个子程序, 将内部RAM 40H~4FH的内容复制到50H~5FH。\nCOPY: MOV R0, #40H MOV R1, #50H MOV R2, #10H ; 40H~4FH一共复制了16次 LOOP: MOV A, @R0 MOV @R1, A INC R0 INC R1 DJNZ R2, LOOP RET 因为没有MOV @RX, @RX这条指令, 所以用A做数据的中转站。\n将任何无符号8位二进制数转换为BCD码的子程序, 入口参数为内部RAM单元20H, 出口参数为内部RAM单元30H和31H, 30H存放百位数, 31H存放十位数和个位数。\nCV: MOV R0, #20H MOV A, @R0 MOV B, #100 DIV AB; A除以100, 得到的百位数存在A中 MOV 30H, A MOV A, B MOV B, #10 DIV AB SWAP A ADD A, B; 也可以用ORL MOV 31H, A RET DIV AB和MUL AB的A和B之间没有逗号。\n内部RAM 30H单元存放两位十进制数 (压缩BCD码), 编写将该十进制数转换为对应ASCII码的子程序, 转换结果存放到内部RAM 40H (十位数) 和41H (个位数) 单元。\nASCII码： 30H为0, 41H为A, 61H为a\nCV: MOV A, 30H ANL A, #0FH MOV DPTR, #DATA; 或者直接用ADD A, #30H即可 MOVC A, @A+DPTR MOV 41H, A MOV A, 30H SWAP A ANL A, #0FH MOVC A, @A+DPTR MOV 40H, A RET DATA: DB 30H, 31H, 32H, 33H, 34H, 35H, 36H, 37H, 38H, 39H 8个8位数相加, 求平均值, 入口地址为30H~37H, 结果存到40H。\n把8位数相加存在溢出, 所以把相加结果以16进制存到R2、R3中, 再除以8( 右移3次), 即可求得不四舍五入的平均值。\nMOV R0, #30H MOV R1, #08H MOV R2, #00H MOV R3, #00H ; 初始化 LOOP: CLR C MOV A, @R0 ADD A, R3 MOV R3, A JNC SKIP INC R2 SKIP: INC R0 DJNZ R1, LOOP 这样结果被保存到R2、R3中, 然后需要写一个循环右移3位的程序。\nMOV R4, #03H LOOP2: RRC R2 RRC R3 DJNZ R4, LOOP2 MOV 40H, R3 ; 右移3次后R2的低4位为0, 结果保存在R3中 这样R3中求得的是不带四舍五入的结果。\n如果需要带四舍五入的话第一种方法是判断最后一次右移时最低位是否为\\(1\\)，\\((1 / 2 = 0.5)\\)。\nMOV R4, #03H LOOP2: RRC R2 RRC R3 DJNZ R4, LOOP2 JNC SKIP2 INC R3 SKIP2: MOV 40H, R3 ; 右移3次后R2肯定为0 这样是带四舍五入的结果。\n第二种方法，8个8位数相加求平均值，要求四舍五入的话，只需要在这8个数求和后再加4（0100B），之后右移3次。\nADD A, #04H MOV R3, A JNC SKIP2 INC R2 SKIP2: MOV R4, #03H LOOP2: RRC R2 RRC R3 DJNZ R4, LOOP2 结果保存在R3中。\n中断系统 8051的外部中断有低电平触发和下降沿触发两种触发方式。外部中断1的中断向量地址是0013H。\n在响应中断时, 单片机自动生成一条长调用指令LCALL addr16, 其地址为中断入口地址。\n中断源 入口地址 INT0 0003H T0 000BH INT1 0013H T1 001BH 串行口 0023H 通常在中断入口地址处放一条无条件转移指令*JMP。\n内部查询顺序同入口地址的顺序，由高到低。\n执行指令MOV IP, #0BH( #00001011B)后, 中断优先级最高者为PX0, 最低为PS。\nIP: 中断优先级寄存器, 其前3为无意义, 后5位( IP.4至IP.0)为：PS, PT1, PX1, PT0, PX0, 分别对应串行口、定时器T1、外部中断1、定时器0、外部中断0。\nD7 D6 D5 D4 D3 D2 D1 D0 IP PS PT1 PX1 PT0 PX0 单片机复位以后, IP的内容为0, 各个中断源均为低优先级中断。\n在同时收到几个同一优先级的中断请求时, 中断响应取决于内部查询顺序, 其顺序由高到低为：INT0、T0、INT1、T1、串行口。\n当中断源均为同一优先级时, 当它们同时申请中断时CPU首先响应外部中断0\n8051的晶振频率为12MHz, 则最短的外部中断响应时间为3\\(\\mu\\)s, 最长的外部中断响应时间为12\\(\\mu\\)。\n中断标记位于单片机寄存器的TCON和SCON中。\nD7 D6 D5 D4 D3 D2 D1 D0 TCON TF1 TR1 TF0 TR0 IE1 IT1 IE0 IT0 SCON SM0 SM1 SM2 REN TB8 RB8 TI RI TCON中TF1和TF0为定时器/计数器中断标志位, TR1和TR0为定时/计数启动位, IE1和IE0为外部中断标志位, IT1和IT0为选择外部中断为边沿触发(1)还是电平触发(0)方式。\nSCON中前几位与串行口有关，第1位和第2位的TI和RI(是大写字母I不是数字1)分别为串行口中断发送中断请求标志位(发送成功后置1)和接受中断请求标志位( 接受成功后置1)。串口中断无法硬件清零, 只能软件清零。\n当IE中EA为1、ES为1时，TI或RI为1时，CPU执行无条件转移指令LJMP 0023H, 执行串行口中断服务程序。\n要使8051能够响应定时器T1的中断和串行口中断, 不响应其他中断, 则中断允许寄存器IE的内容为98H(10011000B)。\n中断允许寄存器IE：\nD7 D6 D5 D4 D3 D2 D1 D0 IE EA ES ET1 EX1 ET0 EX0 EA为总控制位, 当EA为1时, CPU才可以响应中断请求。\nES为串行口中断允许位, ET1和ET0为定时器中断允许位, EX1和EX0为外部中断允许位。\n定时器和计数器 使T0工作方式1的溢出周期最长的初值是0000H。\n定时器/计数器工作在方式0为13位计数器, 由TLX的低5位和THX的高8位组成13位计数器, 最大值为\\(2^{13}-1 = 8191\\), 晶振频率12MHz下计时周期最长为8.192ms。工作在方式1时由均为8位的TLX和THX组成16位计数器, 最大值为65535, 晶振频率为12M下最长为65.536ms。\n当定时器/计数器工作在方式2时, 可以循环定时/计数。当计数溢出后, 自动将8位的THX装入8位的TLX中, 可省去重装初值的时间, 最大值为255, 晶振频率12M下计时周期最长为0.256ms。\nT1配置为方式3时, 停止计数, 方式3只适用于定时器0。\n定时器T0的方式3将其分为两个8位定时器, 其中TH0只能做定时器使用。\n设8051单片机的晶振频率为12MHz, 定时器作计数器使用时, 其计数输入信号的最高频率为500KHz。\n当定时器用作计数器时, 当检测到引脚上的负跳变时计数器的值增一。检测下降沿需要2个机器周期, 即24个震荡周期, 所以输入信号最高频率为 \\(12M \\div 24 = 500KHz\\)。\n用定时器方式2扩展一个下降沿触发的外部中断, 计数初值应为FFH。\n此处定时器2以计数器方式运行, 当检测到一个下降沿后, 计数器加一后溢出, 因此会执行定时器中断的中断子程序。\n2020年12月3日： 前两天感冒, 休息了几天(打了两天的游戏)后继续。\n串行口 串行口TXD为高电平, 表示这是数据位或停止位或空闲状态。\n串行口工作在方式1时, TXD用来发送数据、RXD用来接受数据。方式1的一帧数据为10位, 起始为为0, 停止位为1, 数据位和空闲状态均可能为0或1。\n串行口工作在方式3时, 发送的第9位数据要事先写入寄存器SCON的TB8, 接收的第9位数据被写入同一寄存器的RB8。\n串行口控制寄存器SCON：\nD7 D6 D5 D4 D3 D2 D1 D0 SCON SM0 SM1 SM2 REN TB8 RB8 TI RI 其中SM0、SM1为串口的工作方式选择位, 方式0为同步移位寄存器方式, 方式1为8位异步收发, 方式2和方式3为9位异步收发。\n波特率：串行口每秒钟传送的比特位数，单位bits/s。\n方式0的波特率固定为 \\(f_{osc}/12\\), 方式2的波特率为 \\(f_{osc}/64\\) 或 \\(f_{osc}/32\\) (由SMOD控制)。\n方式1的波特率和方式3的波特率可变, 公式为 \\((2^{SMOD} / 32) \\times 定时器T1的溢出率\\)。\nT1的溢出率为定时器T1的周期的倒数，定时器的周期为\n$$T = \\frac{12\\times (2^n - X )}{f\\_{osc}}$$ 当T1工作在方式2时，n为8，波特率为：\n$$波特率=\\frac{(2^{SMOD} \\div 32) \\times f_{osc}}{12 \\times (256 - X)}$$ \\(X\\)为定时器T1的初值。\n串口工作在方式1，波特率为2400，则每秒钟最大能发送/接收 \\(2400 \\div 10 = 240Byte\\) 的数据。\n单片机工作在方式1时, 1帧数据为1个起始位、8个数据位、1个停止位共10位。\n8051的UART工作在方式3，要求每秒钟能传送不少于900个字节的数据，则波特率应当大于 \\(900 \\times 8 = 7200bits/s\\)。\n比特率2400Kbits/s，时钟频率12M，PC机发送8个字节的数据存到单片机的30H-37H中，随后单片机发送2个确认字节55H和AAH给PC机，使用查询方式。\nORG 0000H MAIN: MOV SCON, #50H ; 串口使用方式1，且允许接收 MOV PCON, #00H ; 波特率不加倍 MOV TMOD, #20H ; 定时器1使用方式2 MOV TL1, #0F3H MOV TH1, #0F3H SETB TR1 LOOP: MOV R0, #30H MOV R1, #08H REC: JNB RI, $ MOV @R0, SBUF CLR RI ; 软件清零RI INC R0 DJNZ R1, REC MOV SBUF, #55H JNB TI, $ CLR TI MOV SBUF, #0AAH JNB TI, $ CLR TI AJMP LOOP END 单片机接收到数据后，RI被置1，代表SBUF中的数据有效，取走SBUF中的数据后需要软件清零RI（串口中断不会自动清零RI）。\n当单片机执行写SBUF操作时，串口发送开始，TI被自动置1，在发送完成后TI被自动清0。\n2020年12月7日：\nI/O口 \u0026 外部存储器拓展 8051使用指令MOVX A, @R0读外部数据存储器时，不起作用的信号是WR。\n8051在使用MOVX @DPTR类指令读外部数据存储器时，P0和P2先输出外部数据的地址，单片机发出的ALE信号的负跳沿将P0口输出的地址锁存在地址锁存器(74HC573)里，之后单片机发出RD信号，读取外部数据存储器（RAM）的数据到总线再传送到P0口上。最后单片机从P0口读取数据保存到A中。\n如果是写外部数据存储器时，单片机将不发出RD信号而是WR信号，将A中的数据写入外部数据存储器中。\n存储器芯片6264需要13根地址线。\n62256的容量为 \\(256Kbit \\div 8 = 32KB = 2^{15}\\), 需要15根地址线。\n6264的容量为 \\(64Kbit \\div 8 = 8KB = 2^{13}\\)，所以需要13根地址线。\n6116容量为 \\(16Kbit \\div 8 = 2KB = 2^{11}\\), 需要11根地址线。\n计算方法是62 \\(X\\) 的 \\(容量=X \\div 8(K)\\)。\n使用16位地址模式时，8051的外部数据存储器寻址空间为64KB。\n基于8051的单片机系统能拓展的外部数据存储器容量无限制。\n有的书上说最大只能拓展64KB，实际是最大寻址空间为64KB，拓展的外部数据存储器容量无限制。\n8051的程序存储器可用来存放用户程序和数据。 例如使用DW或DB指令用来定义数据。\n所以应用程序也可以使用MOVC A, @A+DPTR访问程序存储器中的数据。\n除此之外LED数码管和外部存储器拓展、外部I/O设备拓展部分有很多需要根据线路图计算地址和DA转换的题，因为线路图源自老师提供的PDF，而老师为PDF加了密码，意味着不允许外传，所以我就不放到博客上面了，除非我自己用Porteus画一个类似的\nLED段码入口地址8004H，位选入口地址8002H，将30H-32H保存的6个压缩BCD码发送到6位共阴极数码管上显示， 要求编写延时1ms的子程序。\nMAIN: MOV R0, #30H ; R2用来计数 MOV R2, #03H ; R3用来位选 MOV R3, #01H LOOP: MOV A, @R0 SWAP A ANL A, #0FH MOV DPTR, #TAB MOVC A, @A+DPTR ; 取高4位BCD码对应的段码 MOV DPTR, #8004H MOVX A, @A+DPTR ; 先送段码 MOV A, R3 MOV DPTR, #8002H MOVX @DPTR, A RL A MOV R3, A ; 再送位选 LCALL DELAY MOV A, @R0 ANL A, #0FH MOV DPTR, #TAB MOVC A, @A+DPTR ; 取低4位BCD码对应的段码 MOV DPTR, #8004H MOVX A, @A+DPTR ; 送段码 MOV A, R3 MOV DPTR, #8002H MOVX @DPTR, A RL A MOV R3, A ; 送位选 LCALL DELAY INC R0 DJNZ R2, LOOP DELAY: MOV R7, #250 DL: NOP NOP DJNZ R7, DL RET TAB: DB 3FH, 06H, 5BH, 4FH, 66H, 6DH, 7DH, 07H, 7FH, 6FH END 打印机数据输入接口和P1直接相连，STB接口和P3.4相连，BUSY接口和P3.3相连，不使用ACK应答信号，编写将外部存储器1000H-100FH的数据发送到打印机打印的子程序。\nPRINT: MOV DPTR, #1000H MOV R2, #10H LOOP: JB P3.3, $ ; 确保打印机处于空闲状态 MOVX A, @DPTR MOV P1, A CLR P3.4 SETB P3.4 INC DPTR DJNZ R2, LOOP RET 如果打印机没有和P1直接相连，而是连接到数据锁存器上（74HC374），锁存器的时钟信号的入口地址为A000H。\n使用堆栈保护间接寻址寄存器的值。\nPRINT: MOV R2, #10H MOV DPTR, #1000H LOOP: JB P3.3, $ ; 确保打印机处于空闲状态 MOVX A, @DPTR PUSH DPL PUSH DPH MOV DPTR, #0A000H MOVX @DPTR, A POP DPH POP DPL CLR P3.4 SETB P3.4 INC DPTR DJNZ R2, LOOP RET SFR列表 87H D7 D6 D5 D4 D3 D2 D1 D0 PCON SMOD - - - - - PD IDL 88H D7 D6 D5 D4 D3 D2 D1 D0 TCON TF1 TR1 TF0 TR0 IE1 IT1 IE0 IT0 89H D7 D6 D5 D4 D3 D2 D1 D0 TMOD GATE C/T M1 M0 GATE C/T M1 M0 98H D7 D6 D5 D4 D3 D2 D1 D0 SCON SM0 SM1 SM2 REN TB8 RB8 TI RI A8H D7 D6 D5 D4 D3 D2 D1 D0 IE EA - - ES ET1 EX1 ET0 EX0 B8H D7 D6 D5 D4 D3 D2 D1 D0 IP - - - PS PT1 PX1 PT0 PX0 D0H D7 D6 D5 D4 D3 D2 D1 D0 PSW Cy Ac F0 RS1 RS0 OV - P ","wordCount":"7478","inLanguage":"zh","image":"https://blog.starry-s.moe/avatar.png","datePublished":"2020-11-03T20:19:36+08:00","dateModified":"2020-12-09T12:31:15+08:00","author":{"@type":"Person","name":"STARRY-S"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.starry-s.moe/posts/2020/learn-mcs8051/"},"publisher":{"@type":"Organization","name":"STARRY-S' Blog","logo":{"@type":"ImageObject","url":"https://blog.starry-s.moe/favicon-32x32.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.starry-s.moe/ accesskey=h title="Blog (Alt + H)"><img src=https://blog.starry-s.moe/apple-touch-icon.png alt aria-label=logo height=24>Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.starry-s.moe/gallery/ title=相册><span>相册</span></a></li><li><a href=https://blog.starry-s.moe/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.starry-s.moe/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.starry-s.moe/categories/ title=分类><span>分类</span></a></li><li><a href=https://blog.starry-s.moe/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.starry-s.moe/projects/ title=项目><span>项目</span></a></li><li><a href=https://blog.starry-s.moe/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.starry-s.moe/>主页</a>&nbsp;»&nbsp;<a href=https://blog.starry-s.moe/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">51单片机习题整理</h1><div class=post-meta><span title='2020-11-03 20:19:36 +0800 +0800'>2020-11-03 20:19:36 +0800</span>&nbsp;·&nbsp;15 分钟&nbsp;·&nbsp;7478 字&nbsp;·&nbsp;STARRY-S&nbsp;|&nbsp;<a href=https://github.com/STARRY-S/blog/edit/main/content/posts/2020/learn-mcs8051/index.md rel="noopener noreferrer edit" target=_blank>Edit Text</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#硬件结构指令系统>硬件结构&指令系统</a></li><li><a href=#汇编语言程序>汇编语言程序</a></li><li><a href=#中断系统>中断系统</a></li><li><a href=#定时器和计数器>定时器和计数器</a></li><li><a href=#串行口>串行口</a></li><li><a href=#io口--外部存储器拓展>I/O口 & 外部存储器拓展</a></li><li><a href=#sfr列表>SFR列表</a></li></ul></nav></div></details></div><div class=post-content><p>赶在<del>期中考试</del>(骑磨烤柿)前把单片机的课后习题整理出来&mldr;</p><p>(实在是没什么可拿来更新博客的了, 就干脆写点复习资料吧&mldr;)</p><hr><blockquote><p>本篇内容为作者整理资料所得, 仅供学习使用。如需转载请务必遵循CC BY-NC-ND 4.0协议。
请勿将本篇内容作为权威的教学辅导资料使用, 因无法保证100%准确, 仅供参考。</p><p>如果发现了本篇存在的错误, 欢迎在页面下方提issue指正。</p><p>本篇文章使用MathJax显示数学公式，在使用RSS阅读器时会出现无法正确显示的情况。</p></blockquote><meting-js server=netease type=song id=1429420739 theme=#233333></meting-js><h2 id=硬件结构指令系统>硬件结构&指令系统<a hidden class=anchor aria-hidden=true href=#硬件结构指令系统>#</a></h2><ol><li><p>8051复位后从地址<code>0000H</code>开始执行程序, SP的值为<code>07H</code>。</p><p>PC: 两字节(16位)寄存器, 也称程序计数器。</p><p>SP: 堆栈指针, 指示出堆栈顶部在<strong>内部RAM块</strong>中的位置。</p><p>单片机的堆栈设在了内部RAM区, 单片机复位后, SP中的内容为<code>07H</code>(指向第0组工作寄存器的R7), 堆栈实际上从<code>08H</code>开始。</p><p>若SP被初始化为<code>39H</code>, 则堆栈实际上是从<code>3AH</code>开始的。</p><p>执行<code>LCALL addr16</code>指令时，单片机先将PC的低字节压栈，再将PC的高字节压栈，最后把转移地址送入PC中。</p><p>与之类似的<code>LJMP</code>类无条件转移指令，单片机只修改PC的值，并不堆栈保存跳转前的PC中保存的地址。</p><p>执行<code>RET</code>指令后, SP值减2 (因为PC为2字节寄存器), 进行两次出栈操作，第一次出栈送PC的高位，第二次出栈送PC的低位。</p><p>中断服务程序结束指令<code>RETI</code>不仅将堆栈中保存的2字节地址分别送入PC的高位和低位中，而且复位中断系统。因此<code>RET</code>和<code>RETI</code>不同。</p><p><code>RET</code>和<code>RETI</code>对堆栈的操作是相同的。</p></li><li><p>PSW中的<code>RS1 RS0</code>=<code>10B</code>时, R2的RAM地址为<code>12H</code>。</p><p>PSW： 程序状态字寄存器, 从<code>PSW.7</code>至<code>PSW.0</code>分别为<code>Cy</code>(进位标志位), <code>Ac</code>(辅助进位标志位), <code>F0</code>(标志位), <code>RS1</code>和<code>RS0</code>(寄存器区选择控制位), <code>OV</code>(溢出位), 保留位, <code>P</code>(奇偶标志位, 奇数为1, 偶数为0)。</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center>D7</th><th style=text-align:center>D6</th><th style=text-align:center>D5</th><th style=text-align:center>D4</th><th style=text-align:center>D3</th><th style=text-align:center>D2</th><th style=text-align:center>D1</th><th style=text-align:center>D0</th></tr></thead><tbody><tr><td style=text-align:center>PSW</td><td style=text-align:center>Cy</td><td style=text-align:center>Ac</td><td style=text-align:center>F0</td><td style=text-align:center>RS1</td><td style=text-align:center>RS0</td><td style=text-align:center>OV</td><td style=text-align:center></td><td style=text-align:center>P</td></tr></tbody></table><p><code>RS1 RS0</code> = <code>10B</code>时, 使用第二组工作寄存器区, 第0组工作寄存器区R0-R7的地址为<code>00H-07H</code>, 第1组为<code>08H-0FH</code>, 第2组为<code>10H-17H</code>, 第3组为<code>18H-1FH</code>(每组长度为8个字节, 每个寄存器占1个字节)。</p><p>因此, 当A为<code>01110010B</code>时, PSW中P为0(偶数个1)。</p><p><code>INC A</code>指令不改变<code>PSW</code>中的<code>Cy</code>，只有可能改变奇偶标志位<code>P</code>。</p><p>假设PSW为<code>18H</code>, 即<code>00011000B</code>, 此时使用第3组工作寄存器, R0地址为<code>18H</code>, R7地址为<code>1FH</code>。</p><p>复位后, 默认选择的寄存器区是0区。</p></li><li><p>8051片外数据存储器的寻址空间为<code>0000H~0FFFFH</code></p></li><li><p>位地址<code>07H</code>位于字节地址<code>20H</code>, 位地址<code>7FH</code>位于字节地址<code>2FH</code>。</p><p>片内RAM中<code>20H~2FH</code>这16个单元即可进行共128位的位寻址, 也可进行字节寻址。</p><p>字节地址及其位地址见下表所示：</p><table><thead><tr><th style=text-align:center>字节地址</th><th style=text-align:center>D7</th><th style=text-align:center>D6</th><th style=text-align:center>D5</th><th style=text-align:center>D4</th><th style=text-align:center>D3</th><th style=text-align:center>D2</th><th style=text-align:center>D1</th><th style=text-align:center>D0</th></tr></thead><tbody><tr><td style=text-align:center>2FH</td><td style=text-align:center>7FH</td><td style=text-align:center>7EH</td><td style=text-align:center>7DH</td><td style=text-align:center>7CH</td><td style=text-align:center>7BH</td><td style=text-align:center>7AH</td><td style=text-align:center>79H</td><td style=text-align:center>78H</td></tr><tr><td style=text-align:center>2EH</td><td style=text-align:center>77H</td><td style=text-align:center>76H</td><td style=text-align:center>75H</td><td style=text-align:center>74H</td><td style=text-align:center>73H</td><td style=text-align:center>72H</td><td style=text-align:center>71H</td><td style=text-align:center>70H</td></tr><tr><td style=text-align:center>2DH</td><td style=text-align:center>6FH</td><td style=text-align:center>6EH</td><td style=text-align:center>6DH</td><td style=text-align:center>6CH</td><td style=text-align:center>6BH</td><td style=text-align:center>6AH</td><td style=text-align:center>69H</td><td style=text-align:center>68H</td></tr><tr><td style=text-align:center>&mldr;</td><td style=text-align:center>&mldr;</td><td style=text-align:center>&mldr;</td><td style=text-align:center>&mldr;</td><td style=text-align:center>&mldr;</td><td style=text-align:center>&mldr;</td><td style=text-align:center>&mldr;</td><td style=text-align:center>&mldr;</td><td style=text-align:center>&mldr;</td></tr><tr><td style=text-align:center>21H</td><td style=text-align:center>0FH</td><td style=text-align:center>0EH</td><td style=text-align:center>0DH</td><td style=text-align:center>0CH</td><td style=text-align:center>0BH</td><td style=text-align:center>0AH</td><td style=text-align:center>09H</td><td style=text-align:center>08H</td></tr><tr><td style=text-align:center>20H</td><td style=text-align:center>07H</td><td style=text-align:center>06H</td><td style=text-align:center>05H</td><td style=text-align:center>04H</td><td style=text-align:center>03H</td><td style=text-align:center>02H</td><td style=text-align:center>01H</td><td style=text-align:center>00H</td></tr></tbody></table><p>因此<code>00H~07H</code>位于字节地址<code>20H</code>, <code>78H-7FH</code>位于字节地址<code>2FH</code>。</p><p>除此之外，一些特殊功能寄存器（SFR）可进行位寻址（字节地址能够被8整除），SFR中位地址有83个（共有88个，5个未用），能够位寻址的SFR的字节地址末位均为<code>0H</code>或<code>8H</code>。</p></li><li><p>访问外部存储器时, P0口用来传输低8位地址和数据, P2口用来传送高8位地址。</p></li><li><p>访问外部存储器时, ALE的输出用于锁存低8位地址。</p></li><li><p>一个机器周期为12个震荡周期</p></li><li><p>为保证读入数据正确, 在读一个端口引脚之前应先向相应的端口锁存器写1。</p><p>如果在读一个端口引脚之前向对应的输出锁存器写了0, 将总是读到0。</p><p>8051访问片外存储器时, 利用ALE信号锁存来自P0的低8位地址信号。</p></li><li><p>只能用直接寻址方式访问特殊功能寄存器。</p><p>如果为8052单片机, 在访问高128字节的RAM时, 只能用间接寻址方式寻址。</p><p>访问片外数据存储器64Kbyte时, 使用<code>DPTR</code>做间接寻址寄存器。</p><p>使用<code>MOVX @DPTR</code>类指令访问外部扩展存储器时, P2口输出高8位地址, P0口传送低8位地址和数据。</p><p>8051中, <code>PC</code>和<code>DPTR</code>都用于提供地址时, <code>PC</code>是<strong>用户程序不可访问的</strong>, <code>DPTR</code>可以分为两个8位寄存器<code>DPH</code>和<code>DPL</code>使用。</p></li><li><p>累加器A的值为<code>30H</code>, 指令<code>MOVC A, @A+PC</code>位于地址<code>3000H</code>。执行该指令时, 程序存储器地址<code>3031H</code>的内容被传送至累加器A。</p></li></ol><p>指令<code>MOVC A, @A+PC</code>长度为1字节, 位于地址<code>3000H</code>, 因此PC值为<code>3001H</code>, 故<code>A+PC</code>为<code>3031H</code>。</p><ol start=11><li>设SP的值为<code>5FH</code>, 指令<code>LCALL DELAY</code>所在地址为<code>2030H</code>, 子程序DELAY所在地址为<code>20A0H</code>, 则该指令完成的操作是将地址<code>2033H</code>压入堆栈保存, 将地址<code>20A0H</code>送入PC, SP的值应在该指令执行结束后变成<code>61H</code>。</li></ol><p>单片机执行子程序或中断服务程序时, 需要保护现场, 即将PC当前的值压栈保存, 当子程序或中断服务程序运行结束后再进行出栈。(所以如果子程序修改了栈的内容, 在子程序运行结束后程序有可能会运行错误)。</p><p><strong>PC是16字节寄存器</strong>, 所以SP需要加2, 以此分别保存PC的高、低8位的数据。</p><p><code>LCALL addr16</code>这条指令占3字节, 其中addr16占两字节, 因此程序可跳转64KB范围内的地址。</p><p>(<code>ACALL</code>指令只能跳转当前所在的<strong>2K范围内</strong>的地址, 如果不涉及到片外数据存储器的话, 通常只用<code>SJMP</code>和<code>AJMP</code>)</p><blockquote><p>在网上搜到的答案「将<code>3500H</code>送入PC」是错误的, 实际是将<code>20A0H</code>送入PC, 因为DELAY所在的地址为<code>20A0H</code>, 和<code>3500H</code>一点关系都没有。</p></blockquote><ol start=12><li><code>MOVC</code>访问 <strong>程序(ROM)</strong> 存储器, <code>MOVX</code>指令访问 <strong>外部数据</strong> 存储器。</li></ol><p><code>MOVC</code>为查表指令, 只有<code>MOVC @A+PC</code>和<code>MOVC @A+DPTR</code>这两条, 均为单字节指令。</p><p><code>MOVX</code>用于累加器A与外部数据存储器进行传送。</p><p>可以是<code>MOVX A, @DPTR</code>, <code>MOVX A, @Ri</code>, <code>MOVX @DPTR, A</code>, <code>MOVX @Ri, A</code>，其中i为0或1.</p><p>当使用<code>MOVX @Ri</code>类指令时，只有P0口用来传送地址和数据，P2口的状态不会发生改变，因此可使用<code>MOV P2, #12H</code>指令设定高8位的地址。</p><p>当采用Ri作间接寻址时, 只能寻找片外256个单元的数据存储器, 此时8位地址和数据均由P0口传送，P2口的状态不发生改变。</p><ol start=13><li>假设指令<code>DJNZ R7, rel</code>位于<code>005FH</code>, 如果在执行该指令前寄存器R7值为<code>00H</code>, 偏移量rel为<code>02H</code>, 则该指令执行后下一条要执行的指令所在的地址是<code>005FH</code>。</li></ol><p><code>DJNZ R7, rel</code>位于<code>005FH</code>, 该指令长度为<strong>2字节</strong> (书上写的3字节是错的), 所以在执行这条指令开始时PC值在原来的基础上 + 2 变为<code>0061H</code>。又因为rel为<code>02H</code>, 所以执行这条指令后, PC值变为<code>0063H</code>。</p><ol start=14><li>分析下面子程序的功能, 假设8051单片机的震荡频率为6MHz。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nl>DL:</span> <span class=nf>MOV</span> <span class=no>R7</span><span class=p>,</span> <span class=c1>#0AH
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>L0:</span> <span class=nf>MOV</span> <span class=no>R6</span><span class=p>,</span> <span class=c1>#250
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>L1:</span> <span class=nf>NOP</span>
</span></span><span class=line><span class=cl>     <span class=nf>NOP</span>
</span></span><span class=line><span class=cl>     <span class=nf>DJNZ</span> <span class=no>R6</span><span class=p>,</span> <span class=no>L1</span>
</span></span><span class=line><span class=cl>     <span class=nf>DJNZ</span> <span class=no>R7</span><span class=p>,</span> <span class=no>L0</span>
</span></span><span class=line><span class=cl>     <span class=nf>RET</span>
</span></span></code></pre></div><p>R7为10, R6为250, 因此两个<code>NOP</code>加上一个<code>DJNZ</code>一共循环了250次, 该250次的循环一共执行了10次。</p><p><code>NOP</code>为1周期指令, <code>DJNZ</code>为2周期指令, 两个<code>NOP</code>加一个<code>DJNZ</code>共4周期。</p><p>6MHz下一个机器周期为<span class=has-mathjax>\(12 \div (6 \times 10^6)= 2{\mu}s\)</span>, 12MHz下一个机器周期为1微秒。</p><p>故程序该子程序延时了<span class=has-mathjax>\((4 \times 250 \times 10 \times 12) \div (6 \times 10^6) = 20(ms)\)</span></p><p>(实际上有10次<code>MOV R6, #250</code>和10次<code>DJNZ R7, L0</code>造成的30个机器周期的约0.6ms的误差)</p><hr><blockquote><p>以下部分写于2020年11月25日</p></blockquote><h2 id=汇编语言程序>汇编语言程序<a hidden class=anchor aria-hidden=true href=#汇编语言程序>#</a></h2><ol><li><p>编写一个子程序, 将内部RAM 40H~4FH的内容复制到50H~5FH。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nl>COPY:</span> <span class=nf>MOV</span> <span class=no>R0</span><span class=p>,</span> <span class=c1>#40H
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nf>MOV</span> <span class=no>R1</span><span class=p>,</span> <span class=c1>#50H
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nf>MOV</span> <span class=no>R2</span><span class=p>,</span> <span class=c1>#10H
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>; 40H~4FH一共复制了16次
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>LOOP:</span>
</span></span><span class=line><span class=cl>      <span class=nf>MOV</span> <span class=no>A</span><span class=p>,</span> <span class=err>@</span><span class=no>R0</span>
</span></span><span class=line><span class=cl>      <span class=nf>MOV</span> <span class=err>@</span><span class=no>R1</span><span class=p>,</span> <span class=no>A</span>
</span></span><span class=line><span class=cl>      <span class=nf>INC</span> <span class=no>R0</span>
</span></span><span class=line><span class=cl>      <span class=nf>INC</span> <span class=no>R1</span>
</span></span><span class=line><span class=cl>      <span class=nf>DJNZ</span> <span class=no>R2</span><span class=p>,</span> <span class=no>LOOP</span>
</span></span><span class=line><span class=cl>      <span class=nf>RET</span>
</span></span></code></pre></div><p>因为没有<code>MOV @RX, @RX</code>这条指令, 所以用A做数据的中转站。</p></li><li><p>将任何无符号8位二进制数转换为BCD码的子程序, 入口参数为内部RAM单元20H, 出口参数为内部RAM单元30H和31H, 30H存放百位数, 31H存放十位数和个位数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nl>CV:</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>R0</span><span class=p>,</span> <span class=c1>#20H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=no>A</span><span class=p>,</span> <span class=err>@</span><span class=no>R0</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>B</span><span class=p>,</span> <span class=c1>#100
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>DIV</span> <span class=no>AB</span><span class=c1>; A除以100, 得到的百位数存在A中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=mi>30</span><span class=no>H</span><span class=p>,</span> <span class=no>A</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>A</span><span class=p>,</span> <span class=no>B</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>B</span><span class=p>,</span> <span class=c1>#10
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>DIV</span> <span class=no>AB</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>SWAP</span> <span class=no>A</span>
</span></span><span class=line><span class=cl><span class=nf>ADD</span> <span class=no>A</span><span class=p>,</span> <span class=no>B</span><span class=c1>; 也可以用ORL
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=mi>31</span><span class=no>H</span><span class=p>,</span> <span class=no>A</span>
</span></span><span class=line><span class=cl><span class=nf>RET</span>
</span></span></code></pre></div><p><code>DIV AB</code>和<code>MUL AB</code>的A和B之间没有逗号。</p></li><li><p>内部RAM 30H单元存放两位十进制数 (压缩BCD码), 编写将该十进制数转换为对应ASCII码的子程序, 转换结果存放到内部RAM 40H (十位数) 和41H (个位数) 单元。</p><blockquote><p>ASCII码： <code>30H</code>为<code>0</code>, <code>41H</code>为<code>A</code>, <code>61H</code>为<code>a</code></p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nl>CV:</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>A</span><span class=p>,</span> <span class=mi>30</span><span class=no>H</span>
</span></span><span class=line><span class=cl><span class=nf>ANL</span> <span class=no>A</span><span class=p>,</span> <span class=c1>#0FH
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=no>DPTR</span><span class=p>,</span> <span class=c1>#DATA; 或者直接用ADD A, #30H即可
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOVC</span> <span class=no>A</span><span class=p>,</span> <span class=err>@</span><span class=no>A</span><span class=err>+</span><span class=no>DPTR</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=mi>41</span><span class=no>H</span><span class=p>,</span> <span class=no>A</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>A</span><span class=p>,</span> <span class=mi>30</span><span class=no>H</span>
</span></span><span class=line><span class=cl><span class=nf>SWAP</span> <span class=no>A</span>
</span></span><span class=line><span class=cl><span class=nf>ANL</span> <span class=no>A</span><span class=p>,</span> <span class=c1>#0FH
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOVC</span> <span class=no>A</span><span class=p>,</span> <span class=err>@</span><span class=no>A</span><span class=err>+</span><span class=no>DPTR</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=mi>40</span><span class=no>H</span><span class=p>,</span> <span class=no>A</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>RET</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>DATA:</span>
</span></span><span class=line><span class=cl><span class=nf>DB</span> <span class=mi>30</span><span class=no>H</span><span class=p>,</span> <span class=mi>31</span><span class=no>H</span><span class=p>,</span> <span class=mi>32</span><span class=no>H</span><span class=p>,</span> <span class=mi>33</span><span class=no>H</span><span class=p>,</span> <span class=mi>34</span><span class=no>H</span><span class=p>,</span> <span class=mi>35</span><span class=no>H</span><span class=p>,</span> <span class=mi>36</span><span class=no>H</span><span class=p>,</span> <span class=mi>37</span><span class=no>H</span><span class=p>,</span> <span class=mi>38</span><span class=no>H</span><span class=p>,</span> <span class=mi>39</span><span class=no>H</span>
</span></span></code></pre></div></li><li><p>8个8位数相加, 求平均值, 入口地址为<code>30H</code>~<code>37H</code>, 结果存到<code>40H</code>。</p><p>把8位数相加存在溢出, 所以把相加结果以16进制存到R2、R3中, 再除以8( 右移3次), 即可求得不四舍五入的平均值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>R0</span><span class=p>,</span> <span class=c1>#30H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=no>R1</span><span class=p>,</span> <span class=c1>#08H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=no>R2</span><span class=p>,</span> <span class=c1>#00H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=no>R3</span><span class=p>,</span> <span class=c1>#00H
</span></span></span><span class=line><span class=cl><span class=c1>; 初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>LOOP:</span>
</span></span><span class=line><span class=cl><span class=nf>CLR</span> <span class=no>C</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>A</span><span class=p>,</span> <span class=err>@</span><span class=no>R0</span>
</span></span><span class=line><span class=cl><span class=nf>ADD</span> <span class=no>A</span><span class=p>,</span> <span class=no>R3</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>R3</span><span class=p>,</span> <span class=no>A</span>
</span></span><span class=line><span class=cl><span class=nf>JNC</span> <span class=no>SKIP</span>
</span></span><span class=line><span class=cl><span class=nf>INC</span> <span class=no>R2</span>
</span></span><span class=line><span class=cl><span class=nl>SKIP:</span>
</span></span><span class=line><span class=cl><span class=nf>INC</span> <span class=no>R0</span>
</span></span><span class=line><span class=cl><span class=nf>DJNZ</span> <span class=no>R1</span><span class=p>,</span> <span class=no>LOOP</span>
</span></span></code></pre></div><p>这样结果被保存到R2、R3中, 然后需要写一个循环右移3位的程序。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>R4</span><span class=p>,</span> <span class=c1>#03H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>LOOP2:</span>
</span></span><span class=line><span class=cl><span class=nf>RRC</span> <span class=no>R2</span>
</span></span><span class=line><span class=cl><span class=nf>RRC</span> <span class=no>R3</span>
</span></span><span class=line><span class=cl><span class=nf>DJNZ</span> <span class=no>R4</span><span class=p>,</span> <span class=no>LOOP2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=mi>40</span><span class=no>H</span><span class=p>,</span> <span class=no>R3</span>
</span></span><span class=line><span class=cl><span class=c1>; 右移3次后R2的低4位为0, 结果保存在R3中
</span></span></span></code></pre></div><p>这样R3中求得的是不带四舍五入的结果。</p><p>如果需要带四舍五入的话第一种方法是判断最后一次右移时最低位是否为<span class=has-mathjax>\(1\)</span>，<span class=has-mathjax>\((1 / 2 = 0.5)\)</span>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>R4</span><span class=p>,</span> <span class=c1>#03H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>LOOP2:</span>
</span></span><span class=line><span class=cl><span class=nf>RRC</span> <span class=no>R2</span>
</span></span><span class=line><span class=cl><span class=nf>RRC</span> <span class=no>R3</span>
</span></span><span class=line><span class=cl><span class=nf>DJNZ</span> <span class=no>R4</span><span class=p>,</span> <span class=no>LOOP2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>JNC</span> <span class=no>SKIP2</span>
</span></span><span class=line><span class=cl><span class=nf>INC</span> <span class=no>R3</span>
</span></span><span class=line><span class=cl><span class=nl>SKIP2:</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=mi>40</span><span class=no>H</span><span class=p>,</span> <span class=no>R3</span>
</span></span><span class=line><span class=cl><span class=c1>; 右移3次后R2肯定为0
</span></span></span></code></pre></div><p>这样是带四舍五入的结果。</p><p>第二种方法，8个8位数相加求平均值，要求四舍五入的话，只需要在这8个数求和后再加4（<code>0100B</code>），之后右移3次。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>ADD</span> <span class=no>A</span><span class=p>,</span> <span class=c1>#04H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=no>R3</span><span class=p>,</span> <span class=no>A</span>
</span></span><span class=line><span class=cl><span class=nf>JNC</span> <span class=no>SKIP2</span>
</span></span><span class=line><span class=cl><span class=nf>INC</span> <span class=no>R2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>SKIP2:</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>R4</span><span class=p>,</span> <span class=c1>#03H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>LOOP2:</span>
</span></span><span class=line><span class=cl><span class=nf>RRC</span> <span class=no>R2</span>
</span></span><span class=line><span class=cl><span class=nf>RRC</span> <span class=no>R3</span>
</span></span><span class=line><span class=cl><span class=nf>DJNZ</span> <span class=no>R4</span><span class=p>,</span> <span class=no>LOOP2</span>
</span></span></code></pre></div><p>结果保存在R3中。</p></li></ol><hr><h2 id=中断系统>中断系统<a hidden class=anchor aria-hidden=true href=#中断系统>#</a></h2><ol><li><p>8051的外部中断有低电平触发和下降沿触发两种触发方式。外部中断1的中断向量地址是<code>0013H</code>。</p><p>在响应中断时, 单片机自动生成一条长调用指令<code>LCALL addr16</code>, 其地址为中断入口地址。</p><table><thead><tr><th style=text-align:center>中断源</th><th style=text-align:center>入口地址</th></tr></thead><tbody><tr><td style=text-align:center>INT0</td><td style=text-align:center>0003H</td></tr><tr><td style=text-align:center>T0</td><td style=text-align:center>000BH</td></tr><tr><td style=text-align:center>INT1</td><td style=text-align:center>0013H</td></tr><tr><td style=text-align:center>T1</td><td style=text-align:center>001BH</td></tr><tr><td style=text-align:center>串行口</td><td style=text-align:center>0023H</td></tr></tbody></table><p>通常在中断入口地址处放一条<strong>无条件转移指令</strong><code>*JMP</code>。</p><p>内部查询顺序同入口地址的顺序，由高到低。</p></li><li><p>执行指令<code>MOV IP, #0BH</code>( <code>#00001011B</code>)后, 中断优先级最高者为<code>PX0</code>, 最低为<code>PS</code>。</p><p>IP: 中断优先级寄存器, 其前3为无意义, 后5位( IP.4至IP.0)为：<code>PS</code>, <code>PT1</code>, <code>PX1</code>, <code>PT0</code>, <code>PX0</code>, 分别对应串行口、定时器T1、外部中断1、定时器0、外部中断0。</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center>D7</th><th style=text-align:center>D6</th><th style=text-align:center>D5</th><th style=text-align:center>D4</th><th style=text-align:center>D3</th><th style=text-align:center>D2</th><th style=text-align:center>D1</th><th style=text-align:center>D0</th></tr></thead><tbody><tr><td style=text-align:center>IP</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>PS</td><td style=text-align:center>PT1</td><td style=text-align:center>PX1</td><td style=text-align:center>PT0</td><td style=text-align:center>PX0</td></tr></tbody></table><p>单片机复位以后, IP的内容为0, 各个中断源均为低优先级中断。</p><p>在同时收到几个同一优先级的中断请求时, 中断响应取决于内部查询顺序, 其顺序由高到低为：<code>INT0</code>、<code>T0</code>、<code>INT1</code>、<code>T1</code>、<code>串行口</code>。</p><p>当中断源均为同一优先级时, 当它们同时申请中断时CPU首先响应外部中断0</p></li><li><p>8051的晶振频率为12MHz, 则最短的外部中断响应时间为3<span class=has-mathjax>\(\mu\)</span>s, 最长的外部中断响应时间为12<span class=has-mathjax>\(\mu\)</span>。</p></li><li><p>中断标记位于单片机寄存器的<code>TCON</code>和<code>SCON</code>中。</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center>D7</th><th style=text-align:center>D6</th><th style=text-align:center>D5</th><th style=text-align:center>D4</th><th style=text-align:center>D3</th><th style=text-align:center>D2</th><th style=text-align:center>D1</th><th style=text-align:center>D0</th></tr></thead><tbody><tr><td style=text-align:center>TCON</td><td style=text-align:center>TF1</td><td style=text-align:center>TR1</td><td style=text-align:center>TF0</td><td style=text-align:center>TR0</td><td style=text-align:center>IE1</td><td style=text-align:center>IT1</td><td style=text-align:center>IE0</td><td style=text-align:center>IT0</td></tr><tr><td style=text-align:center>SCON</td><td style=text-align:center>SM0</td><td style=text-align:center>SM1</td><td style=text-align:center>SM2</td><td style=text-align:center>REN</td><td style=text-align:center>TB8</td><td style=text-align:center>RB8</td><td style=text-align:center>TI</td><td style=text-align:center>RI</td></tr></tbody></table><p><code>TCON</code>中<code>TF1</code>和<code>TF0</code>为定时器/计数器中断标志位, <code>TR1</code>和<code>TR0</code>为定时/计数启动位, <code>IE1</code>和<code>IE0</code>为外部中断标志位, <code>IT1</code>和<code>IT0</code>为选择外部中断为边沿触发(1)还是电平触发(0)方式。</p><p><code>SCON</code>中前几位与串行口有关，第1位和第2位的<code>TI</code>和<code>RI</code>(是大写字母I不是数字1)分别为串行口中断发送中断请求标志位(发送成功后置1)和接受中断请求标志位( 接受成功后置1)。串口中断无法硬件清零, 只能软件清零。</p><p>当IE中EA为1、ES为1时，TI或RI为1时，CPU执行无条件转移指令<code>LJMP 0023H</code>, 执行串行口中断服务程序。</p></li><li><p>要使8051能够响应定时器T1的中断和串行口中断, 不响应其他中断, 则中断允许寄存器<code>IE</code>的内容为<code>98H</code>(<code>10011000B</code>)。</p><p>中断允许寄存器IE：</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center>D7</th><th style=text-align:center>D6</th><th style=text-align:center>D5</th><th style=text-align:center>D4</th><th style=text-align:center>D3</th><th style=text-align:center>D2</th><th style=text-align:center>D1</th><th style=text-align:center>D0</th></tr></thead><tbody><tr><td style=text-align:center>IE</td><td style=text-align:center>EA</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>ES</td><td style=text-align:center>ET1</td><td style=text-align:center>EX1</td><td style=text-align:center>ET0</td><td style=text-align:center>EX0</td></tr></tbody></table><p><code>EA</code>为总控制位, 当<code>EA</code>为1时, CPU才可以响应中断请求。</p><p><code>ES</code>为串行口中断允许位, <code>ET1</code>和<code>ET0</code>为定时器中断允许位, <code>EX1</code>和<code>EX0</code>为外部中断允许位。</p></li></ol><hr><h2 id=定时器和计数器>定时器和计数器<a hidden class=anchor aria-hidden=true href=#定时器和计数器>#</a></h2><ol><li><p>使T0工作方式1的溢出周期最长的初值是<code>0000H</code>。</p><p>定时器/计数器工作在方式0为13位计数器, 由<code>TLX</code>的低5位和<code>THX</code>的高8位组成13位计数器, 最大值为<span class=has-mathjax>\(2^{13}-1 = 8191\)</span>, 晶振频率12MHz下计时周期最长为8.192ms。工作在方式1时由均为8位的<code>TLX</code>和<code>THX</code>组成16位计数器, 最大值为65535, 晶振频率为12M下最长为65.536ms。</p><p>当定时器/计数器工作在方式2时, 可以循环定时/计数。当计数溢出后, 自动将8位的<code>THX</code>装入8位的<code>TLX</code>中, 可省去重装初值的时间, 最大值为<code>255</code>, 晶振频率12M下计时周期最长为0.256ms。</p></li><li><p><code>T1</code>配置为方式3时, 停止计数, 方式3只适用于定时器0。</p><p>定时器<code>T0</code>的方式3将其分为两个8位定时器, 其中<code>TH0</code>只能做定时器使用。</p></li><li><p>设8051单片机的晶振频率为12MHz, 定时器作计数器使用时, 其计数输入信号的最高频率为500KHz。</p><p>当定时器用作计数器时, 当检测到引脚上的负跳变时计数器的值增一。检测下降沿需要2个机器周期, 即24个震荡周期, 所以输入信号最高频率为 <span class=has-mathjax>\(12M \div 24 = 500KHz\)</span>。</p></li><li><p>用定时器方式2扩展一个下降沿触发的外部中断, 计数初值应为<code>FFH</code>。</p><p>此处定时器2以计数器方式运行, 当检测到一个下降沿后, 计数器加一后溢出, 因此会执行定时器中断的中断子程序。</p></li></ol><hr><blockquote><p>2020年12月3日：
前两天感冒, 休息了几天(<del>打了两天的游戏</del>)后继续。</p></blockquote><h2 id=串行口>串行口<a hidden class=anchor aria-hidden=true href=#串行口>#</a></h2><ol><li><p>串行口TXD为高电平, 表示这是数据位或停止位或空闲状态。</p><p>串行口工作在方式1时, <code>TXD</code>用来发送数据、<code>RXD</code>用来接受数据。方式1的一帧数据为10位, 起始为为0, 停止位为1, 数据位和空闲状态均可能为0或1。</p></li><li><p>串行口工作在方式3时, 发送的第9位数据要事先写入寄存器<code>SCON</code>的<code>TB8</code>, 接收的第9位数据被写入同一寄存器的<code>RB8</code>。</p><p>串行口控制寄存器SCON：</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center>D7</th><th style=text-align:center>D6</th><th style=text-align:center>D5</th><th style=text-align:center>D4</th><th style=text-align:center>D3</th><th style=text-align:center>D2</th><th style=text-align:center>D1</th><th style=text-align:center>D0</th></tr></thead><tbody><tr><td style=text-align:center>SCON</td><td style=text-align:center>SM0</td><td style=text-align:center>SM1</td><td style=text-align:center>SM2</td><td style=text-align:center>REN</td><td style=text-align:center>TB8</td><td style=text-align:center>RB8</td><td style=text-align:center>TI</td><td style=text-align:center>RI</td></tr></tbody></table><p>其中<code>SM0</code>、<code>SM1</code>为串口的工作方式选择位, 方式0为同步移位寄存器方式, 方式1为8位异步收发, 方式2和方式3为9位异步收发。</p><p>波特率：串行口每秒钟传送的比特位数，单位bits/s。</p><p>方式0的波特率<strong>固定</strong>为 <span class=has-mathjax>\(f_{osc}/12\)</span>, 方式2的波特率为 <span class=has-mathjax>\(f_{osc}/64\)</span> 或 <span class=has-mathjax>\(f_{osc}/32\)</span> (由SMOD控制)。</p><p>方式1的波特率和方式3的波特率可变, 公式为 <span class=has-mathjax>\((2^{SMOD} / 32) \times 定时器T1的溢出率\)</span>。</p><p>T1的溢出率为定时器T1的周期的倒数，定时器的周期为</p><div class=has-mathjax>$$T = \frac{12\times (2^n - X )}{f\_{osc}}$$</div><p>当T1工作在方式2时，n为8，波特率为：</p><div class=has-mathjax>$$波特率=\frac{(2^{SMOD} \div 32) \times f_{osc}}{12 \times (256 - X)}$$</div><p><span class=has-mathjax>\(X\)</span>为定时器T1的初值。</p><p>串口工作在方式1，波特率为2400，则每秒钟最大能发送/接收 <span class=has-mathjax>\(2400 \div 10 = 240Byte\)</span> 的数据。</p><blockquote><p>单片机工作在方式1时, 1帧数据为1个起始位、8个数据位、1个停止位共10位。</p></blockquote><p>8051的UART工作在方式3，要求每秒钟能传送不少于900个字节的数据，则波特率应当大于 <span class=has-mathjax>\(900 \times 8 = 7200bits/s\)</span>。</p></li><li><p>比特率2400Kbits/s，时钟频率12M，PC机发送8个字节的数据存到单片机的<code>30H-37H</code>中，随后单片机发送2个确认字节<code>55H</code>和<code>AAH</code>给PC机，使用查询方式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>ORG</span> <span class=mi>0000</span><span class=no>H</span>
</span></span><span class=line><span class=cl><span class=nl>MAIN:</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>SCON</span><span class=p>,</span> <span class=c1>#50H
</span></span></span><span class=line><span class=cl><span class=c1>; 串口使用方式1，且允许接收
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=no>PCON</span><span class=p>,</span> <span class=c1>#00H
</span></span></span><span class=line><span class=cl><span class=c1>; 波特率不加倍
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=no>TMOD</span><span class=p>,</span> <span class=c1>#20H
</span></span></span><span class=line><span class=cl><span class=c1>; 定时器1使用方式2
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>TL1</span><span class=p>,</span> <span class=c1>#0F3H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=no>TH1</span><span class=p>,</span> <span class=c1>#0F3H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>SETB</span> <span class=no>TR1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>LOOP:</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>R0</span><span class=p>,</span> <span class=c1>#30H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=no>R1</span><span class=p>,</span> <span class=c1>#08H
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nl>REC:</span>
</span></span><span class=line><span class=cl><span class=nf>JNB</span> <span class=no>RI</span><span class=p>,</span> <span class=no>$</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=err>@</span><span class=no>R0</span><span class=p>,</span> <span class=no>SBUF</span>
</span></span><span class=line><span class=cl><span class=nf>CLR</span> <span class=no>RI</span> <span class=c1>; 软件清零RI
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>INC</span> <span class=no>R0</span>
</span></span><span class=line><span class=cl><span class=nf>DJNZ</span> <span class=no>R1</span><span class=p>,</span> <span class=no>REC</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>SBUF</span><span class=p>,</span> <span class=c1>#55H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>JNB</span> <span class=no>TI</span><span class=p>,</span> <span class=no>$</span>
</span></span><span class=line><span class=cl><span class=nf>CLR</span> <span class=no>TI</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>SBUF</span><span class=p>,</span> <span class=c1>#0AAH
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>JNB</span> <span class=no>TI</span><span class=p>,</span> <span class=no>$</span>
</span></span><span class=line><span class=cl><span class=nf>CLR</span> <span class=no>TI</span>
</span></span><span class=line><span class=cl><span class=nf>AJMP</span> <span class=no>LOOP</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>END</span>
</span></span></code></pre></div><p>单片机接收到数据后，RI被置1，代表SBUF中的数据有效，取走SBUF中的数据后需要软件清零RI（串口中断不会自动清零RI）。</p><p>当单片机执行写SBUF操作时，串口发送开始，TI被自动置1，在发送完成后TI被自动清0。</p></li></ol><hr><blockquote><p>2020年12月7日：</p></blockquote><h2 id=io口--外部存储器拓展>I/O口 & 外部存储器拓展<a hidden class=anchor aria-hidden=true href=#io口--外部存储器拓展>#</a></h2><ol><li><p>8051使用指令<code>MOVX A, @R0</code>读外部数据存储器时，不起作用的信号是<code>WR</code>。</p><p>8051在使用<code>MOVX @DPTR</code>类指令读外部数据存储器时，P0和P2先输出外部数据的地址，单片机发出的<code>ALE</code>信号的负跳沿将P0口输出的地址锁存在地址锁存器(74HC573)里，之后单片机发出<code>RD</code>信号，读取外部数据存储器（RAM）的数据到总线再传送到P0口上。最后单片机从P0口读取数据保存到A中。</p><p>如果是写外部数据存储器时，单片机将不发出<code>RD</code>信号而是<code>WR</code>信号，将A中的数据写入外部数据存储器中。</p></li><li><p>存储器芯片6264需要13根地址线。</p><p>62256的容量为 <span class=has-mathjax>\(256Kbit \div 8 = 32KB = 2^{15}\)</span>, 需要15根地址线。</p><p>6264的容量为 <span class=has-mathjax>\(64Kbit \div 8 = 8KB = 2^{13}\)</span>，所以需要13根地址线。</p><p>6116容量为 <span class=has-mathjax>\(16Kbit \div 8 = 2KB = 2^{11}\)</span>, 需要11根地址线。</p><p>计算方法是62 <span class=has-mathjax>\(X\)</span> 的 <span class=has-mathjax>\(容量=X \div 8(K)\)</span>。</p></li><li><p>使用16位地址模式时，8051的外部数据存储器寻址空间为64KB。</p></li><li><p>基于8051的单片机系统能拓展的外部数据存储器容量无限制。</p><p>有的书上说最大只能拓展64KB，实际是最大寻址空间为64KB，拓展的外部数据存储器容量无限制。</p></li><li><p>8051的程序存储器可用来存放用户程序和数据。 例如使用<code>DW</code>或<code>DB</code>指令用来定义数据。</p><p>所以应用程序也可以使用<code>MOVC A, @A+DPTR</code>访问程序存储器中的数据。</p></li></ol><blockquote><p>除此之外LED数码管和外部存储器拓展、外部I/O设备拓展部分有很多需要根据线路图计算地址和DA转换的题，因为线路图源自老师提供的PDF，而老师为PDF加了密码，意味着不允许外传，所以我就不放到博客上面了，<del>除非我自己用Porteus画一个类似的</del></p></blockquote><ol start=6><li><p>LED段码入口地址8004H，位选入口地址8002H，将30H-32H保存的6个压缩BCD码发送到6位共阴极数码管上显示， 要求编写延时1ms的子程序。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nl>MAIN:</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>R0</span><span class=p>,</span> <span class=c1>#30H
</span></span></span><span class=line><span class=cl><span class=c1>; R2用来计数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=no>R2</span><span class=p>,</span> <span class=c1>#03H
</span></span></span><span class=line><span class=cl><span class=c1>; R3用来位选
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=no>R3</span><span class=p>,</span> <span class=c1>#01H
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nl>LOOP:</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>A</span><span class=p>,</span> <span class=err>@</span><span class=no>R0</span>
</span></span><span class=line><span class=cl><span class=nf>SWAP</span> <span class=no>A</span>
</span></span><span class=line><span class=cl><span class=nf>ANL</span> <span class=no>A</span><span class=p>,</span> <span class=c1>#0FH
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=no>DPTR</span><span class=p>,</span> <span class=c1>#TAB
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOVC</span> <span class=no>A</span><span class=p>,</span> <span class=err>@</span><span class=no>A</span><span class=err>+</span><span class=no>DPTR</span>
</span></span><span class=line><span class=cl><span class=c1>; 取高4位BCD码对应的段码
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>DPTR</span><span class=p>,</span> <span class=c1>#8004H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOVX</span> <span class=no>A</span><span class=p>,</span> <span class=err>@</span><span class=no>A</span><span class=err>+</span><span class=no>DPTR</span>
</span></span><span class=line><span class=cl><span class=c1>; 先送段码
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>A</span><span class=p>,</span> <span class=no>R3</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>DPTR</span><span class=p>,</span> <span class=c1>#8002H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOVX</span> <span class=err>@</span><span class=no>DPTR</span><span class=p>,</span> <span class=no>A</span>
</span></span><span class=line><span class=cl><span class=nf>RL</span> <span class=no>A</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>R3</span><span class=p>,</span> <span class=no>A</span>
</span></span><span class=line><span class=cl><span class=c1>; 再送位选
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>LCALL</span> <span class=no>DELAY</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>A</span><span class=p>,</span> <span class=err>@</span><span class=no>R0</span>
</span></span><span class=line><span class=cl><span class=nf>ANL</span> <span class=no>A</span><span class=p>,</span> <span class=c1>#0FH
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=no>DPTR</span><span class=p>,</span> <span class=c1>#TAB
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOVC</span> <span class=no>A</span><span class=p>,</span> <span class=err>@</span><span class=no>A</span><span class=err>+</span><span class=no>DPTR</span>
</span></span><span class=line><span class=cl><span class=c1>; 取低4位BCD码对应的段码
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>DPTR</span><span class=p>,</span> <span class=c1>#8004H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOVX</span> <span class=no>A</span><span class=p>,</span> <span class=err>@</span><span class=no>A</span><span class=err>+</span><span class=no>DPTR</span>
</span></span><span class=line><span class=cl><span class=c1>; 送段码
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>A</span><span class=p>,</span> <span class=no>R3</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>DPTR</span><span class=p>,</span> <span class=c1>#8002H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOVX</span> <span class=err>@</span><span class=no>DPTR</span><span class=p>,</span> <span class=no>A</span>
</span></span><span class=line><span class=cl><span class=nf>RL</span> <span class=no>A</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>R3</span><span class=p>,</span> <span class=no>A</span>
</span></span><span class=line><span class=cl><span class=c1>; 送位选
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>LCALL</span> <span class=no>DELAY</span>
</span></span><span class=line><span class=cl><span class=nf>INC</span> <span class=no>R0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>DJNZ</span> <span class=no>R2</span><span class=p>,</span> <span class=no>LOOP</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>DELAY:</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>R7</span><span class=p>,</span> <span class=c1>#250
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>DL:</span>
</span></span><span class=line><span class=cl><span class=nf>NOP</span>
</span></span><span class=line><span class=cl><span class=nf>NOP</span>
</span></span><span class=line><span class=cl><span class=nf>DJNZ</span> <span class=no>R7</span><span class=p>,</span> <span class=no>DL</span>
</span></span><span class=line><span class=cl><span class=nf>RET</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>TAB:</span>
</span></span><span class=line><span class=cl><span class=nf>DB</span> <span class=mi>3</span><span class=no>FH</span><span class=p>,</span> <span class=mi>06</span><span class=no>H</span><span class=p>,</span> <span class=mi>5</span><span class=no>BH</span><span class=p>,</span> <span class=mi>4</span><span class=no>FH</span><span class=p>,</span> <span class=mi>66</span><span class=no>H</span><span class=p>,</span> <span class=mi>6</span><span class=no>DH</span><span class=p>,</span> <span class=mi>7</span><span class=no>DH</span><span class=p>,</span> <span class=mi>07</span><span class=no>H</span><span class=p>,</span> <span class=mi>7</span><span class=no>FH</span><span class=p>,</span> <span class=mi>6</span><span class=no>FH</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>END</span>
</span></span></code></pre></div></li><li><p>打印机数据输入接口和P1直接相连，STB接口和P3.4相连，BUSY接口和P3.3相连，不使用ACK应答信号，编写将外部存储器<code>1000H-100FH</code>的数据发送到打印机打印的子程序。</p><p><img loading=lazy src=images/1.jpg#center alt></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nl>PRINT:</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>DPTR</span><span class=p>,</span> <span class=c1>#1000H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=no>R2</span><span class=p>,</span> <span class=c1>#10H
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nl>LOOP:</span>
</span></span><span class=line><span class=cl><span class=nf>JB</span> <span class=no>P3.3</span><span class=p>,</span> <span class=no>$</span>
</span></span><span class=line><span class=cl><span class=c1>; 确保打印机处于空闲状态
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOVX</span> <span class=no>A</span><span class=p>,</span> <span class=err>@</span><span class=no>DPTR</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>P1</span><span class=p>,</span> <span class=no>A</span>
</span></span><span class=line><span class=cl><span class=nf>CLR</span> <span class=no>P3.4</span>
</span></span><span class=line><span class=cl><span class=nf>SETB</span> <span class=no>P3.4</span>
</span></span><span class=line><span class=cl><span class=nf>INC</span> <span class=no>DPTR</span>
</span></span><span class=line><span class=cl><span class=nf>DJNZ</span> <span class=no>R2</span><span class=p>,</span> <span class=no>LOOP</span>
</span></span><span class=line><span class=cl><span class=nf>RET</span>
</span></span></code></pre></div><p>如果打印机没有和P1直接相连，而是连接到数据锁存器上（74HC374），锁存器的时钟信号的入口地址为<code>A000H</code>。</p><p>使用堆栈保护间接寻址寄存器的值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nl>PRINT:</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>R2</span><span class=p>,</span> <span class=c1>#10H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOV</span> <span class=no>DPTR</span><span class=p>,</span> <span class=c1>#1000H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>LOOP:</span>
</span></span><span class=line><span class=cl><span class=nf>JB</span> <span class=no>P3.3</span><span class=p>,</span> <span class=no>$</span>
</span></span><span class=line><span class=cl><span class=c1>; 确保打印机处于空闲状态
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>MOVX</span> <span class=no>A</span><span class=p>,</span> <span class=err>@</span><span class=no>DPTR</span>
</span></span><span class=line><span class=cl><span class=nf>PUSH</span> <span class=no>DPL</span>
</span></span><span class=line><span class=cl><span class=nf>PUSH</span> <span class=no>DPH</span>
</span></span><span class=line><span class=cl><span class=nf>MOV</span> <span class=no>DPTR</span><span class=p>,</span> <span class=c1>#0A000H
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>MOVX</span> <span class=err>@</span><span class=no>DPTR</span><span class=p>,</span> <span class=no>A</span>
</span></span><span class=line><span class=cl><span class=nf>POP</span> <span class=no>DPH</span>
</span></span><span class=line><span class=cl><span class=nf>POP</span> <span class=no>DPL</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>CLR</span> <span class=no>P3.4</span>
</span></span><span class=line><span class=cl><span class=nf>SETB</span> <span class=no>P3.4</span>
</span></span><span class=line><span class=cl><span class=nf>INC</span> <span class=no>DPTR</span>
</span></span><span class=line><span class=cl><span class=nf>DJNZ</span> <span class=no>R2</span><span class=p>,</span> <span class=no>LOOP</span>
</span></span><span class=line><span class=cl><span class=nf>RET</span>
</span></span></code></pre></div></li></ol><hr><h2 id=sfr列表>SFR列表<a hidden class=anchor aria-hidden=true href=#sfr列表>#</a></h2><table><thead><tr><th style=text-align:center>87H</th><th style=text-align:center>D7</th><th style=text-align:center>D6</th><th style=text-align:center>D5</th><th style=text-align:center>D4</th><th style=text-align:center>D3</th><th style=text-align:center>D2</th><th style=text-align:center>D1</th><th style=text-align:center>D0</th></tr></thead><tbody><tr><td style=text-align:center>PCON</td><td style=text-align:center>SMOD</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td style=text-align:center>PD</td><td style=text-align:center>IDL</td></tr></tbody></table><table><thead><tr><th style=text-align:center>88H</th><th style=text-align:center>D7</th><th style=text-align:center>D6</th><th style=text-align:center>D5</th><th style=text-align:center>D4</th><th style=text-align:center>D3</th><th style=text-align:center>D2</th><th style=text-align:center>D1</th><th style=text-align:center>D0</th></tr></thead><tbody><tr><td style=text-align:center>TCON</td><td style=text-align:center>TF1</td><td style=text-align:center>TR1</td><td style=text-align:center>TF0</td><td style=text-align:center>TR0</td><td style=text-align:center>IE1</td><td style=text-align:center>IT1</td><td style=text-align:center>IE0</td><td style=text-align:center>IT0</td></tr></tbody></table><table><thead><tr><th style=text-align:center>89H</th><th style=text-align:center>D7</th><th style=text-align:center>D6</th><th style=text-align:center>D5</th><th style=text-align:center>D4</th><th style=text-align:center>D3</th><th style=text-align:center>D2</th><th style=text-align:center>D1</th><th style=text-align:center>D0</th></tr></thead><tbody><tr><td style=text-align:center>TMOD</td><td style=text-align:center>GATE</td><td style=text-align:center>C/T</td><td style=text-align:center>M1</td><td style=text-align:center>M0</td><td style=text-align:center>GATE</td><td style=text-align:center>C/T</td><td style=text-align:center>M1</td><td style=text-align:center>M0</td></tr></tbody></table><table><thead><tr><th style=text-align:center>98H</th><th style=text-align:center>D7</th><th style=text-align:center>D6</th><th style=text-align:center>D5</th><th style=text-align:center>D4</th><th style=text-align:center>D3</th><th style=text-align:center>D2</th><th style=text-align:center>D1</th><th style=text-align:center>D0</th></tr></thead><tbody><tr><td style=text-align:center>SCON</td><td style=text-align:center>SM0</td><td style=text-align:center>SM1</td><td style=text-align:center>SM2</td><td style=text-align:center>REN</td><td style=text-align:center>TB8</td><td style=text-align:center>RB8</td><td style=text-align:center>TI</td><td style=text-align:center>RI</td></tr></tbody></table><table><thead><tr><th style=text-align:center>A8H</th><th style=text-align:center>D7</th><th style=text-align:center>D6</th><th style=text-align:center>D5</th><th style=text-align:center>D4</th><th style=text-align:center>D3</th><th style=text-align:center>D2</th><th style=text-align:center>D1</th><th style=text-align:center>D0</th></tr></thead><tbody><tr><td style=text-align:center>IE</td><td style=text-align:center>EA</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td style=text-align:center>ES</td><td style=text-align:center>ET1</td><td style=text-align:center>EX1</td><td style=text-align:center>ET0</td><td style=text-align:center>EX0</td></tr></tbody></table><table><thead><tr><th style=text-align:center>B8H</th><th style=text-align:center>D7</th><th style=text-align:center>D6</th><th style=text-align:center>D5</th><th style=text-align:center>D4</th><th style=text-align:center>D3</th><th style=text-align:center>D2</th><th style=text-align:center>D1</th><th style=text-align:center>D0</th></tr></thead><tbody><tr><td style=text-align:center>IP</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td style=text-align:center>PS</td><td style=text-align:center>PT1</td><td style=text-align:center>PX1</td><td style=text-align:center>PT0</td><td style=text-align:center>PX0</td></tr></tbody></table><table><thead><tr><th style=text-align:center>D0H</th><th style=text-align:center>D7</th><th style=text-align:center>D6</th><th style=text-align:center>D5</th><th style=text-align:center>D4</th><th style=text-align:center>D3</th><th style=text-align:center>D2</th><th style=text-align:center>D1</th><th style=text-align:center>D0</th></tr></thead><tbody><tr><td style=text-align:center>PSW</td><td style=text-align:center>Cy</td><td style=text-align:center>Ac</td><td style=text-align:center>F0</td><td style=text-align:center>RS1</td><td style=text-align:center>RS0</td><td style=text-align:center>OV</td><td style=text-align:center>-</td><td style=text-align:center>P</td></tr></tbody></table><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.starry-s.moe/tags/%E5%8D%95%E7%89%87%E6%9C%BA/>单片机</a></li><li><a href=https://blog.starry-s.moe/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/>学习资料</a></li></ul><nav class=paginav><a class=prev href=https://blog.starry-s.moe/posts/2021/hello-2021/><span class=title>« 上一页</span><br><span>Hello 2021</span>
</a><a class=next href=https://blog.starry-s.moe/posts/2021/archlinux-pavilion-gaming-laptop/><span class=title>下一页 »</span><br><span>惠普光影精灵4在Arch Linux下使用Optimus Manager配置双显卡</span></a></nav></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//starry-s-blog.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>© 2016 - 2025 STARRY-S | <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a> | Hosted on <a href=https://pages.github.com>GitHub Pages</a><br></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>const pathname=window.location.pathname,images=document.querySelectorAll("img");Array.from(images).forEach(e=>{if(!pathname.includes("/posts/"))return;if(e.src.indexOf("images")<0)return;e.addEventListener("load",()=>fitImage(e)),e.complete&&e.naturalWidth!==0&&fitImage(e)});function fitImage(e){e.style.marginLeft="auto",e.style.marginRight="auto",e.naturalWidth/e.naturalHeight<1.1&&(e.style.maxWidth="60%",e.style.height="auto")}</script><script src=/js/home-info.js></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>