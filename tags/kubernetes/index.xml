<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Kubernetes on STARRY-S&#39; Blog</title>
    <link>https://blog.starry-s.moe/tags/kubernetes/</link>
    <description>Recent content in Kubernetes on STARRY-S&#39; Blog</description>
    <image>
      <title>STARRY-S&#39; Blog</title>
      <url>https://blog.starry-s.moe/avatar.png</url>
      <link>https://blog.starry-s.moe/avatar.png</link>
    </image>
    <generator>Hugo -- 0.133.1</generator>
    <language>zh</language>
    <copyright>2016 - 2024 STARRY-S | CC BY-NC-ND 4.0 | Hosted on GitHub Pages
</copyright>
    <lastBuildDate>Tue, 16 Jul 2024 00:35:24 +0800</lastBuildDate>
    <atom:link href="https://blog.starry-s.moe/tags/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>再探容器网络</title>
      <link>https://blog.starry-s.moe/posts/2024/container-network-2/</link>
      <pubDate>Thu, 11 Jul 2024 01:12:36 +0800</pubDate>
      <guid>https://blog.starry-s.moe/posts/2024/container-network-2/</guid>
      <description>&lt;p&gt;在写之前的 &lt;a href=&#34;../container-network-1/&#34;&gt;初探容器网络&lt;/a&gt; 时是想过什么时候写后续的，这期间鸽了不到半年，嗯也不算很久，忙完手头的事情继续更一下容器网络系列……&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>在写之前的 <a href="../container-network-1/">初探容器网络</a> 时是想过什么时候写后续的，这期间鸽了不到半年，嗯也不算很久，忙完手头的事情继续更一下容器网络系列……</p>
<meting-js server="netease" type="song" id="1416321955" theme="#233333"></meting-js>
<p>在上篇 <a href="../container-network-1/">初探容器网络</a> 中咱简单的写了 Linux Network Namespace 和容器相关的东西，所以这篇会继续上一篇的内容拓展一下 CNI 网络插件和他的好朋友们……</p>
<h2 id="container-network-interface-cni">Container Network Interface (CNI)</h2>
<p>有关 CNI 的介绍可以在他的<a href="https://www.cni.dev/">官网</a> 找到，CNI 定义了一套 Linux 容器的网络接口规范和相关代码库，还提供了一些简单的样例网络插件代码。Kubernetes 使用 CNI 网络插件为 Pod 创建网络。
需要注意的是 Docker 的容器网络不是由 CNI 插件创建的，而是由 Docker 自己的 <a href="https://docs.docker.com/network/drivers/">Driver</a> 负责创建，这里需要注意别弄混了，其他的容器运行时也不完全是使用 CNI 网络插件，也可能是用的别的插件的标准。</p>
<p>不过 CNI 在 Kubernetes 中广为使用，学起来也不是很难（），所以本篇就先围绕着 CNI 进行简单的介绍，熟悉完 CNI 后其他种类的网络插件也相对的能更容易上手一些。</p>
<p>首先来熟悉一下到底什么是 CNI 插件，有关 CNI 的定义和详细介绍可以在<a href="https://www.cni.dev/docs/spec/">这里</a>找到，但新手可能单凭这个介绍，无法对 CNI 有详细的了解，实际上官网的定义介绍感觉更像是给一个熟悉 CNI 网络插件的查阅的手册而不是帮一个萌新去了解的入门指南。</p>
<p>需要知道的是，CNI 插件是一个可执行文件，一个最简单的 CNI 插件可以是一个有执行权限的脚本，执行 <code>ip link</code>, <code>ip route</code> 等命令，为 Pod 的 Network Namespace 实现添加、删除虚拟接口等操作，就可以算得上是一个 CNI 插件。但强大一点的 CNI 插件都是由更灵活的编程语言写的程序，编译成二进制文件放在系统的某个路径下面。Kubernetes 集群可以指定默认使用的 CNI 网络插件（比如广为人知的 Calico、Flannel、Cilium 等），除此之外还可以使用一些额外插件为 Pod 创建多个虚拟网卡（例如 Multus CNI）。在 Pod 创建时，执行 CNI 插件为 Pod 的 Network Namespace 创建网卡接口。这里网卡接口类型不再局限为单纯的 Veth Pair，而可以是其他复杂类型的接口（比如 Macvlan、IPvlan 甚至你自己可以写个网络驱动）。在部署一个 Kubernetes 集群后，节点上执行 <code>ip link</code> 能看到一大堆名称为 <code>vethXXXX@ifN</code> 的虚拟接口，这些其实是由集群使用的 CNI 插件创建的 Veth Pair，因为这些 NS 的文件被放在了 <code>/run/netns</code> 路径下面，所以可以被 <code>ip link</code> 命令识别到，而 Docker 的 NS 文件不在这个路径里面，所以用 Docker 跑容器时，执行 <code>ip link</code> 不会有许多 Veth 虚拟设备输出在屏幕上。</p>
<h3 id="cni-参数">CNI 参数</h3>
<p>执行 CNI 时，通过一些环境变量向 CNI 传递参数，传递的环境变量为：</p>
<ul>
<li><code>CNI_COMMAND</code>: CNI 插件执行的命令，在 CNI Spec 1.0.0 中，CNI 插件支持 <code>ADD</code>, <code>DEL</code>, <code>CHECK</code>, <code>VERSION</code> 这四个命令。</li>
<li><code>CNI_CONTAINERID</code>: 容器的 Container ID，由 Container Runtime 管理。</li>
<li><code>CNI_NETNS</code>: 容器的 Network Namespace 在节点上的路径，通常是在 <code>/run/netns/[nsname]</code> 路径下面。</li>
<li><code>CNI_IFNAME</code>: 待创建的网卡名称，例如最常见的情况是容器里有一块网卡，名为 <code>eth0</code>。</li>
<li><code>CNI_ARGS</code>: 向 CNI 插件传递的一些其他参数，格式为 <code>KEY=VALUE</code>，由分号分隔，例如 <code>FOO=BAR;ABC=123</code>。</li>
<li><code>CNI_PATH</code>: CNI 可执行文件所在路径列表。</li>
</ul>
<h3 id="cni-返回值">CNI 返回值</h3>
<p>如果 CNI 成功执行并完成了指定的命令，它的返回值为 0，其他非 0 的返回值代表错误，输出一串 JSON，包含错误的详细内容，关于 CNI Errors 的定义可以看<a href="https://www.cni.dev/docs/spec/#error">这里</a>。</p>
<h3 id="cni-命令">CNI 命令</h3>
<p>在 CNI Spec 0.4.0 之前，CNI 插件只定义了 <code>ADD</code>, <code>DEL</code>, <code>VERSION</code> 这三个命令，分别对应 “添加网络”、“删除网络”、“支持版本”。CNI Spec 0.4.0 新引入了 <code>CHECK</code> 命令，用于对已创建网络的容器进行校验。</p>
<h3 id="配置文件">配置文件</h3>
<p>CNI 配置文件为 JSON 格式，以下是一个样例配置文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// CNI Spec Version
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nt">&#34;cniVersion&#34;</span><span class="p">:</span> <span class="s2">&#34;1.0.0&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Network name.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;dbnet&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;plugins&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// CNI Plugin Binary name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bridge&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// CNI Plugin specific parameters...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nt">&#34;bridge&#34;</span><span class="p">:</span> <span class="s2">&#34;cni0&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Dictionary with IPAM (IP Address Management) specific values.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nt">&#34;ipam&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// IPAM Plugin Binary name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;host-local&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// IPAM specific params...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nt">&#34;subnet&#34;</span><span class="p">:</span> <span class="s2">&#34;10.1.0.0/16&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;gateway&#34;</span><span class="p">:</span> <span class="s2">&#34;10.1.0.1&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;routes&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span> <span class="nt">&#34;dst&#34;</span><span class="p">:</span> <span class="s2">&#34;0.0.0.0/0&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="p">},</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;dns&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;nameservers&#34;</span><span class="p">:</span> <span class="p">[</span> <span class="s2">&#34;10.1.0.1&#34;</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>通常高级的 CNI 插件可以自动的由 Controller 生成他所需的 CNI Config，而简易的 CNI 插件需要手动的编写 Config 文件放在 <code>/etc/cni/net.d/</code> 目录下面（不同类型的集群的 Config 路径可能不一致）。</p>
<p>光凭上面这一大堆 Specification 定义比较难理解这个抽象的 CNI 插件，所以接下来我们拆解一个样例 CNI 插件，并手撮一个简易的 CNI 插件。</p>
<h3 id="样例-cni-插件">样例 CNI 插件</h3>
<p>在 GitHub 的 <code>containernetworking</code> Org 里能找到许多 CNI Plugin 代码，<a href="https://github.com/containernetworking/plugins/tree/main/plugins/main/ptp">这里</a>为样例 <code>p2p</code> CNI Plugin 插件代码，这个插件能为容器和主机之间创建一对 Veth Pair，可以主机和容器之间的点对点访问。在<a href="https://github.com/containernetworking/plugins">这里</a>还能找到一些其他样例插件代码，例如为容器创建 Linux Kernel 的 <code>bridge</code>、<code>macvlan</code>、<code>ipvlan</code> 等类型的网卡接口。</p>
<p>样例插件由 Go 语言编写，所以这里需要你熟悉 Go 编程语言。为了折腾 CNI 插件，你需要有一个调试使用的 Kubernetes 集群，因为 Pod 需要具备跨节点通信的能力，所以集群最好至少有一个 Master (etcd, controlplane, scheduler) 和 2 个 Worker (scheduler) 节点，将 Pod 调度到不同节点上验证节点之间 Pod 连同性，因为折腾 CNI 时很可能同一个节点的 Pod 能互相访问而不能跨节点访问，也可能节点能访问其他节点上的 Pod 但无法访问运行在当前节点的 Pod 等一堆复杂问题。集群的节点最好是可以灵活重启抗造的物理机或 KVM 虚拟机（因公有云的网路环境略微复杂且大多数公有云都不支持 KVM，所以不是很建议在公有云上折腾 CNI 网络插件）。
同时本篇需要你具备一些基本的计算机网络基础，例如可以先看一下 IPv4/IPv6 的网络编址/子网划分、OSI 七层模型的 L2 和 L3 层，例如 2 层交换机 (Switch) 和 3 层交换机 (Router) 的区别，更复杂一点的地方需要你清楚常见的 VLAN (<a href="https://en.wikipedia.org/wiki/IEEE_802.1Q">IEEE 802.1Q</a>、<a href="https://en.wikipedia.org/wiki/IEEE_802.1ad">802.1ad</a>) 以及后续衍生出来的 <a href="https://en.wikipedia.org/wiki/Virtual_Extensible_LAN">VXLAN</a> 等 *VLAN 协议……</p>
<p>往简单来说 CNI 插件基本的功能就是执行 <code>ip link</code>, <code>ip route</code>, <code>ip netns</code> 等一系列命令为 Pod 的 Network Namespace 和主机的 Default Network Namespace 之间创建虚拟网卡实现互相通信。Go 语言同样有 Library 提供了 Linux <code>ip</code> 命令的代码，常用的 Go Library 包含以下的：</p>
<ul>
<li><a href="https://github.com/vishvananda/netlink">https://github.com/vishvananda/netlink</a>: Go 语言实现的 <code>iproute2</code> 命令行工具的 API，可以执行类似 <code>ip link</code>, <code>ip route</code> 等命令</li>
<li><a href="https://github.com/vishvananda/netns">https://github.com/vishvananda/netns</a>: Go 语言实现的处理 Linux Network Namespace API</li>
<li><a href="https://github.com/containernetworking/cni">https://github.com/containernetworking/cni</a>: 包含 CNI 定义 Types 和常用组件</li>
</ul>
<p>打开<a href="https://github.com/containernetworking/plugins/blob/main/plugins/main/ptp/ptp.go">样例 p2p CNI 插件代码</a>，先看他的 <code>main</code> 函数只有简洁的一行 <code>skel.PluginMain</code>，这个方法会处理环境变量传入的 CNI 参数，加载 Config，执行相应的 COMMAND。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">skel</span><span class="p">.</span><span class="nf">PluginMain</span><span class="p">(</span><span class="nx">cmdAdd</span><span class="p">,</span> <span class="nx">cmdCheck</span><span class="p">,</span> <span class="nx">cmdDel</span><span class="p">,</span> <span class="nx">version</span><span class="p">.</span><span class="nx">All</span><span class="p">,</span> <span class="nx">bv</span><span class="p">.</span><span class="nf">BuildString</span><span class="p">(</span><span class="s">&#34;ptp&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="add-命令">ADD 命令</h4>
<p>ADD 命令用于为容器创建网卡（或修改已有的网卡），找一下 p2p CNI 插件的 <code>cmdAdd</code> 函数，大致简化一下里面的代码流程为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">cmdAdd</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">skel</span><span class="p">.</span><span class="nx">CmdArgs</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Load CNI Config
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">conf</span> <span class="o">:=</span> <span class="nx">NetConf</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">StdinData</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">conf</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed to load netconf: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ---------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Execute IPAM command to get IP address
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ipam</span><span class="p">.</span><span class="nf">ExecAdd</span><span class="p">(</span><span class="nx">conf</span><span class="p">.</span><span class="nx">IPAM</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">StdinData</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">current</span><span class="p">.</span><span class="nf">NewResultFromResult</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">IPs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;IPAM plugin returned missing IP config&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ip</span><span class="p">.</span><span class="nf">EnableForward</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">IPs</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Could not enable IP forwarding: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ---------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Create Veth Pair for Pod Network Namespace
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">netns</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ns</span><span class="p">.</span><span class="nf">GetNS</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">Netns</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed to open netns %q: %v&#34;</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Netns</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">netns</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">hostInterface</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">setupContainerVeth</span><span class="p">(</span><span class="nx">netns</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">IfName</span><span class="p">,</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">MTU</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ---------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Setup Veth Pair for default Network Namespace
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">setupHostVeth</span><span class="p">(</span><span class="nx">hostInterface</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Some other IP forward (masquerade) operations...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">types</span><span class="p">.</span><span class="nf">PrintResult</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">CNIVersion</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>简单概括样例 P2P Plugin 的 ADD 命令流程大致为：</p>
<ol>
<li>加载 CNI Config 配置文件</li>
<li>执行 IPAM 获取 Pod IP</li>
<li>创建一对 Veth Pair，其中一个 Iface 接口放在 Pod NS 中，配置 IP、路由等</li>
<li>另一个 Veth Pair 的 Iface 接口放在 default NS 中，配置 IP、路由……</li>
<li>配置 Default NS 的 Masquerade 等额外操作</li>
<li>输出运行结果</li>
</ol>
<h4 id="del-命令">DEL 命令</h4>
<p>DEL 命令用于释放容器和主机的网卡接口资源，在 Pod 删除时被执行，以下是简化的样例 P2P Plugin 的 <code>cmdDel</code> 函数代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">cmdDel</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">skel</span><span class="p">.</span><span class="nx">CmdArgs</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Load CNI Config
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">conf</span> <span class="o">:=</span> <span class="nx">NetConf</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">StdinData</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">conf</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed to load netconf: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ---------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Execute IPAM command to release IP address
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ipam</span><span class="p">.</span><span class="nf">ExecDel</span><span class="p">(</span><span class="nx">conf</span><span class="p">.</span><span class="nx">IPAM</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">StdinData</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ---------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Release link interface &amp; masquerades...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">ipnets</span> <span class="p">[]</span><span class="o">*</span><span class="nx">net</span><span class="p">.</span><span class="nx">IPNet</span>
</span></span><span class="line"><span class="cl">    <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ns</span><span class="p">.</span><span class="nf">WithNetNSPath</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">Netns</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">_</span> <span class="nx">ns</span><span class="p">.</span><span class="nx">NetNS</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ipnets</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">ip</span><span class="p">.</span><span class="nf">DelLinkByNameAddr</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">IfName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">ip</span><span class="p">.</span><span class="nx">ErrLinkNotFound</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ipnets</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">IPMasq</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ipn</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ipnets</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">err</span> <span class="p">=</span> <span class="nx">ip</span><span class="p">.</span><span class="nf">TeardownIPMasq</span><span class="p">(</span><span class="nx">ipn</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>简单概括 DEL 命令流程大致为：</p>
<ol>
<li>加载 CNI Config 配置文件</li>
<li>执行 IPAM 释放 Pod IP</li>
<li>释放 Veth Pair 和其他配置 (Masquerade&hellip;)</li>
</ol>
<h4 id="check-命令">CHECK 命令</h4>
<p>CHECK 命令用于校验 Pod 网络，在 CNI Spec 0.4.0 中，Config 新增了 <code>prevResult</code> 字段，记录了 CNI 插件上一次执行 ADD 命令的结果。
CHECK 命令将 <code>prevResult</code> 记录的状态信息和设定的期望值进行比对。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">cmdCheck</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">skel</span><span class="p">.</span><span class="nx">CmdArgs</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Load CNI Config
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">conf</span> <span class="o">:=</span> <span class="nx">NetConf</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">StdinData</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">conf</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed to load netconf: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// -----------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Run IPAM plugin CHECK command and get results
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">err</span> <span class="p">=</span> <span class="nx">ipam</span><span class="p">.</span><span class="nf">ExecCheck</span><span class="p">(</span><span class="nx">conf</span><span class="p">.</span><span class="nx">IPAM</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">StdinData</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// -----------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Parse prevResult
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">NetConf</span><span class="p">.</span><span class="nx">RawPrevResult</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;ptp: Required prevResult missing&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">version</span><span class="p">.</span><span class="nf">ParsePrevResult</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">conf</span><span class="p">.</span><span class="nx">NetConf</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Convert whatever the IPAM result was into the current Result type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">current</span><span class="p">.</span><span class="nf">NewResultFromResult</span><span class="p">(</span><span class="nx">conf</span><span class="p">.</span><span class="nx">PrevResult</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">contMap</span> <span class="nx">current</span><span class="p">.</span><span class="nx">Interface</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Find interfaces for name whe know, that of host-device inside container
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">intf</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">result</span><span class="p">.</span><span class="nx">Interfaces</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">IfName</span> <span class="o">==</span> <span class="nx">intf</span><span class="p">.</span><span class="nx">Name</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Netns</span> <span class="o">==</span> <span class="nx">intf</span><span class="p">.</span><span class="nx">Sandbox</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">contMap</span> <span class="p">=</span> <span class="o">*</span><span class="nx">intf</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// -----------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Check Network Namespace Name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Netns</span> <span class="o">!=</span> <span class="nx">contMap</span><span class="p">.</span><span class="nx">Sandbox</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Sandbox in prevResult %s doesn&#39;t match configured netns: %s&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">contMap</span><span class="p">.</span><span class="nx">Sandbox</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Netns</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Check prevResults for ips, routes and dns against values found in the container
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">netns</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">_</span> <span class="nx">ns</span><span class="p">.</span><span class="nx">NetNS</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Check interface
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">err</span> <span class="o">:=</span> <span class="nf">validateCniContainerInterface</span><span class="p">(</span><span class="nx">contMap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Check IPs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">err</span> <span class="p">=</span> <span class="nx">ip</span><span class="p">.</span><span class="nf">ValidateExpectedInterfaceIPs</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">IfName</span><span class="p">,</span> <span class="nx">result</span><span class="p">.</span><span class="nx">IPs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Check routes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">err</span> <span class="p">=</span> <span class="nx">ip</span><span class="p">.</span><span class="nf">ValidateExpectedRoute</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">Routes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Other checks...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>样例 P2P 插件的 DEL 命令流程大致为：</p>
<ol>
<li>加载 CNI Config 配置文件</li>
<li>执行 IPAM CHECK 命令</li>
<li>加载 prevResult 信息</li>
<li>依次校验 Network Namespace 名称、Pod 网卡、Pod IP、路由表等状态信息</li>
</ol>
<h3 id="运行样例-cni">运行样例 CNI</h3>
<p>上述的样例 P2P CNI 插件仅能为 Pod NS 与主机的 Default NS 之间创建 Veth Pair 并简单的配置 IP 地址和路由表，并不能用于更复杂的场景。如果想在你的调试集群中试用上述样例的 CNI 插件，可以使用 <a href="https://github.com/k8snetworkplumbingwg/multus-cni/">Multus CNI</a>。Multus CNI 可以为 Pod 创建多块网卡，其中 Pod 的默认网卡（通常是 <code>eth0</code>）为 Kubernetes 集群的原生 CNI（例如 Calico、Flannel、Cilium 或其他 CNI），使用 Multus CNI 可以调用上述的样例 P2P CNI 插件为 Pod 创建额外的网卡。</p>
<h4 id="安装-multus-cni">安装 Multus CNI</h4>
<p>目前 Multus CNI 最新版本 (<code>4.0.2</code>) 支持的最高 CNI Spec 版本为 <code>1.0.0</code>，可以运行在 K3s 但有亿点小问题（参考 <a href="https://github.com/k8snetworkplumbingwg/multus-cni/issues/1089#issuecomment-1550442393">Issue</a>），咱写这篇博客用的集群是 K3s <code>v1.28.10+k3s1</code>，一共有两个节点，运行在 KVM 虚拟机中方便折腾。</p>
<p>参照 <a href="https://github.com/k8snetworkplumbingwg/multus-cni/blob/master/docs/quickstart.md#installation">Multus CNI</a> 文档，部署 Multus Daemonset，在每个节点中安装 Multus CNI Binary 文件。</p>
<p>在 K3s 上安装 Multus 的步骤可以看咱之前写的 <a href="../k3s-multus-macvlan/">K3s + Multus CNI 插件使用 Macvlan</a>。</p>
<h3 id="安装样例-cni-binary-文件">安装样例 CNI Binary 文件</h3>
<p>需要将上述的样例 P2P CNI 插件拷贝到 K3s 每个集群节点的 <code>/var/lib/rancher/k3s/data/current/bin</code> 目录下（如果是其他集群，路径为 <code>/opt/cni/bin</code>）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> mkdir -p cni <span class="o">&amp;&amp;</span> <span class="nb">cd</span> cni
</span></span><span class="line"><span class="cl"><span class="gp">$</span> wget https://github.com/containernetworking/plugins/releases/download/v1.5.1/cni-plugins-linux-amd64-v1.5.1.tgz
</span></span><span class="line"><span class="cl"><span class="gp">$</span> tar -zxvf cni-plugins-linux-amd64-v1.5.1.tgz
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo cp ptp /var/lib/rancher/k3s/data/current/bin/
</span></span></code></pre></div><p>创建一个 <code>NetworkAttachmentDefinition</code> Custom Resource，将 p2p 的 CNI Config 存储在这里，配置 Pod 使用 ptp CNI 插件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;k8s.cni.cncf.io/v1&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">NetworkAttachmentDefinition</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">ptp-conf</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">config</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">  &#34;cniVersion&#34;: &#34;1.0.0&#34;,
</span></span></span><span class="line"><span class="cl"><span class="s1">  &#34;type&#34;: &#34;ptp&#34;,
</span></span></span><span class="line"><span class="cl"><span class="s1">  &#34;ipam&#34;: {
</span></span></span><span class="line"><span class="cl"><span class="s1">    &#34;type&#34;: &#34;host-local&#34;,
</span></span></span><span class="line"><span class="cl"><span class="s1">    &#34;subnet&#34;: &#34;192.168.1.0/24&#34;
</span></span></span><span class="line"><span class="cl"><span class="s1">  },
</span></span></span><span class="line"><span class="cl"><span class="s1">  &#34;dns&#34;: {
</span></span></span><span class="line"><span class="cl"><span class="s1">    &#34;nameservers&#34;: [ &#34;192.168.1.0&#34;, &#34;8.8.8.8&#34; ]
</span></span></span><span class="line"><span class="cl"><span class="s1">  }
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> k get network-attachment-definitions.k8s.cni.cncf.io
</span></span><span class="line"><span class="cl"><span class="go">NAME       AGE
</span></span></span><span class="line"><span class="cl"><span class="go">ptp-conf   9s
</span></span></span></code></pre></div><h3 id="创建样例-workload">创建样例 Workload</h3>
<p>接下来可以创建样例工作负载，设置 <code>k8s.v1.cni.cncf.io/networks</code> Annotation 定义 Pod 的第二网卡由上述的 P2P 插件创建。为便于折腾这里的样例负载为 DaemonSet，并赋予容器 Privileged 权限。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">DaemonSet</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">example-ds</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">example-alpine-ds</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">example-alpine-ds</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">annotations</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">k8s.v1.cni.cncf.io/networks</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;ptp-conf&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">example-alpine</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">alpine</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">imagePullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">IfNotPresent</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;sleep&#34;</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">args</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;infinity&#34;</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">securityContext</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">privileged</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> vim example-ds.yaml
</span></span><span class="line"><span class="cl"><span class="gp">$</span> k apply -f example-ds.yaml
</span></span><span class="line"><span class="cl"><span class="go">daemonset.apps/example-ds created
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> k get pods -o wide
</span></span><span class="line"><span class="cl"><span class="go">NAME               READY   STATUS    RESTARTS   AGE   IP           NODE    NOMINATED NODE   READINESS GATES
</span></span></span><span class="line"><span class="cl"><span class="go">example-ds-4865k   1/1     Running   0          3s    10.42.1.7    k3s-2   &lt;none&gt;           &lt;none&gt;
</span></span></span><span class="line"><span class="cl"><span class="go">example-ds-9g5kp   1/1     Running   0          3s    10.42.0.12   k3s-1   &lt;none&gt;           &lt;none&gt;
</span></span></span></code></pre></div><p>查看 Pod 中的网卡信息，除了 <code>lo</code> 回环接口和 <code>eth0</code> 接口外，还有一个由 <code>ptp</code> 创建的 <code>net1</code> 接口，IP 地址为 <code>192.168.1.2</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> k <span class="nb">exec</span> -it example-ds-9g5kp -- sh
</span></span><span class="line"><span class="cl"><span class="gp">#</span> ip a
</span></span><span class="line"><span class="cl"><span class="go">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 127.0.0.1/8 scope host lo
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 ::1/128 scope host
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">2: eth0@if18: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1450 qdisc noqueue state UP
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether ba:ac:48:99:66:73 brd ff:ff:ff:ff:ff:ff
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 10.42.0.12/24 brd 10.42.0.255 scope global eth0
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 fe80::b8ac:48ff:fe99:6673/64 scope link
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">3: net1@if19: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 6a:0b:7d:4b:6f:c5 brd ff:ff:ff:ff:ff:ff
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 192.168.1.2/24 brd 192.168.1.255 scope global net1
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 fe80::680b:7dff:fe4b:6fc5/64 scope link
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">#</span> ip r
</span></span><span class="line"><span class="cl"><span class="go">default via 10.42.0.1 dev eth0
</span></span></span><span class="line"><span class="cl"><span class="go">10.42.0.0/24 dev eth0 scope link  src 10.42.0.12
</span></span></span><span class="line"><span class="cl"><span class="go">10.42.0.0/16 via 10.42.0.1 dev eth0
</span></span></span><span class="line"><span class="cl"><span class="go">192.168.1.0/24 via 192.168.1.1 dev net1  src 192.168.1.2
</span></span></span><span class="line"><span class="cl"><span class="go">192.168.1.1 dev net1 scope link  src 192.168.1.2
</span></span></span></code></pre></div><p>在节点上执行 <code>ip</code> 命令，查看节点的网卡和 IP 地址信息，可以看到除了节点的 <code>lo</code> 和 <code>eth0</code>，Flannel CNI 的 <code>flannel.1</code>, <code>cni0</code> 和一些其他 Pod 的 Veth Pair，有一个 Veth Pair 的 IP 地址为 <code>192.168.1.1/32</code>，这个是由样例 ptp CNI 创建。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> ip a
</span></span><span class="line"><span class="cl"><span class="go">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 127.0.0.1/8 scope host lo
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 ::1/128 scope host noprefixroute
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 52:54:00:de:78:16 brd ff:ff:ff:ff:ff:ff
</span></span></span><span class="line"><span class="cl"><span class="go">    altname enp1s0
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 10.128.0.101/12 brd 10.143.255.255 scope global eth0
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 fe80::5054:ff:fede:7816/64 scope link proto kernel_ll
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">3: flannel.1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UNKNOWN group default
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether ee:82:b4:a0:d9:4d brd ff:ff:ff:ff:ff:ff
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 10.42.0.0/32 scope global flannel.1
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 fe80::ec82:b4ff:fea0:d94d/64 scope link proto kernel_ll
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">4: cni0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 6e:99:8d:63:e5:4b brd ff:ff:ff:ff:ff:ff
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 10.42.0.1/24 brd 10.42.0.255 scope global cni0
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 fe80::6c99:8dff:fe63:e54b/64 scope link proto kernel_ll
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">18: vethf91807b2@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master cni0 state UP group default
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 6a:dd:6f:b9:29:8a brd ff:ff:ff:ff:ff:ff link-netns cni-dba4ed62-c7d7-98fa-0efb-ffa6a8e526a3
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 fe80::68dd:6fff:feb9:298a/64 scope link proto kernel_ll
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">19: veth37d38de3@if3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether ee:29:cc:72:e0:a5 brd ff:ff:ff:ff:ff:ff link-netns cni-dba4ed62-c7d7-98fa-0efb-ffa6a8e526a3
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 192.168.1.1/32 scope global veth37d38de3
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 fe80::ec29:ccff:fe72:e0a5/64 scope link proto kernel_ll
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span></code></pre></div><p>显然这个样例 P2P CNI 只能通过 Veth Pair 访问当前节点的 Pod，无法跨节点访问运行在别的节点的 Pod。</p>
<h3 id="手动执行-cni-check-命令">手动执行 CNI CHECK 命令</h3>
<p>到这里其实你可以魔改一下上面介绍的 P2P 样例 CNI 插件，打一些日志输出到某个文件中，看一下 <code>netlink</code> 执行的结果以及 CNI 执行时传递的参数之类的……</p>
<p>在 Pod 创建时会执行 ADD 命令，删除时会执行 DEL 命令，但如果想调试 CHECK 命令，可以手动为 CNI 传递相应参数执行 CHECK 命令。</p>
<p>首先准备一份包含 <code>prevResult</code> 的 CNI Config，参照下方的 Config 修改 <code>prevResult</code> 字段。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;cniVersion&#34;</span><span class="p">:</span> <span class="s2">&#34;1.0.0&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ptp-conf&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;ptp&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;ipam&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;host-local&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;subnet&#34;</span><span class="p">:</span> <span class="s2">&#34;192.168.1.0/24&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;dns&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;nameservers&#34;</span><span class="p">:</span> <span class="p">[</span> <span class="s2">&#34;192.168.1.0&#34;</span><span class="p">,</span> <span class="s2">&#34;8.8.8.8&#34;</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;prevResult&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;cniVersion&#34;</span><span class="p">:</span> <span class="s2">&#34;1.0.0&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;ptp&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;interfaces&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&#34;mac&#34;</span><span class="p">:</span> <span class="s2">&#34;6a:0b:7d:4b:6f:c5&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;net1&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&#34;sandbox&#34;</span><span class="p">:</span> <span class="s2">&#34;/var/run/netns/cni-dba4ed62-c7d7-98fa-0efb-ffa6a8e526a3&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">],</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;ips&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&#34;address&#34;</span><span class="p">:</span> <span class="s2">&#34;192.168.1.2/24&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&#34;interface&#34;</span><span class="p">:</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">],</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;ipam&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;host-local&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;subnet&#34;</span><span class="p">:</span> <span class="s2">&#34;192.168.1.0/24&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;dns&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;nameservers&#34;</span><span class="p">:</span> <span class="p">[</span> <span class="s2">&#34;192.168.1.0&#34;</span><span class="p">,</span> <span class="s2">&#34;8.8.8.8&#34;</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>设置 CNI 环境变量，传递 CHECK 命令需要的参数。如果实在不清楚 NETNS 和 CONTAINERID 的话，可以魔改 ADD 和 DEL 命令的代码，把参数打印到某个日志文件中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">CNI_PATH</span><span class="o">=</span><span class="s2">&#34;/var/lib/rancher/k3s/data/current/bin&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$CNI_PATH</span>:<span class="nv">$PATH</span>
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">CNI_CONTAINERID</span><span class="o">=</span><span class="s2">&#34;f19d5f601d6227bdf0cb28b43862632e98ecd23cd44d08e8ba1b2d8f27c9639c&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">CNI_NETNS</span><span class="o">=</span><span class="s2">&#34;/var/run/netns/cni-dba4ed62-c7d7-98fa-0efb-ffa6a8e526a3&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">CNI_IFNAME</span><span class="o">=</span>net1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">CNI_COMMAND</span><span class="o">=</span>CHECK
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/var/lib/rancher/k3s/data/current/bin/ptp &lt; p2p.json
</span></span></code></pre></div><p>如果验证错误，会返回一串包含错误信息的 JSON：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;code&#34;</span><span class="p">:</span> <span class="mi">999</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;msg&#34;</span><span class="p">:</span> <span class="s2">&#34;host-local: Failed to find address added by container caf3bc30ca71c847b84741b48a188456277867b404c409628ed33dc7aeb7d1a8&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果 CHECK 运行成功，CNI 程序的返回值将为 0，没有文字输出。</p>
<p>同理，你可以手动创建一个 Network Namespace 模拟容器网络，编辑上方相应的参数执行 CNI Binary 为这个 NS 创建/删除 Veth Pair。</p>
<h2 id="others">Others</h2>
<p>前几天生病了所以咕了好几天，感觉一篇博客把 CNI 和它的好朋友们全讲完不太现实，而且篇幅会变得巨长。所以到这里你已经清楚了 CNI 是个什么东西并具备手搓一个简单的 CNI 网络插件的能力了，至于上面提到的 *VLAN 以及那些目前成熟的网络插件们（Calico、Flannel、Cilium 等）感兴趣的话可以自行去折腾了，Kubernetes 集群上使用的成熟的 CNI 插件可不单要实现上面样例的 P2P 插件简单的功能，后面咱如果有时间的话打算再开一篇博客写这些东西了。</p>]]></content:encoded>
    </item>
    <item>
      <title>Leader Election 折腾小记</title>
      <link>https://blog.starry-s.moe/posts/2024/leader-election/</link>
      <pubDate>Wed, 12 Jun 2024 23:58:26 +0800</pubDate>
      <guid>https://blog.starry-s.moe/posts/2024/leader-election/</guid>
      <description>&lt;p&gt;最近好忙，有很多想写博客的东西都没时间写，五一去了佛山的 HiFurry，本来想着整理点照片水一篇博客但没时间也没精力，所以最后想写的东西就都咽肚里就饭吃了。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>最近好忙，有很多想写博客的东西都没时间写，五一去了佛山的 HiFurry，本来想着整理点照片水一篇博客但没时间也没精力，所以最后想写的东西就都咽肚里就饭吃了。</p>
<meting-js server="netease" type="song" id="2055270589" theme="#233333"></meting-js>
<hr>
<p>最近在折腾 Operator，就是用现成的框架写的 Controller。Operator 省去了重复且繁琐的使用 client-go 手搓 ClientSet、Informer、Lister、WorkQueue 等一大堆重复代码的步骤，只要基于已有的框架去写资源对象更新/删除时的业务处理逻辑就行了。</p>
<h2 id="leader-election-是什么">Leader Election 是什么</h2>
<p>当负载在 Kubernetes 运行时，通常会设置多个 Replicas 冗余副本，以实现高可用（HA），例如通常会将某些系统组件的 Replicas 设置为 2，就会创建两个对应的 Pods，通常这俩 Pod 会被调度到不同的节点上，在某个 Pod 挂掉时还能用另一个节点的 Pod。</p>
<p>Leader Election 机制是由“领导人选举机制”抽象而来的，可以理解为在多个“候选者”中选取某一个作为 Leader。这里的候选者指的是负载创建的多个冗余 Pod，Leader Election 机制从中选取某一个 Pod 作为 Leader，其他 Pod 则处于“待命”状态，如果 Leader Pod 出现故障，则会重新选举一个 Leader Pod。</p>
<p>Kubernetes 使用 Lease 资源（译作：租约）作为 Leader Election 的锁。和常用的 Mutex 互斥锁不同，Lease 资源会被 Leader Pod 每隔几秒钟更新一次。如果长达一段时间 Lease 没有被更新，则说明 Leader 挂掉了，其他 Pods 会竞争，尝试更新这个 Lease 锁，而成功更新了 Lease 的 Pod 会成为新的 Leader，其余 Pod 则继续处于待命状态。</p>
<p>大多数情况下，当某个资源发生更新时，我们不希望所有的冗余副本 Pod 都去处理某一个资源的更新，而是让某一个 Pod 去处理就可以了，不然会混乱（比如刷 Conflict 报错: <code>the object has been modified; please apply your changes to the latest version and try again</code>）。这时可以用到 Leader Election 机制，从多个冗余 Pod 中只选其中某一个 Pod 作为 Leader 处理资源更新，其余 Pod 只作为待命或其他用途。</p>
<p>如果你的 Controller 没有 Leader Election 机制，通常只能强行设定其 Replicas 为 1，但如果有小聪明修改了冗余数值为 2，则会出现一些问题，日志会刷大量的 Conflict 报错之类的，所以更严谨的方式是为 Controller 添加 Leader Election，以允许多 Replicas 冗余。</p>
<h2 id="举个栗子">举个栗子</h2>
<p>client-go 的样例代码中有 <a href="https://github.com/kubernetes/client-go/blob/v0.30.1/examples/leader-election/main.go">Leader Election 例子</a>，所以直接拿这个 Example 做简单的介绍了，把这个 Example 代码拷贝下来在本地跑一下。</p>
<p>首先你需要有一个 Kubernetes 集群用来调试，如果你觉得搭一个集群太麻烦，或者手里没有可供调试使用的集群的话，一个超级简单的方式是使用 <a href="https://k3d.io/">K3d</a> 在你的 Docker Runtime 中跑一个迷你版 K3s 集群。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> k3d cluster create example
</span></span><span class="line"><span class="cl"><span class="go">INFO[0000] Prep: Network
</span></span></span><span class="line"><span class="cl"><span class="go">INFO[0000] Created network &#39;k3d-example&#39;
</span></span></span><span class="line"><span class="cl"><span class="go">......
</span></span></span><span class="line"><span class="cl"><span class="go">INFO[0012] Cluster &#39;example&#39; created successfully!
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> kubectl get nodes -o wide
</span></span><span class="line"><span class="cl"><span class="go">NAME                   STATUS   ROLES                  AGE   VERSION        INTERNAL-IP   EXTERNAL-IP   OS-IMAGE           KERNEL-VERSION   CONTAINER-RUNTIME
</span></span></span><span class="line"><span class="cl"><span class="go">k3d-example-server-0   Ready    control-plane,master   98s   v1.28.8+k3s1   172.19.0.2    &lt;none&gt;        K3s v1.28.8+k3s1   6.9.3-arch1-1    containerd://1.7.11-k3s2
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> docker ps
</span></span><span class="line"><span class="cl"><span class="go">CONTAINER ID   IMAGE                            COMMAND                  CREATED          STATUS              PORTS                           NAMES
</span></span></span><span class="line"><span class="cl"><span class="go">a4c1367c04a2   ghcr.io/k3d-io/k3d-proxy:5.6.3   &#34;/bin/sh -c nginx-pr…&#34;   2 minutes ago    Up About a minute   80/tcp, 0.0.0.0:6443-&gt;6443/tcp  k3d-example-serverlb
</span></span></span><span class="line"><span class="cl"><span class="go">7c95a6ea069b   rancher/k3s:v1.28.8-k3s1         &#34;/bin/k3d-entrypoint…&#34;   2 minutes ago    Up 2 minutes                                        k3d-example-server-0
</span></span></span></code></pre></div><p>按照样例的 <a href="https://github.com/kubernetes/client-go/blob/v0.30.1/examples/leader-election/README.md">README</a>，在 3 个终端中运行 Leader Election 样例代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> go run main.go -kubeconfig<span class="o">=</span>~/.kube/config -logtostderr<span class="o">=</span><span class="nb">true</span> -lease-lock-name<span class="o">=</span>example -lease-lock-namespace<span class="o">=</span>default -id<span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="go">I0612 22:59:20.118613   27504 leaderelection.go:250] attempting to acquire leader lease default/example...
</span></span></span><span class="line"><span class="cl"><span class="go">I0612 22:59:20.124630   27504 leaderelection.go:260] successfully acquired lease default/example
</span></span></span><span class="line"><span class="cl"><span class="go">I0612 22:59:20.124696   27504 main.go:87] Controller loop...
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> go run main.go -kubeconfig<span class="o">=</span>~/.kube/config -logtostderr<span class="o">=</span><span class="nb">true</span> -lease-lock-name<span class="o">=</span>example -lease-lock-namespace<span class="o">=</span>default -id<span class="o">=</span><span class="m">2</span>
</span></span><span class="line"><span class="cl"><span class="go">I0612 22:59:32.692373   27815 leaderelection.go:250] attempting to acquire leader lease default/example...
</span></span></span><span class="line"><span class="cl"><span class="go">I0612 22:59:32.695277   27815 main.go:151] new leader elected: 1
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> go run main.go -kubeconfig<span class="o">=</span>~/.kube/config -logtostderr<span class="o">=</span><span class="nb">true</span> -lease-lock-name<span class="o">=</span>example -lease-lock-namespace<span class="o">=</span>default -id<span class="o">=</span><span class="m">3</span>
</span></span><span class="line"><span class="cl"><span class="go">I0612 22:59:36.424251   28089 leaderelection.go:250] attempting to acquire leader lease default/example...
</span></span></span><span class="line"><span class="cl"><span class="go">I0612 22:59:36.427674   28089 main.go:151] new leader elected: 1
</span></span></span></code></pre></div><p>按顺序在 3 个终端中依次运行样例代码，可以看到 ID 为 1 的程序最先运行所以它成了 Leader，其余两个程序则在待命中。</p>
<p>这时对 ID 1 的程序执行 Ctrl-C，发送 <code>SIGINT</code> 中断信号，让它 Context Canceled，ID 1 程序会释放 Lease 锁并结束运行，其余两个程序中的某一个则会重新竞争，其中一个变成 Leader。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> go run main.go -kubeconfig<span class="o">=</span>~/.kube/config -logtostderr<span class="o">=</span><span class="nb">true</span> -lease-lock-name<span class="o">=</span>example -lease-lock-namespace<span class="o">=</span>default -id<span class="o">=</span><span class="m">3</span>
</span></span><span class="line"><span class="cl"><span class="go">I0612 22:59:36.424251   28089 leaderelection.go:250] attempting to acquire leader lease default/example...
</span></span></span><span class="line"><span class="cl"><span class="go">I0612 22:59:36.427674   28089 main.go:151] new leader elected: 1
</span></span></span><span class="line"><span class="cl"><span class="go">I0612 23:02:56.584777   28089 leaderelection.go:260] successfully acquired lease default/example
</span></span></span><span class="line"><span class="cl"><span class="go">I0612 23:02:56.584866   28089 main.go:87] Controller loop...
</span></span></span></code></pre></div><p>查看样例程序代码，<code>leaderelection.RunOrDie</code> 的参数传递的 Config 定义了 Leader Election 机制的 Callback 回调函数以及租约相关的时间 Duration。</p>
<p><code>Callbacks</code> 回调函数分为：</p>
<ul>
<li><code>OnStartedLeading</code>: 当该程序被选举为 Leader 时，执行此回调函数，通常该回调函数启动 Controller 的 Sync 逻辑等一些操作。</li>
<li><code>OnStoppedLeading</code>: 当该程序不再是 Leader 时（可能是收到了 <code>SIGINT</code> 信号，Context Canceled 或程序出故障，很长一段时间没有去更新 Lease 锁），会执行此回调函数，执行一些资源释放等操作，然后直接 <code>os.Exit</code> 结束程序。</li>
<li><code>OnNewLeader</code>: 当其他某个程序被选举为 Leader 时，会执行此函数，一般没什么用，可以不配置。</li>
</ul>
<p>Config 的其他参数：</p>
<ul>
<li><code>Lock</code>: Lease Lock。</li>
<li><code>ReleaseOnCancel</code>: 当 Context Cancel（当前的 Leader 结束运行）时，释放当前的 Lease 锁，使得其他 Pod 可以立即进行新一轮的选举。如果设置为 false 的话，当前 Leader 挂掉后其他 Pod 并不知道当前 Leader 已经挂掉了，只有过很长一段时间，发现 Lease 锁超过了 <code>LeaseDuration</code> 时间还没被更新，才会去强行的执行新一轮的选举。</li>
<li><code>LeaseDuration</code>: 结合上方的 <code>ReleaseOnCancel</code> 的介绍，假设当前 Leader Pod 出故障了（例如被 <code>SIGKILL</code> 立即杀死，Context 来不及 Cancel，或者调试进入了 Breakpoint 断点，程序暂停），Lease 锁没被释放，但当前 Leader 出问题挂掉了，其他待命的 Pod 发现 Lease 锁已经超过 <code>LeaseDuration</code> 没有被更新，则会强行进行新一轮的选举，而原 Leader 如果还活着的话，也会执行 <code>OnStoppedLeading</code> 回调函数结束运行。</li>
<li><code>RenewDeadline</code>: Leader 每隔一段时间会更新一次 Lease 锁。</li>
<li><code>RetryPeriod</code>: 如果 Leader 更新 Lease 锁失败了，会在一段时间后重试。</li>
</ul>
<p>所以有些小朋友在调试软件时，进入断点再恢复运行时会莫名其妙的结束运行，其实就是 Leader Election 机制搞的。所以如果想调试程序，可以临时把 <code>LeaseDuration</code> 设置长一些（例如好几天），这样调试断点恢复后，程序就不会被杀死了。</p>
<h2 id="杂谈">杂谈</h2>
<p>常用的 Operator 框架都支持 Leader Election，所以基本不用手写 <code>RunOrDie</code> 这部分代码，例如 Rancher 使用的 <a href="https://github.com/rancher/wrangler/">Wrangler</a> 框架，当程序成为 Leader 时，直接执行 <a href="https://github.com/rancher/rancher/blob/v2.9.0-rc1/pkg/wrangler/context.go#L175">OnLeader</a> 回调函数启动一系列业务逻辑。而当程序还没被选为 Leader 时，只初始化 Informer Cache 等初始化步骤，不启动 Sync 相关逻辑。</p>
<p>通常 <code>sample-controller</code> 或其他简单的 Controller 在 Worker Start 执行完之后，会加一个 <code>&lt;-ctx.Done()</code> 阻塞（<a href="https://github.com/kubernetes/sample-controller/blob/master/controller.go#L182">代码位置</a>），遇到 Context Cancel 后直接结束运行。但如果加了 Leader Election 机制，当 Context Cancel 时是由 Leader Election 的 <code>OnStoppedLeading</code> 回调函数结束运行并释放 Lease 锁，所以 <code>main</code> 函数可以改为使用 <code>select {}</code> 阻塞，否则程序在 Context Cancel 时 Lease 锁还没来得及释放就由 <code>main</code> 函数结束运行了。</p>
<p>所以读到这里，可以得出结论，就算设置数量特别多的 Replicas，实际上依旧只有一个 Controller Pod 在执行真正的 Sync 逻辑，而其他 Pod 只是在观望，或者只提供一些 Web Server 功能。如果想让多个冗余 Pod 分别 Sync 不同的资源更新，需要设计一个更复杂的锁，而这又会增加一定的 API Server 请求数量……</p>]]></content:encoded>
    </item>
    <item>
      <title>初探容器网络</title>
      <link>https://blog.starry-s.moe/posts/2024/container-network-1/</link>
      <pubDate>Mon, 26 Feb 2024 19:21:28 +0800</pubDate>
      <guid>https://blog.starry-s.moe/posts/2024/container-network-1/</guid>
      <description>&lt;p&gt;稍微折腾一下容器网络相关的东西……&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>稍微折腾一下容器网络相关的东西……</p>
<meting-js server="netease" type="song" id="1388992194" theme="#233333"></meting-js>
<h2 id="linux-网络命名空间">Linux 网络命名空间</h2>
<p>在熟悉容器网络之前，首先来看一下 Linux 网络命名空间 (Network Namespace) 这个东西。Linux 提供了多个不同种类的 Namespace，可以用 <code>lsns</code> 命令查看。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> lsns
</span></span><span class="line"><span class="cl"><span class="go">        NS TYPE   NPROCS   PID USER     COMMAND
</span></span></span><span class="line"><span class="cl"><span class="go">4026531834 time        2  2251 starry-s -zsh
</span></span></span><span class="line"><span class="cl"><span class="go">4026531835 cgroup      2  2251 starry-s -zsh
</span></span></span><span class="line"><span class="cl"><span class="go">4026531836 pid         2  2251 starry-s -zsh
</span></span></span><span class="line"><span class="cl"><span class="go">4026531837 user        2  2251 starry-s -zsh
</span></span></span><span class="line"><span class="cl"><span class="go">4026531838 uts         2  2251 starry-s -zsh
</span></span></span><span class="line"><span class="cl"><span class="go">4026531839 ipc         2  2251 starry-s -zsh
</span></span></span><span class="line"><span class="cl"><span class="go">4026531840 net         2  2251 starry-s -zsh
</span></span></span><span class="line"><span class="cl"><span class="go">4026531841 mnt         2  2251 starry-s -zsh
</span></span></span><span class="line"><span class="cl"><span class="go">...
</span></span></span></code></pre></div><p>参考 <a href="https://man7.org/linux/man-pages/man7/network_namespaces.7.html">network_namespace manpage</a>，Network Namespace 是 Linux 实现网络资源隔离的功能，不同的 Network Namespace 拥有不同的网卡、ARP、路由表等数据。可以使用 <code>iproute2</code> 工具的 <code>ip</code> 命令对 Linux Network Namespace 执行一系列的操作。</p>
<blockquote>
<p>本篇介绍的指令不会系统产生损坏，但建议在虚拟机或一个用于测试的系统上执行 Network Namespace 相关操作，以便于执行重启等暴力操作。</p>
</blockquote>
<p>开始之前，先安装 <code>net-tools</code> 网络工具包。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo pacman -S net-tools
</span></span></code></pre></div><p>查看设备中已有的 Network Namespace。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> ip netns list
</span></span><span class="line"><span class="cl"><span class="gp">$</span> ip netns ls
</span></span></code></pre></div><p><code>ip netns</code> 命令会列出 <code>/var/run/netns/</code> 目录下存在的 Network Namespace，如果之前没有使用 <code>ip</code> 命令创建过 netns，以上命令基本不会有输出（除非有别的工具也修改了这个目录）。首先创建两个 Network Namespace。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip netns add ns0
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip netns add ns1
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip netns ls
</span></span><span class="line"><span class="cl"><span class="go">ns0
</span></span></span><span class="line"><span class="cl"><span class="go">ns1
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> ls /var/run/netns/
</span></span><span class="line"><span class="cl"><span class="go">ns0 ns1
</span></span></span></code></pre></div><p>每个 Network Namespace 拥有不同的网卡、路由表、ARP 表等信息，可以使用 <code>ip -n [NAMESPACE]</code> 对某个 netns 进行操作，或通过 <code>ip netns exec</code> 在不同的 netns 下执行命令。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns0 link
</span></span><span class="line"><span class="cl"><span class="go">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> sudo ip netns <span class="nb">exec</span> ns0 ip link
</span></span><span class="line"><span class="cl"><span class="go">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> sudo ip netns <span class="nb">exec</span> ns0 route
</span></span><span class="line"><span class="cl"><span class="go">Kernel IP routing table
</span></span></span><span class="line"><span class="cl"><span class="go">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> sudo ip netns <span class="nb">exec</span> ns0 arp
</span></span></code></pre></div><h3 id="veth-pair-连接-network-namespace">veth pair 连接 Network Namespace</h3>
<p>新建的 netns 只有一个 DOWN 状态的回环接口，没有 ARP 和路由表信息，如果想在不同的 netns 之间通信，需要建立 veth pair（Virtual Cabel），把 netns 连接起来。</p>
<p>可以使用 <code>ip link add type veth</code> 创建一对 veth pair，注意 veth pair 是成对出现的，可以在创建 veth pair 时指定这对 veth pair 名称。</p>
<p>首先看一下系统自带的接口信息，默认情况下系统有一个 <code>lo</code> 回环接口和一个 <code>eth0</code> (被重命名为 <code>enp*s*</code> 的接口)，如果运行了 Docker，还会有一个 <code>docker0</code> 接口。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link
</span></span><span class="line"><span class="cl"><span class="go">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span></span><span class="line"><span class="cl"><span class="go">2: enp1s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether ab:cd:ef:89:8f:f5 brd ff:ff:ff:ff:ff:ff
</span></span></span><span class="line"><span class="cl"><span class="go">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default 
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 02:42:b7:a9:6a:55 brd ff:ff:ff:ff:ff:ff
</span></span></span></code></pre></div><p>创建一对 veth pair 名为 <code>veth0</code> 和 <code>veth1</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link add veth0 <span class="nb">type</span> veth peer name veth1
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link
</span></span><span class="line"><span class="cl"><span class="go">......
</span></span></span><span class="line"><span class="cl"><span class="go">4: veth1@veth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 5e:7a:4e:96:b1:df brd ff:ff:ff:ff:ff:ff
</span></span></span><span class="line"><span class="cl"><span class="go">5: veth0@veth1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 5e:5b:51:12:d0:b6 brd ff:ff:ff:ff:ff:ff
</span></span></span></code></pre></div><p>之后使用 <code>ip link set</code> 将这对 veth pair 分配到不同的 netns 中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link <span class="nb">set</span> veth0 netns ns0
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link <span class="nb">set</span> veth1 netns ns1
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns0 link
</span></span><span class="line"><span class="cl"><span class="go">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span></span><span class="line"><span class="cl"><span class="go">5: veth0@if4: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 5e:5b:51:12:d0:b6 brd ff:ff:ff:ff:ff:ff link-netns ns1
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> sudo ip -n ns1 link
</span></span><span class="line"><span class="cl"><span class="go">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span></span><span class="line"><span class="cl"><span class="go">4: veth1@if5: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 5e:7a:4e:96:b1:df brd ff:ff:ff:ff:ff:ff link-netns ns0
</span></span></span></code></pre></div><p>使用 <code>ip addr add</code> 为 veth pair 接口创建 IP 地址，并使用 <code>ip link set [INTERFACE] up</code> 启动网卡接口。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns0 addr add 10.0.0.100/24 dev veth0
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns1 addr add 10.0.0.101/24 dev veth1
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns0 link <span class="nb">set</span> veth0 up
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns1 link <span class="nb">set</span> veth1 up
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns0 addr
</span></span><span class="line"><span class="cl"><span class="go">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span></span><span class="line"><span class="cl"><span class="go">5: veth0@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 5e:5b:51:12:d0:b6 brd ff:ff:ff:ff:ff:ff link-netns ns1
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 10.0.0.100/24 scope global veth0
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 fe80::5c5b:51ff:fe12:d0b6/64 scope link proto kernel_ll 
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> sudo ip -n ns1 addr
</span></span><span class="line"><span class="cl"><span class="go">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span></span><span class="line"><span class="cl"><span class="go">4: veth1@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 5e:7a:4e:96:b1:df brd ff:ff:ff:ff:ff:ff link-netns ns0
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 10.0.0.101/24 scope global veth1
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 fe80::5c7a:4eff:fe96:b1df/64 scope link proto kernel_ll 
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span></code></pre></div><p><code>ip addr add</code> 命令在添加 IP 地址时会自动创建路由表信息。现在两个 netns 之间可通过 veth pair 互相通信。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns0 route
</span></span><span class="line"><span class="cl"><span class="go">10.0.0.0/24 dev veth0 proto kernel scope link src 10.0.0.100 
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> sudo ip -n ns1 route
</span></span><span class="line"><span class="cl"><span class="go">10.0.0.0/24 dev veth1 proto kernel scope link src 10.0.0.101 
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> sudo ip netns <span class="nb">exec</span> ns0 ping -c <span class="m">1</span> 10.0.0.101
</span></span><span class="line"><span class="cl"><span class="go">PING 10.0.0.101 (10.0.0.101) 56(84) bytes of data.
</span></span></span><span class="line"><span class="cl"><span class="go">64 bytes from 10.0.0.101: icmp_seq=1 ttl=64 time=0.051 ms
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">--- 10.0.0.101 ping statistics ---
</span></span></span><span class="line"><span class="cl"><span class="go">1 packets transmitted, 1 received, 0% packet loss, time 0ms
</span></span></span><span class="line"><span class="cl"><span class="go">rtt min/avg/max/mdev = 0.051/0.051/0.051/0.000 ms
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> sudo ip netns <span class="nb">exec</span> ns1 ping -c <span class="m">1</span> 10.0.0.100
</span></span><span class="line"><span class="cl"><span class="go">PING 10.0.0.100 (10.0.0.100) 56(84) bytes of data.
</span></span></span><span class="line"><span class="cl"><span class="go">64 bytes from 10.0.0.100: icmp_seq=1 ttl=64 time=0.040 ms
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">--- 10.0.0.100 ping statistics ---
</span></span></span><span class="line"><span class="cl"><span class="go">1 packets transmitted, 1 received, 0% packet loss, time 0ms
</span></span></span><span class="line"><span class="cl"><span class="go">rtt min/avg/max/mdev = 0.040/0.040/0.040/0.000 ms
</span></span></span></code></pre></div><p>到这里，<code>ns0</code> 和 <code>ns1</code> 两个 Network Namespace 之间的拓扑图如下。</p>
<p><img loading="lazy" src="images/veth.webp" alt="" />

</p>
<h3 id="使用-bridge-连接多个-network-namespace">使用 bridge 连接多个 Network Namespace</h3>
<p>veth pair 只能用于两个 netns 之间的通信，如果需要多个 netns 访问到同一个网络中，需要配置桥接网络。</p>
<p>重启系统（清理掉之前创建的 netns 和 veth pair），之后重新建立 <code>ns0</code>, <code>ns1</code> 和 <code>ns2</code> 三个 Network Namespace。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip netns add ns0
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip netns add ns1
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip netns add ns2
</span></span></code></pre></div><p>使用 <code>ip link add</code> 创建一个桥接接口，并建立三对 veth pair，用于连接 <code>br0</code> 和上述三个 netns。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link add br0 <span class="nb">type</span> bridge
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link add veth0-br <span class="nb">type</span> veth peer name veth0
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link add veth1-br <span class="nb">type</span> veth peer name veth1
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link add veth2-br <span class="nb">type</span> veth peer name veth2
</span></span><span class="line"><span class="cl"><span class="gp">$</span> ip link
</span></span><span class="line"><span class="cl"><span class="go">...
</span></span></span><span class="line"><span class="cl"><span class="go">4: br0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether be:60:00:25:c5:37 brd ff:ff:ff:ff:ff:ff
</span></span></span><span class="line"><span class="cl"><span class="go">5: veth0@veth0-br: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 5e:5b:51:12:d0:b6 brd ff:ff:ff:ff:ff:ff
</span></span></span><span class="line"><span class="cl"><span class="go">6: veth0-br@veth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 72:01:3d:42:16:8c brd ff:ff:ff:ff:ff:ff
</span></span></span><span class="line"><span class="cl"><span class="go">7: veth1@veth1-br: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 5e:7a:4e:96:b1:df brd ff:ff:ff:ff:ff:ff
</span></span></span><span class="line"><span class="cl"><span class="go">8: veth1-br@veth1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 1e:13:96:f1:b6:9d brd ff:ff:ff:ff:ff:ff
</span></span></span><span class="line"><span class="cl"><span class="go">9: veth2@veth2-br: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 62:13:73:b6:5d:f9 brd ff:ff:ff:ff:ff:ff
</span></span></span><span class="line"><span class="cl"><span class="go">10: veth2-br@veth2: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether f2:e6:df:92:de:71 brd ff:ff:ff:ff:ff:ff
</span></span></span></code></pre></div><p>把 <code>veth0</code>, <code>veth1</code>, <code>veth2</code> 分别放到 <code>ns0</code>, <code>ns1</code> 和 <code>ns2</code> 三个 Network Namespace 中，并将他们重命名为 <code>eth0</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link <span class="nb">set</span> dev veth0 netns ns0
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link <span class="nb">set</span> dev veth1 netns ns1
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link <span class="nb">set</span> dev veth2 netns ns2
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns0 link <span class="nb">set</span> dev veth0 name eth0
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns1 link <span class="nb">set</span> dev veth1 name eth0
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns2 link <span class="nb">set</span> dev veth2 name eth0
</span></span></code></pre></div><p>并把 <code>veth0-br</code>, <code>veth1-br</code>, <code>veth2-br</code> 分别连接到 <code>br0</code> 桥接网卡中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link <span class="nb">set</span> dev veth0-br master br0
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link <span class="nb">set</span> dev veth1-br master br0
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link <span class="nb">set</span> dev veth2-br master br0
</span></span></code></pre></div><p>启用所有的网卡接口（为了能 ping 通每个 netns 的 <code>127.0.0.1</code>，将每个 ns 的 <code>lo</code> 回环接口也启动）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link <span class="nb">set</span> dev br0 up
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link <span class="nb">set</span> veth0-br up
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link <span class="nb">set</span> veth1-br up
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link <span class="nb">set</span> veth2-br up
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns0 link <span class="nb">set</span> eth0 up
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns1 link <span class="nb">set</span> eth0 up
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns2 link <span class="nb">set</span> eth0 up
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns0 link <span class="nb">set</span> lo up
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns1 link <span class="nb">set</span> lo up
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns2 link <span class="nb">set</span> lo up
</span></span></code></pre></div><p>为 <code>br0</code> 和 netns 中的 veth 接口 （<code>eth0</code>）添加 IP 地址。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip addr add 10.1.1.1/24 dev br0
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns0 addr add 10.1.1.10/24 dev eth0
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns1 addr add 10.1.1.11/24 dev eth0
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns2 addr add 10.1.1.12/24 dev eth0
</span></span></code></pre></div><p>查看一下 <code>br0</code> 和 netns 中的 <code>eth0</code> 接口的 IP 地址。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> ip a
</span></span><span class="line"><span class="cl"><span class="go">...
</span></span></span><span class="line"><span class="cl"><span class="go">4: br0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether be:60:00:25:c5:37 brd ff:ff:ff:ff:ff:ff
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 10.0.0.1/24 scope global br0
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">6: veth0-br@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br0 state UP group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 72:01:3d:42:16:8c brd ff:ff:ff:ff:ff:ff link-netns ns0
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 fe80::7001:3dff:fe42:168c/64 scope link proto kernel_ll 
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">8: veth1-br@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br0 state UP group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 1e:13:96:f1:b6:9d brd ff:ff:ff:ff:ff:ff link-netns ns1
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 fe80::1c13:96ff:fef1:b69d/64 scope link proto kernel_ll 
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">10: veth2-br@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br0 state UP group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether f2:e6:df:92:de:71 brd ff:ff:ff:ff:ff:ff link-netns ns2
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 fe80::f0e6:dfff:fe92:de71/64 scope link proto kernel_ll 
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> sudo ip -n ns0 a
</span></span><span class="line"><span class="cl"><span class="go">5: eth0@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 5e:5b:51:12:d0:b6 brd ff:ff:ff:ff:ff:ff link-netnsid 0
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 10.1.1.10/24 scope global eth0
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 fe80::5c5b:51ff:fe12:d0b6/64 scope link proto kernel_ll 
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> sudo ip -n ns1 a
</span></span><span class="line"><span class="cl"><span class="go">7: eth0@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 5e:7a:4e:96:b1:df brd ff:ff:ff:ff:ff:ff link-netnsid 0
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 10.1.1.11/24 scope global eth0
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 fe80::5c7a:4eff:fe96:b1df/64 scope link proto kernel_ll 
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> sudo ip -n ns2 a
</span></span><span class="line"><span class="cl"><span class="go">9: eth0@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 62:13:73:b6:5d:f9 brd ff:ff:ff:ff:ff:ff link-netnsid 0
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 10.1.1.12/24 scope global eth0
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">    inet6 fe80::6013:73ff:feb6:5df9/64 scope link proto kernel_ll 
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span></code></pre></div><p>此时在主机上可以 ping 通三个 netns 的 IP 地址。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> ping -c <span class="m">1</span> 10.1.1.10
</span></span><span class="line"><span class="cl"><span class="go">PING 10.1.1.10 (10.1.1.10) 56(84) bytes of data.
</span></span></span><span class="line"><span class="cl"><span class="go">64 bytes from 10.1.1.10: icmp_seq=1 ttl=64 time=0.130 ms
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> ping -c <span class="m">1</span> 10.1.1.11
</span></span><span class="line"><span class="cl"><span class="go">PING 10.1.1.11 (10.1.1.11) 56(84) bytes of data.
</span></span></span><span class="line"><span class="cl"><span class="go">64 bytes from 10.1.1.11: icmp_seq=1 ttl=64 time=0.117 ms
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> ping -c <span class="m">1</span> 10.1.1.12
</span></span><span class="line"><span class="cl"><span class="go">PING 10.1.1.12 (10.1.1.12) 56(84) bytes of data.
</span></span></span><span class="line"><span class="cl"><span class="go">64 bytes from 10.1.1.12: icmp_seq=1 ttl=64 time=0.119 ms
</span></span></span></code></pre></div><p>三个 netns 也可以访问主机的 IP 地址 <code>10.1.1.1</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip netns <span class="nb">exec</span> ns0 ping -c <span class="m">1</span> 10.1.1.1
</span></span><span class="line"><span class="cl"><span class="go">PING 10.1.1.1 (10.1.1.1) 56(84) bytes of data.
</span></span></span><span class="line"><span class="cl"><span class="go">64 bytes from 10.1.1.1: icmp_seq=1 ttl=64 time=0.076 ms
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> sudo ip netns <span class="nb">exec</span> ns1 ping -c <span class="m">1</span> 10.1.1.1
</span></span><span class="line"><span class="cl"><span class="go">PING 10.1.1.1 (10.1.1.1) 56(84) bytes of data.
</span></span></span><span class="line"><span class="cl"><span class="go">64 bytes from 10.1.1.1: icmp_seq=1 ttl=64 time=0.071 ms
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> sudo ip netns <span class="nb">exec</span> ns2 ping -c <span class="m">1</span> 10.1.1.1
</span></span><span class="line"><span class="cl"><span class="go">PING 10.1.1.1 (10.1.1.1) 56(84) bytes of data.
</span></span></span><span class="line"><span class="cl"><span class="go">64 bytes from 10.1.1.1: icmp_seq=1 ttl=64 time=0.072 ms
</span></span></span></code></pre></div><p>默认情况下 Linux 会把 bridge 的二层转发（交换机）功能禁用掉，因此不同的 netns 之间仍无法互相访问。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip netns <span class="nb">exec</span> ns0 ping -c <span class="m">1</span> -W <span class="m">5</span> 10.1.1.11
</span></span><span class="line"><span class="cl"><span class="go">PING 10.1.1.11 (10.1.1.11) 56(84) bytes of data.
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">--- 10.1.1.11 ping statistics ---
</span></span></span><span class="line"><span class="cl"><span class="go">1 packets transmitted, 0 received, 100% packet loss, time 0ms
</span></span></span></code></pre></div><p>使用 IP 桌子，激活桥接接口的转发功能。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo iptables -A FORWARD -i br0 -j ACCEPT
</span></span></code></pre></div><p>此时不同的 netns 之间可以互相 ping 通了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip netns <span class="nb">exec</span> ns0 ping 10.1.1.12
</span></span><span class="line"><span class="cl"><span class="go">PING 10.1.1.12 (10.1.1.12) 56(84) bytes of data.
</span></span></span><span class="line"><span class="cl"><span class="go">64 bytes from 10.1.1.12: icmp_seq=1 ttl=64 time=0.148 ms
</span></span></span></code></pre></div><p>到这里有关 Linux Network Namespace 的配置就可以完美的告一段落了，咱创建了三个 netns，它们之间可以通过 <code>10.1.1.0/24</code> 这一个网段通过 bridge 桥接网卡和 veth pair 实现互相二层（交换机）访问，此时的网络拓扑图变成了下面这样子。</p>
<p><img loading="lazy" src="images/veth-bridge.webp" alt="" />

</p>
<hr>
<p>如果想要更进一步，要实现 netns 内访问其他网段的 IP 地址，还需要再做一些配置，让主机实现网关功能，并配置 NAT，让主机实现 3 层地址转发（路由器）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip netns <span class="nb">exec</span> ns0 ping -c <span class="m">1</span> 8.8.8.8
</span></span><span class="line"><span class="cl"><span class="go">ping: connect: Network is unreachable
</span></span></span></code></pre></div><p>首先需要将主机的网卡（咱这里为 <code>enp1s0</code>，不同系统可能不一样）也添加到将桥接网卡 <code>br0</code> 中，这里要注意把主机的网卡 <code>enp1s0</code> 添加到桥接网卡 <code>br0</code> 后，要把 <code>enp1s0</code> 网卡上的 IP 地址（咱这里为 <code>192.168.122.101/24</code>）改到桥接网卡 <code>br0</code> 上，不然过一段时间后会网络中断。</p>
<blockquote>
<p>这里<strong>不要</strong> ssh 远程操作。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link <span class="nb">set</span> enp1s0 master br0
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip addr del 192.168.122.101/24 dev enp1s0
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip addr add 192.168.122.101/24 dev br0
</span></span></code></pre></div><p>手动为 netns 设定默认网关 <code>10.1.1.1/24</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns0 route add default via 10.1.1.1
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns1 route add default via 10.1.1.1
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns2 route add default via 10.1.1.1
</span></span></code></pre></div><p>接下来使用 IP 桌子配置 IP 地址转发，这里的指令和之前配置 Linux 主机做路由器是一样的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo iptables --table nat -A POSTROUTING -s 10.1.1.0/24 -j MASQUERADE
</span></span></code></pre></div><p>查看一下 netns 中的路由表，这时的默认流量会走 <code>10.1.1.1</code> 网关。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns0 route
</span></span><span class="line"><span class="cl"><span class="go">default via 10.1.1.1 dev eth0 
</span></span></span><span class="line"><span class="cl"><span class="go">10.1.1.0/24 dev eth0 proto kernel scope link src 10.1.1.10
</span></span></span></code></pre></div><p>到这里如果不出意外的话，三个 netns 已经具备访问公网的能力了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip netns <span class="nb">exec</span> ns0 ping -c <span class="m">1</span> 8.8.8.8
</span></span><span class="line"><span class="cl"><span class="go">PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.
</span></span></span><span class="line"><span class="cl"><span class="go">64 bytes from 8.8.8.8: icmp_seq=1 ttl=112 time=66.0 ms
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">--- 8.8.8.8 ping statistics ---
</span></span></span><span class="line"><span class="cl"><span class="go">1 packets transmitted, 1 received, 0% packet loss, time 0ms
</span></span></span><span class="line"><span class="cl"><span class="go">rtt min/avg/max/mdev = 65.964/65.964/65.964/0.000 ms
</span></span></span></code></pre></div><h2 id="容器网络">容器网络</h2>
<p>其实上面咱演示的使用 bridge 桥接网卡 + veth pair 配置多个 Network Namespace 互相访问的这个网络模型基本上就和 Docker 默认的 <code>bridge</code> 网络模型没啥区别了。</p>
<p>只是 Docker 使用 <a href="https://github.com/opencontainers/runc/tree/main/libcontainer">runc/libcontainer</a> 没有把容器对应的 Network Namespace 文件放到 <code>/var/run/netns/</code> 目录，使用 <code>ip netns</code> 命令发现不到它。不过带胶布，可以把 Docker 容器中应用的 Network Namespace 对应文件软链接到 <code>/var/run/netns/</code> 目录中，再使用 <code>ip</code> 命令执行一些操作。</p>
<p>首先跑一个 <code>nginx</code> 容器，使用 <code>docker inspect</code> 获取进程的 PID。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> docker run -dit --name nginx -p 80:80 nginx
</span></span><span class="line"><span class="cl"><span class="gp">$</span> docker inspect --format <span class="s1">&#39;{{.State.Pid}}&#39;</span> nginx
</span></span><span class="line"><span class="cl"><span class="go">993
</span></span></span></code></pre></div><p>创建软链接，将进程的 netns 文件链接到 <code>/var/run/netns</code> 目录。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo mkdir -p /var/run/netns
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ln -s /proc/993/ns/net /var/run/netns/ns-993
</span></span><span class="line"><span class="cl"><span class="gp">$</span> ip netns
</span></span><span class="line"><span class="cl"><span class="go">ns-993
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> sudo ip netns <span class="nb">exec</span> ns-993 ip addr
</span></span><span class="line"><span class="cl"><span class="go">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 127.0.0.1/8 scope host lo
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">4: eth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default 
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span></code></pre></div><p>之后可以像上面那样，再建立一对 veth pair，为容器创建 “第二个网卡” <code>eth1</code>，实现主机和容器之间的访问。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link add eth0-ns-993 <span class="nb">type</span> veth peer name veth-ns-993
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link <span class="nb">set</span> eth0-ns-993 netns ns-993
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns-993 link <span class="nb">set</span> dev eth0-ns-993 name eth1
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns-993 addr
</span></span><span class="line"><span class="cl"><span class="go">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 127.0.0.1/8 scope host lo
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">4: eth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default 
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
</span></span></span><span class="line"><span class="cl"><span class="go">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
</span></span></span><span class="line"><span class="cl"><span class="go">       valid_lft forever preferred_lft forever
</span></span></span><span class="line"><span class="cl"><span class="go">9: eth1@if8: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 36:57:fa:63:3b:f0 brd ff:ff:ff:ff:ff:ff link-netnsid 0
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> sudo ip addr add 10.1.0.1/24 dev veth-ns-993
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns-993 addr add 10.1.0.2/24 dev eth1
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip link <span class="nb">set</span> dev veth-ns-993 up
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo ip -n ns-993 link <span class="nb">set</span> dev eth1 up
</span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> ping 10.1.0.2
</span></span><span class="line"><span class="cl"><span class="go">PING 10.1.0.2 (10.1.0.2) 56(84) bytes of data.
</span></span></span><span class="line"><span class="cl"><span class="go">64 bytes from 10.1.0.2: icmp_seq=1 ttl=64 time=0.040 ms
</span></span></span><span class="line"><span class="cl"><span class="go">...
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> curl 10.1.0.2
</span></span><span class="line"><span class="cl"><span class="go">&lt;!DOCTYPE html&gt;
</span></span></span><span class="line"><span class="cl"><span class="go">&lt;html&gt;
</span></span></span><span class="line"><span class="cl"><span class="go">&lt;head&gt;
</span></span></span><span class="line"><span class="cl"><span class="go">&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</span></span></span><span class="line"><span class="cl"><span class="go">...
</span></span></span></code></pre></div><p>看吧，就是这么的简单（确信）。</p>
<p>所以在运行了 Docker 的主机上执行 <code>ip</code> 命令有时能看到一大堆 <code>veth</code> 开头的网卡设备名，到这里我们就能明白这些实际上是 veth pair，一端连接到了 <code>docker0</code> 桥接网卡上，另一端则连接在 Docker 容器的 Network Namespace 中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> ip l
</span></span><span class="line"><span class="cl"><span class="go">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default 
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 02:42:48:1b:aa:e0 brd ff:ff:ff:ff:ff:ff
</span></span></span><span class="line"><span class="cl"><span class="go">5: veth077b91e@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default 
</span></span></span><span class="line"><span class="cl"><span class="go">    link/ether 6e:29:0d:fb:d2:43 brd ff:ff:ff:ff:ff:ff link-netnsid 0
</span></span></span></code></pre></div><h2 id="kubernetes-pod">Kubernetes Pod</h2>
<p>众所周知，Kubernetes 的一个 Pod 中可以包含多个容器，这些容器共用一个网络命名空间，不同容器运行的程序可以直接通过 <code>127.0.0.1</code> 回环地址互相访问。这里需要补充一个萌新容易混淆的概念就是，Linux 的 Namespace 和 Kubernetes 的 Namespace 不是一个东西，前者是 Linux 内核 Level 的特性，后者是 Kubernetes API Server Level 的功能，虽然都叫 Namespace 但他俩不是一个东西。</p>
<p>那么 Kubernetes 的 Pod 是如何实现多个容器共用一个 Network Namespace 的呢？之前用过 Kubernetes 的小朋友可能会注意到他们的 Container Runtime 中总能看到名叫 <code>pause</code> 的容器，这又是干什么的呢？</p>
<p>Docker 的网络模型除了默认的 <code>bridge</code> 之外，还有 <code>host</code>, <code>none</code> 和 <code>container</code> 这几种。其中 <code>host</code> 是指和主机共用同一个网络命名空间，<code>none</code> 是容器的 Network Namespace 不配置任何额外的网络。而 <code>container</code> 网络模型则是用来指定一个已有的容器，和他共用同一个 Network Namespace。</p>
<p>Kubernetes 的 Pod 需要让多个容器共用同一个 Network Namespace，所以需要先找一个容器创建 Network Namespace，再让其他容器加入到这个预先创建好的 Network Namespace 中。让 Pod 中任何一个容器作为创建 Network Namespace 的容器都不合适，所以就出来了一个 <code>pause</code> 容器，这个容器体积很小，运行之后其进程永远处于休眠（pause）状态，且 pause 容器的进程 PID 为 1，因为除了创建网络命名空间外，<code>pause</code> 容器还创建了 Linux 进程命名空间，用于回收僵尸进程。</p>
<p>Pause 容器的源码可以在 <a href="https://github.com/kubernetes/kubernetes/blob/master/build/pause/linux/pause.c">这里</a> 找到，可以看到它主要确保自己的 PID 为 1，处理一些 Linux Signal 之外，其余时间一直都在 <code>pause</code>。</p>
<p>可以用 Docker 的 <code>container</code> 网络模型模拟一个 Kubernetes 的 Pod，因为想不出什么太合适的栗子，所以这个 “Pod” 里运行了一个 nginx server 和一个 registry server。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> docker run -d --name pause -p 8080:80 -p 5000:5000 --ipc<span class="o">=</span>shareable rancher/mirrored-pause:3.6
</span></span><span class="line"><span class="cl"><span class="gp">$</span> docker run -d --name nginx --net<span class="o">=</span>container:pause --ipc<span class="o">=</span>container:pause --pid<span class="o">=</span>container:pause nginx
</span></span><span class="line"><span class="cl"><span class="gp">$</span> docker run -d --name registry --net<span class="o">=</span>container:pause --ipc<span class="o">=</span>container:pause --pid<span class="o">=</span>container:pause registry
</span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> docker ps
</span></span><span class="line"><span class="cl"><span class="go">CONTAINER ID   IMAGE                        COMMAND                  CREATED         STATUS         PORTS                                                                              NAMES
</span></span></span><span class="line"><span class="cl"><span class="go">eaace8974956   registry                     &#34;/entrypoint.sh /etc…&#34;   2 minutes ago   Up 2 minutes                                                                                      registry
</span></span></span><span class="line"><span class="cl"><span class="go">247ed1ca07e3   nginx                        &#34;/docker-entrypoint.…&#34;   2 minutes ago   Up 2 minutes                                                                                      nginx
</span></span></span><span class="line"><span class="cl"><span class="go">6cdf835a09f0   rancher/mirrored-pause:3.6   &#34;/pause&#34;                 2 minutes ago   Up 2 minutes   0.0.0.0:5000-&gt;5000/tcp, :::5000-&gt;5000/tcp, 0.0.0.0:8080-&gt;80/tcp, :::8080-&gt;80/tcp   pause
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> curl 127.0.0.1:8080
</span></span><span class="line"><span class="cl"><span class="go">&lt;!DOCTYPE html&gt;
</span></span></span><span class="line"><span class="cl"><span class="go">&lt;html&gt;
</span></span></span><span class="line"><span class="cl"><span class="go">&lt;head&gt;
</span></span></span><span class="line"><span class="cl"><span class="go">&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</span></span></span><span class="line"><span class="cl"><span class="go">...
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> docker login 127.0.0.1:5000
</span></span><span class="line"><span class="cl"><span class="go">Username: admin
</span></span></span><span class="line"><span class="cl"><span class="go">Password: 
</span></span></span><span class="line"><span class="cl"><span class="go">Login Succeeded
</span></span></span></code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>K3s &#43; Multus CNI 插件使用 Macvlan</title>
      <link>https://blog.starry-s.moe/posts/2024/k3s-multus-macvlan/</link>
      <pubDate>Tue, 30 Jan 2024 18:52:00 +0800</pubDate>
      <guid>https://blog.starry-s.moe/posts/2024/k3s-multus-macvlan/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://k3s.io/&#34;&gt;K3s&lt;/a&gt; 是一个轻量的 Kubernetes 集群，&lt;a href=&#34;https://github.com/k8snetworkplumbingwg/multus-cni&#34;&gt;Multus&lt;/a&gt; 是一个用于给 Pod 创建多个网络接口的 CNI (Container Network Interface) 插件，其创建的接口支持 &lt;code&gt;macvlan&lt;/code&gt;。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p><a href="https://k3s.io/">K3s</a> 是一个轻量的 Kubernetes 集群，<a href="https://github.com/k8snetworkplumbingwg/multus-cni">Multus</a> 是一个用于给 Pod 创建多个网络接口的 CNI (Container Network Interface) 插件，其创建的接口支持 <code>macvlan</code>。</p>
<meting-js server="netease" type="song" id="4017232" theme="#233333"></meting-js>
<hr>
<h2 id="啥是-macvlan">啥是 Macvlan</h2>
<p>字面意思，根据 MAC 地址划分的虚拟子网 (Vlan) 就是 macvlan，网上能搜到很多有关 Macvlan 的介绍，这里不再过多描述。</p>
<p>与之相对应的还有一个叫 ipvlan，是通过 IP 地址划分的虚拟子网。</p>
<p>Macvlan 和 ipvlan 都是 Linux 系统的特性，其他系统不支持这个功能。</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>可以用 <code>modinfo macvlan</code> 检查系统是否有安装 <code>macvlan</code> 模块，根据 <a href="https://docs.docker.com/network/network-tutorial-macvlan/#prerequisites">Docker 文档</a> 中描述的建议是使用 Linux 3.9 或 4.0 及更新的内核版本。</p>
<p>可以用以下指令检查系统是否支持 Macvlan（这里使用桥接模式）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">sudo ip link add macvlan0 link enp1s0 <span class="nb">type</span> macvlan mode bridge  <span class="c1"># 这里替换 enp1s0 为网卡接口名称</span>
</span></span><span class="line"><span class="cl">sudo ip address add 192.168.122.205/24 broadcast 192.168.122.255 dev macvlan0 <span class="c1"># 注意 IP 地址冲突</span>
</span></span></code></pre></div><p>之后可尝试使用其他处于同一个网络（CIDR）的设备 ping 这个 <code>192.168.122.205</code> IP 地址，能 Ping 通就说明你的防火墙没有屏蔽不同设备之间的二层数据转发。</p>
<h2 id="安装-k3s">安装 K3s</h2>
<p>根据 <a href="https://github.com/k8snetworkplumbingwg/multus-cni/blob/master/docs/quickstart.md">Multus 的 QuickStart 手册</a>，准备一个新版本的 Kubernetes 集群（这里用的是 <code>v1.27.8+k3s2</code>），K3s 默认的 CNI 插件使用的是 Flannel。</p>
<p>在国内的话需要先创建 <code>/etc/rancher/k3s/registries.yaml</code> 配置 Registry Mirror：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">mirrors</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">docker.io</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">endpoint</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="s2">&#34;https://docker.nju.edu.cn&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ghcr.io</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">endpoint</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="s2">&#34;https://ghcr.nju.edu.cn&#34;</span><span class="w">
</span></span></span></code></pre></div><p>之后使用国内源一键安装 K3s：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">curl -sfL https://rancher-mirror.oss-cn-beijing.aliyuncs.com/k3s/k3s-install.sh <span class="p">|</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	<span class="nv">INSTALL_K3S_VERSION</span><span class="o">=</span>v1.27.8+k3s2 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	<span class="nv">INSTALL_K3S_MIRROR</span><span class="o">=</span>cn <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	sh -s - server <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	--cluster-init <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	--system-default-registry <span class="s2">&#34;docker.nju.edu.cn&#34;</span>
</span></span></code></pre></div><h2 id="安装-multus-cni">安装 Multus CNI</h2>
<p>接下来安装 Multus CNI 插件，下载 <code>multus-daemonset.yml</code> 配置，需要编辑 <code>kube-multus-ds</code> DaemonSet hostPath 的路径到 K3s 对应的路径上去。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">wget <span class="s1">&#39;https://raw.githubusercontent.com/k8snetworkplumbingwg/multus-cni/master/deployments/multus-daemonset.yml&#39;</span>
</span></span></code></pre></div><p>编辑 <code>kube-multus-ds</code> DaemonSet 的 <code>hostPath</code> 的配置为 K3s 的路径。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nn">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">cni</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">hostPath</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/var/lib/rancher/k3s/agent/etc/cni/net.d</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">cnibin</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">hostPath</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/var/lib/rancher/k3s/data/current/bin</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">...</span><span class="w">
</span></span></span></code></pre></div><p>还要编辑 <code>kube-multus-ds</code> DaemonSet 的 Container 配置，增添一条 command arg：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nn">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">kube-multus</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">ghcr.io/k8snetworkplumbingwg/multus-cni:snapshot</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;/thin_entrypoint&#34;</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">args</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="s2">&#34;--multus-conf-file=auto&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="s2">&#34;--multus-autoconfig-dir=/host/etc/cni/net.d&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="s2">&#34;--cni-conf-dir=/host/etc/cni/net.d&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># ADD THIS LINE:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="s2">&#34;--multus-kubeconfig-file-host=/var/lib/rancher/k3s/agent/etc/cni/net.d/multus.d/multus.kubeconfig&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">...</span><span class="w">
</span></span></span></code></pre></div><p>之后 <code>kubectl apply</code> 上面的 Multus Daemonset 配置，等待 <code>kube-multus-ds</code> DaemonSet 跑起来后，可以看到 <code>/var/lib/rancher/k3s/data/current/bin</code> 目录下有新增 <code>multus</code> 可执行文件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> sudo ls /var/lib/rancher/k3s/data/current/bin <span class="p">|</span> grep multus
</span></span><span class="line"><span class="cl"><span class="go">multus
</span></span></span></code></pre></div><h2 id="自定义-multus-cni-配置文件">自定义 Multus CNI 配置文件</h2>
<p>新建一个名为 <code>macvlan-conf</code> 的 <code>NetworkAttachmentDefinition</code> Custom Resource，自定义 multus 配置文件：</p>
<p>这里需要注意 <code>config</code> 中的 <code>master</code> 网卡接口要设置为物理机上对应的网卡接口名。</p>
<p>咱把 K3s Server 安装在了 QEMU 虚拟机中，虚拟机使用的是 libvirt 创建的默认网卡，CIDR 编址为 <code>192.168.122.0/24</code>，网关 <code>192.168.122.1</code>。
为了能在其他虚拟机 / 物理机上也能访问到虚拟机中使用了 macvlan 的 pod，multus macvlan 配置文件也使用 libvirt 网卡的 CIDR。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;k8s.cni.cncf.io/v1&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">NetworkAttachmentDefinition</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">macvlan-conf</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">config</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">      &#34;cniVersion&#34;: &#34;0.3.1&#34;,
</span></span></span><span class="line"><span class="cl"><span class="s1">      &#34;type&#34;: &#34;macvlan&#34;,
</span></span></span><span class="line"><span class="cl"><span class="s1">      &#34;master&#34;: &#34;enp1s0&#34;,
</span></span></span><span class="line"><span class="cl"><span class="s1">      &#34;mode&#34;: &#34;bridge&#34;,
</span></span></span><span class="line"><span class="cl"><span class="s1">      &#34;ipam&#34;: {
</span></span></span><span class="line"><span class="cl"><span class="s1">        &#34;type&#34;: &#34;host-local&#34;,
</span></span></span><span class="line"><span class="cl"><span class="s1">        &#34;subnet&#34;: &#34;192.168.122.0/24&#34;,
</span></span></span><span class="line"><span class="cl"><span class="s1">        &#34;rangeStart&#34;: &#34;192.168.122.200&#34;,
</span></span></span><span class="line"><span class="cl"><span class="s1">        &#34;rangeEnd&#34;: &#34;192.168.122.210&#34;,
</span></span></span><span class="line"><span class="cl"><span class="s1">        &#34;routes&#34;: [
</span></span></span><span class="line"><span class="cl"><span class="s1">          { &#34;dst&#34;: &#34;0.0.0.0/0&#34; }
</span></span></span><span class="line"><span class="cl"><span class="s1">        ],
</span></span></span><span class="line"><span class="cl"><span class="s1">        &#34;gateway&#34;: &#34;192.168.122.1&#34;
</span></span></span><span class="line"><span class="cl"><span class="s1">      }
</span></span></span><span class="line"><span class="cl"><span class="s1">    }&#39;</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> kubectl apply -f macvlan-conf.yaml
</span></span><span class="line"><span class="cl"><span class="gp">$</span> kubectl get net-attach-def
</span></span><span class="line"><span class="cl"><span class="go">NAME           AGE
</span></span></span><span class="line"><span class="cl"><span class="go">macvlan-conf   59s
</span></span></span></code></pre></div><h2 id="创建-macvlan-pod">创建 Macvlan Pod</h2>
<p>K3s 将安装包体积做了精简移除了 <code>macvlan</code> CNI 插件，所以创建 Pod 之前需要手动下载 <code>macvlan</code> CNI 插件放到 K3s 的 data bin 目录。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> mkdir -p cni-plugin <span class="o">&amp;&amp;</span> <span class="nb">cd</span> cni-plugin
</span></span><span class="line"><span class="cl"><span class="gp">$</span> wget https://github.com/containernetworking/plugins/releases/download/v1.4.0/cni-plugins-linux-amd64-v1.4.0.tgz
</span></span><span class="line"><span class="cl"><span class="gp">$</span> tar -zxvf cni-plugins-linux-amd64-v1.4.0.tgz
</span></span><span class="line"><span class="cl"><span class="gp">$</span> sudo cp ./macvlan /var/lib/rancher/k3s/data/current/bin/
</span></span></code></pre></div><p>之后创建 Pod，使用 Annotation 指定网络的配置文件，并让 Pod 被 Multus CNI 识别。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nginx-macvlan</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">annotations</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">k8s.v1.cni.cncf.io/networks</span><span class="p">:</span><span class="w"> </span><span class="l">macvlan-conf</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span></span></span></code></pre></div><p>如果一切顺利的话，<code>kubectl describe pod nginx-macvlan</code> 能看到以下的 Events：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Events:
</span></span><span class="line"><span class="cl">  Type    Reason          Age   From               Message
</span></span><span class="line"><span class="cl">  ----    ------          ----  ----               -------
</span></span><span class="line"><span class="cl">  Normal  Scheduled       2s    default-scheduler  Successfully assigned default/nginx-macvlan to archlinux-k3s-1
</span></span><span class="line"><span class="cl">  Normal  AddedInterface  2s    multus             Add eth0 [10.42.0.26/24] from cbr0
</span></span><span class="line"><span class="cl">  Normal  AddedInterface  2s    multus             Add net1 [192.168.122.200/24] from default/macvlan-conf
</span></span></code></pre></div><p>因为 K3s 服务器跑在了 QEMU KVM 虚拟机里面，libvirt 默认网卡 CIDR 是 <code>192.168.122.0/24</code>。所以咱在物理机上访问虚拟机内的 Macvlan Pod IP <code>192.168.122.200</code>，是能正常访问的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> curl 192.168.122.200
</span></span><span class="line"><span class="cl"><span class="go">&lt;!DOCTYPE html&gt;
</span></span></span><span class="line"><span class="cl"><span class="go">&lt;html&gt;
</span></span></span><span class="line"><span class="cl"><span class="go">&lt;head&gt;
</span></span></span><span class="line"><span class="cl"><span class="go">&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</span></span></span><span class="line"><span class="cl"><span class="go">...
</span></span></span></code></pre></div><p>然后因为 Macvlan 的子接口 (sub interface) 无法与父接口 (parent interface) 直接访问，所以在节点的主机上访问运行在这个节点内的 macvlan pod 是访问不通的，也就是说无法通过节点主机的接口访问到 macvlan pod 的子接口，除非使用 ipvlan，可以参考以下这几篇讨论：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/69316893/single-node-microk8s-multus-master-interface-cannot-be-reached">Single node Microk8s multus master interface cannot be reached</a></li>
<li><a href="https://forums.docker.com/t/host-and-containers-cannot-communicate-macvlan/112968">Host and Containers cannot communicate - MACVLAN</a></li>
</ul>]]></content:encoded>
    </item>
    <item>
      <title>当你刚开始尝试去写 Kubernetes Controller……</title>
      <link>https://blog.starry-s.moe/posts/2023/kube-controller/</link>
      <pubDate>Sat, 10 Jun 2023 02:33:58 +0800</pubDate>
      <guid>https://blog.starry-s.moe/posts/2023/kube-controller/</guid>
      <description>&lt;p&gt;Controller 对初学着来说有那么亿点点抽象，虽然网络上能找到很多有关 Kubernetes Controller 的讲解，但是 Kubernetes 的学习过程往往是一个离散的而不是连续的过程。如果想弄懂 Controller 还是有蛮高门槛的，不要想着看完 Kubernetes 的文档，速成了 Kubernetes 的基本知识就去尝试写 Controller，这种操作就好比刚过完新手教程就去打高难副本，尽管能仿着 &lt;code&gt;sample-controller&lt;/code&gt; 写一个能“跑”的 Controller，但仅仅只能做到能“跑”的程度……&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;与标题有些不同，这篇博客主要讲的是萌新如何上手编写 Controller，如果你是 Kubernetes 初学者，希望这篇博客能帮助你建立编写 Controller 的学习曲线。&lt;/p&gt;
&lt;/blockquote&gt;</description>
      <content:encoded><![CDATA[<p>Controller 对初学着来说有那么亿点点抽象，虽然网络上能找到很多有关 Kubernetes Controller 的讲解，但是 Kubernetes 的学习过程往往是一个离散的而不是连续的过程。如果想弄懂 Controller 还是有蛮高门槛的，不要想着看完 Kubernetes 的文档，速成了 Kubernetes 的基本知识就去尝试写 Controller，这种操作就好比刚过完新手教程就去打高难副本，尽管能仿着 <code>sample-controller</code> 写一个能“跑”的 Controller，但仅仅只能做到能“跑”的程度……</p>
<blockquote>
<p>与标题有些不同，这篇博客主要讲的是萌新如何上手编写 Controller，如果你是 Kubernetes 初学者，希望这篇博客能帮助你建立编写 Controller 的学习曲线。</p>
</blockquote>
<h2 id="前期准备">前期准备</h2>
<p>对刚接触 Kubernetes 的萌新来讲，这个体系还是蛮复杂和抽象的，只靠读文档看教程自学可不是那么容易。光是怎么安装一个 Kubernetes 集群，在不同的教程里就有无数种方法了。传统的安装 Kubernetes 的方法过于硬核，现在几乎没人选择这种方式部署集群了。咱常用的比较简单的方式有 <a href="https://k3s.io">k3s</a>，光靠一个脚本就能在虚拟机上一键部署一个轻量级的集群，很适合萌新（前提是你没有必须用包管理器安装任何软件的强迫症），但是如果你想在国内的网络环境靠这个脚本安装 <code>k3s</code> 的话，需要一些参数配置国内源，这里不再赘述。除此之外还可以<a href="https://ranchermanager.docs.rancher.com/zh/pages-for-subheaders/rancher-on-a-single-node-with-docker">用 Docker 方式部署一个单节点 Rancher</a>，Rancher 的 Web 界面可以更好的帮助萌新去管理 Kubernetes 资源（当然你还可以选择敲 <code>kubectl</code> 指令的方式），还有很多教程会推荐你使用 <code>minikube</code>，当然你可以选择任何一种方式去部署你自己的集群，只要你觉得这种方法适合你，而且部署的集群版本不要太低即可。</p>
<p>如果想编写 Controller，你得有一定的 Kubernetes 基础（废话），并且熟悉 Go 语言（废话 x 2）。在看完 Kubernetes 文档，熟悉了 k8s 的资源和如何使用 <code>kubectl</code> 操作他们后，先别急着上手写 Controller。首先你得熟悉 <a href="https://github.com/kubernetes/client-go">client-go</a>，<code>client-go</code> 的代码能在 GitHub (<a href="https://github.com/kubernetes/client-go">https://github.com/kubernetes/client-go</a>) 中下载到，但记住它的 Go Module 为 <code>k8s.io/client-go</code>，不在 <code>github.com</code>。</p>
<p>首先了解一些常见的 Kuberntes API 类型，知道 Kubernetes 的资源对象是怎么在 <code>client-go</code> 中用 Go 语言表示的，并如何调用 API 去管理他们（而不是仅凭 <code>kubectl</code> 命令行客户端去管理他们），
这里不单单有 <code>client-go</code> 这一个 Git 仓库，还有 <code>k8s.io/api</code>, <code>k8s.io/apimachinery</code> 等仓库，后面写 Controller 时会经常用到这些 API。认识一下 <code>TypeMeta</code> 和 <code>ObjectMeta</code> （代码位置在<a href="https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/types.go">这里</a>），每个资源对象的 Go 结构中都包含这些数据（除此之外每个资源还有 <code>Spec</code>, <code>Status</code> 等），写代码时会经常用到 <code>json/yaml</code> 的 <code>Marshal/Unmarshal</code> 操作，熟悉到这个程度就可以了。</p>
<p>然后是 Kubernetes 的自定义资源（Custom Resource, CR）这个概念，k8s 内置了一些 Resource 资源对象，例如 <code>pod</code>, <code>deployment</code>, <code>service</code>, <code>secret</code> 等，你可以用 <code>kubectl</code> 去 <code>get/describe/create/delete...</code> 这些资源，但如果你想往 k8s 中添加一些你自己的自定义资源，比如你想定义一个资源叫做 <code>database</code>，你用 <code>kubectl create database ...</code> 就能创建一个你自己想要的数据库，像 <code>create pod</code>, <code>create secret</code> 那样，然后还能对你的自定义资源对象进行 <code>describe/delete/update...</code> 等操作，就需要用到自定义资源（开发者更习惯叫他的简写 CR，以及自定义资源定义的简写 CRD）。Controller 就是用来管理这些 CRs 的。在开发 Controller 时我们需要定义 CR 中包含哪些数据，然后使用代码生成器生成资源的 <code>DeepCopy</code> 等方法，减少不必要的重复代码编写。</p>
<blockquote>
<p>可以不用把每个细节都尝试弄懂，把基本概念过一遍就行，学习 Kubernetes 的过程是一个离散的过程而不是连续的过程，当碰到哪个地方不明白卡住的时候直接跳过去看后面的内容就行啦~</p>
</blockquote>
<h2 id="什么是-controller">什么是 Controller</h2>
<p>在上面介绍 CR 的定义时有解释 Controller 是用来管理 CR 的，比如我们执行 <code>kubectl create database ...</code> （实际是执行 <code>kubectl apply -f</code> 部署了一个 <code>Kind</code> 为 <code>database</code> 的 YAML，不能直接 <code>create database</code>，但这么说比较方便理解~）创建了一个 <code>database</code> 类型的资源，因为这个资源是我们自定义的，所以 Kubernetes 只是在 etcd 数据库中记录了：“我们创建了一个 <code>database</code> 资源，他的数据内容是什么什么……”，并没有进行创建数据库的操作！而 Controller 就是用来管理 Database 资源的生命周期的，比如我们 <code>create database</code> 之后，Controller 会发现我们新建了一个 Database 资源，然后会去创建一个 Database Deployment。当我们 <code>delete database</code> 时，Controller 会注意到我们删除了 Database，之后执行资源释放一系列操作。</p>
<p>往简单了讲，Controller 干的事情就是对比资源当前实际的状态和我们设定的资源状态是否一致。比如这个资源定义的 <code>replicas</code> 为 2，但实际只有一个 Pod 在运行，Controller 就会再去创建一个 Pod 使其实际的 <code>replicas</code> 为 2。</p>
<p>当然 Controller 实现起来比这复杂多了，可不是一个简单的 <code>for</code> 循环不断从 Kube API 中查询资源然后做对比这么简单，这用到了 Cache 缓存机制和 Informer 消息提醒机制，减少 Kube API 请求次数，读取内存中的状态缓存什么的，听不懂没关系，以后会懂的……</p>
<h2 id="sample-controller">sample-controller</h2>
<p><code>github.com/kubernetes/sample-controller</code> 项目是一个样例 Controller，所有的初学者都是靠这个项目学习 Controller 的，相当于是高难副本中最简单的了，可以把这个样例 Controller 改造为自己的 Controller，用来学习。</p>
<p>本篇教程以编写 <code>database-controller</code> 为例，按照 <code>sample-controller</code> 的 Controller 框架编写一个数据库的 Controller，重点在于怎么上手写 Controller，不在数据库。</p>
<p>将 <code>sample-controller</code> 代码克隆到本地 <code>$GOPATH</code> 目录下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> midir -p <span class="nv">$GOPATH</span>/src/github.com/&lt;USERNAME&gt;/ <span class="o">&amp;&amp;</span> <span class="nb">cd</span> <span class="nv">$GOPATH</span>/src/github.com/&lt;USERNAME&gt;/
</span></span><span class="line"><span class="cl"><span class="gp">$</span> git clone git@github.com:kubernetes/sample-controller.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> sample-controller
</span></span></code></pre></div><h3 id="初始化-controller">初始化 Controller</h3>
<p>按照 <code>sample-controller</code> 的 Controller 框架，将其修改为我们想要实现的 Controller。</p>
<ul>
<li>修改项目名称为 <code>database-controller</code>，修改 <code>git remote</code>。</li>
<li>编辑 <code>go.mod</code> 修改 Module 名称，把代码的 <code>k8s.io/sample-controller</code> 改为 <code>github.com/&lt;USERNAME&gt;/database-controller</code>。</li>
<li>编辑 <code>hack/boilerplate.go.txt</code> 中的版权信息。</li>
<li>修改 <code>README</code>，<code>OWNERS</code>，<code>SECURITY_CONTACTS</code> 等信息。</li>
<li>编辑执行<strong>代码生成器</strong>的脚本 <a href="https://github.com/kubernetes/sample-controller/blob/master/hack/update-codegen.sh">hack/update-codegen.sh</a>
<ul>
<li>编辑脚本中的代码生成器所在位置，脚本中原本写的是使用了 <code>go mod vendor</code> 将 Go 依赖都放到了项目的 <code>vendor</code> 目录下时生成器的位置，按实际情况进行修改（比如改成 <code>$GOPATH</code> 目录下）。</li>
<li>编辑 <code>code-generator</code> 的参数，把 <code>k8s.io/sample-controller</code> 改成 <code>github.com/&lt;USERNAME&gt;/database-controller</code>, 并编辑 <code>--output-base</code> 的目录位置。</li>
<li>执行代码生成器脚本，确保能正确生成代码。</li>
</ul>
</li>
</ul>
<p>之后修改 <code>pkg/apis/samplecontroller</code> 目录为 <code>pkg/apis/databasecontroller</code>，同时把 <code>samplecontroller</code> 包修改为 <code>databasecontroller</code>。</p>
<ul>
<li>把代码中所有使用了 <code>samplecontroller</code> 包的地方都改为 <code>databasecontroller</code>（被代码生成器生成的代码可以不用改，后面会重新生成代码）。</li>
<li>修改 <code>pkg/apis/databasecontroller/register.go</code> 的 <code>GroupName</code> 为 <code>database.&lt;YOUR_DOMAIN&gt;</code>，例如 <code>database.example.io</code>。</li>
<li>修改代码生成器的注释，把 <code>pkg/apis/databasecontroller/v1alpha1/doc.go</code> 的 <code>groupName</code> 修改为 <code>database.example.io</code>。</li>
<li>重新执行代码生成器 <code>./hack/update-codegen.sh</code>。</li>
</ul>
<p>先简单熟悉一下修改后的项目的代码结构：</p>
<ul>
<li>
<p><code>main.go</code> 中先构建了 Kubernetes 和 <code>database-controller</code> 的 <code>Client</code>，之后基于 <code>Client</code> 构建了 <code>SharedInformer</code>，最后创建并启动 Controller。</p>
<p>简单来讲，<code>Informer</code> 在资源发生改动时，调用相应事件的处理函数，它可以对“增加”，“更新”，“删除”三种事件进行“监控”处理（一点也不简单，太抽象了）。然后 Informer 还充当了缓存的作用，查询资源状态时只需要查询 Informer 的缓存即可，不需要反复调用 Kube API，减少性能损耗。</p>
</li>
<li>
<p><code>controller.go</code> 包含这些内容：</p>
<ul>
<li>构建 Controller 的 <code>NewController</code>、启动 Controller 的 <code>Run</code>，还有 Informer 在不同事件（Event）进行处理的函数……</li>
<li>创建 Deployment 的函数，<code>sample-controller</code> 中的 CRD Kind 为 <code>foo</code>，这个 <code>foo</code> 创建的 Deployment 是一个 <code>nginx</code> Pod，有点抽象，后面要把 <code>foo</code> 改成咱们要实现的 <code>database</code>，原理实际都没变。</li>
</ul>
<p>Controller 结构体中包含了：</p>
<ul>
<li><code>kubernetes</code> 和代码生成器生成的 <code>database</code> 的 <code>clientSet</code>。</li>
<li>Informer 的 Lister，用来从缓存中获取资源。</li>
<li><code>workqueue</code>：Rate Limit 消息队列。
Controller 在运行时实际是一直尝试从 <code>workqueue</code> 中获取资源并处理。Informer 在接收到状态更新后，会把更新的状态入队列，然后另一个 Routine 中会获取到队列中的消息，拿去处理。
（蛮复杂的，这里还是去直接看代码比较好）</li>
</ul>
</li>
</ul>
<h3 id="修改-controller">修改 Controller</h3>
<p>接下来按照上面讲的那样，修改 <code>pkg/apis/databasecontroller/v1alpha1/types.go</code> 中的 <code>Spec</code> 和 <code>Status</code> 字段，<code>Spec</code> 中的字段是你想定义的 Database 的状态，然后 Controller 负责按照你定义的 <code>Spec</code> 去创建 Deployments 并更新 <code>Status</code>。</p>
<p>首先需要把 <code>Foo</code> 改名成 <code>Database</code>，然后编辑 <code>Spec</code> 中的字段，例如数据库所使用的镜像名称及 Tag，<code>Replicas</code> 冗余数以及其他你觉得创建 Deployment 所需的自定义配置。在修改完 <code>Spec</code> 和 <code>Status</code> 后需要重新执行代码生成器。</p>
<p>之后在项目根目录下编辑 <code>controller.go</code>，修改控制器创建 Deployment 的逻辑，把 <code>Foo</code> 对象修改为 <code>Database</code>，然后按照你定义的 <code>Spec</code>，编辑 <code>artifacs/example</code> 目录下的 <code>crd.yaml</code> 和 <code>example-database.yaml</code> 文件，这部分咱就不把详细的步骤写到这里了，你可以根据你的想法尝试编写你的 Controller，在这里遇到问题最好还是自行尝试动手解决。</p>
<h2 id="其他">其他</h2>
<p>后面还有好多关于 Controller 相关的知识点我也还没搞懂，就不写到博客里误导别人了。除了 <code>sample-controller</code> 这种框架的 Controller 之外，还有很多人使用其他的框架编写 Controller，因为很多时候我们更关注于实现业务逻辑，因此可以套用一些 Operator 模板，常用的有 <a href="https://sdk.operatorframework.io/">Operator SDK</a>，可以通过这个工具生成一份 Controller 模板，然后按照你想实现的功能去修改代码即可，还有很多其他 Operator 可供选择，比如 Rancher 的开发者们使用 <a href="https://github.com/rancher/wrangler">Wrangler</a> 编写 Controller，基于 <code>Wrangler</code> 编写的 Rancher 使用的 Operator 有 <a href="https://github.com/rancher/eks-operator">eks-operator</a> 等一堆 Operator，感兴趣的话可以去看看。<code>Wrangler</code> 的 README 中写的这一段蛮有意思的：</p>
<blockquote>
<p>Most people writing controllers are a bit lost as they find that there is nothing in Kubernetes that is like <code>type Controller interface</code> where you can just do <code>NewController</code>. Instead a controller is really just a pattern of how you use the generated clientsets, informers, and listers combined with some custom event handlers and a workqueue.</p>
</blockquote>
<p>之后如果想把你编写的 Controller (Operator) 应用到生产环境，打包给更多的人使用，可以把编译好的 Operator 二进制文件放到容器镜像中，之后使用 <a href="https://helm.sh">Helm</a> 创建一个 &ldquo;应用程序 (Chart)&quot;，通过编写 <a href="https://helm.sh/docs/chart_best_practices/templates/">模板</a>，在安装 Helm Chart 时编辑 <code>values.yaml</code> 中定义的字段来自定义 CRD 的参数。Helm 的模板本质上是 Go Template 模板渲染引擎，所以用起来都是很简单的（确信）。</p>]]></content:encoded>
    </item>
    <item>
      <title>使用 Helm Chart 方式部署 Harbor</title>
      <link>https://blog.starry-s.moe/posts/2023/harbor-helm-chart/</link>
      <pubDate>Sun, 28 May 2023 16:49:45 +0800</pubDate>
      <guid>https://blog.starry-s.moe/posts/2023/harbor-helm-chart/</guid>
      <description>&lt;p&gt;打算尝试在咱的 NAS 上搭一个 Harbor Registry Server 玩。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>打算尝试在咱的 NAS 上搭一个 Harbor Registry Server 玩。</p>
<p>首先介绍一下 NAS 上的环境，咱的 Kubernetes 集群运行在几个 QEMU 虚拟机里，虚拟机里运行的是 ArchLinux，因为就是咱折腾着玩的所以使用的 k3s 搭建的轻量级的 kubernetes 集群，然后其中一个集群安装了 Rancher 作为 Local 集群。</p>
<h2 id="环境准备">环境准备</h2>
<ol>
<li>
<p>新建一个 Namespace，将 Harbor 的资源与其他资源隔离：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> kubectl create namespace harbor
</span></span></code></pre></div></li>
<li>
<p>为了启用 HTTPS，提前创建一个 TLS 类型的 <a href="https://kubernetes.io/docs/concepts/configuration/secret/">Secret</a>，存放证书:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> cat &gt; cert.pem &lt;&lt; EOF
</span></span><span class="line"><span class="cl"><span class="go">-----BEGIN CERTIFICATE-----
</span></span></span><span class="line"><span class="cl"><span class="go">...
</span></span></span><span class="line"><span class="cl"><span class="go">-----END CERTIFICATE-----
</span></span></span><span class="line"><span class="cl"><span class="go">EOF
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> cat &gt; cert.key &lt;&lt; EOF
</span></span><span class="line"><span class="cl"><span class="go">-----BEGIN PRIVATE KEY-----
</span></span></span><span class="line"><span class="cl"><span class="go">...
</span></span></span><span class="line"><span class="cl"><span class="go">-----END PRIVATE KEY-----
</span></span></span><span class="line"><span class="cl"><span class="go">EOF
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="gp">$</span> kubectl -n harbor create secret tls harbor-tls <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span><span class="go">    --cert=cert.pem \
</span></span></span><span class="line"><span class="cl"><span class="go">    --key=cert.key
</span></span></span></code></pre></div></li>
<li>
<p>提前创建 PVC (<a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">PersistentVolumeClaim</a>)，咱这里先在 NAS 上新建了一个 NFS 服务器，之后创建了 NFS 类型的 PV (PersistentVolumes)，再基于这个 PV 创建的 PVC。</p>
<p>ArchLinux 上搭建 NFS 服务器：<a href="https://wiki.archlinux.org/title/NFS">https://wiki.archlinux.org/title/NFS</a></p>
<blockquote>
<p>在配置 <code>exports</code> 时，需要配置上 <code>no_root_squash</code> 和 <code>no_subtree_check</code>，使挂载的目录及子目录具有写权限。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="c1"># /etc/exports - exports(5) - directories exported to NFS clients</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Use `exportfs -arv` to reload.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">/</span><span class="k">var</span><span class="o">/</span><span class="n">nfs</span><span class="o">/</span><span class="n">harbor</span>		<span class="mf">10.0</span><span class="o">.</span><span class="mf">0.0</span><span class="o">/</span><span class="mi">8</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span><span class="n">sync</span><span class="p">,</span><span class="n">no_root_squash</span><span class="p">,</span><span class="n">no_subtree_check</span><span class="p">)</span>
</span></span></code></pre></div></blockquote>
</li>
</ol>
<h2 id="获取-helm-chart">获取 Helm Chart</h2>
<p>Harbor 的 Helm Chart 可以在 <a href="https://github.com/goharbor/harbor-helm">GitHub</a> 获取，这里使用将 Chart 源码克隆到本地的方式安装，方便编辑 <code>values.yaml</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> git clone https://github.com/goharbor/harbor-helm.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> harbor-helm
</span></span><span class="line"><span class="cl"><span class="gp">$</span> git checkout v1.12.1
</span></span></code></pre></div><blockquote>
<p>写这篇博客时 Chart 的最新版本是 <code>v1.12.1</code> (Harbor OSS v2.8.1)。</p>
</blockquote>
<h3 id="编辑-valuesyaml">编辑 <code>values.yaml</code></h3>
<p>Harbor 的配置都定义在了 <code>values.yaml</code> 文件中，根据需要进行修改。</p>
<p>这里列举些常用的可以修改的选项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">expose</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># expose type, 可以设置为 ingress, clusterIP, nodePort, nodeBalancer，区分大小写</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 默认为 ingress（如果不想使用 80/443 标准端口，可以设置为 nodePort，端口为高位 3000X）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">ingress</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">tls</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 是否启用 TLS (HTTPS)，建议启用</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># TLS Certificate 的来源，可以为 auto, secret 或 none</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 如果为 secret，需要在安装 Chart 之前先创建 TLS Secret</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 1) auto: generate the tls certificate automatically</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 2) secret: read the tls certificate from the specified secret.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># The tls certificate can be generated manually or by cert manager</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 3) none: configure no tls certificate for the ingress. If the default</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># tls certificate is configured in the ingress controller, choose this option</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">certSource</span><span class="p">:</span><span class="w"> </span><span class="l">secret</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">secret</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># The name of secret which contains keys named:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># &#34;tls.crt&#34; - the certificate</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># &#34;tls.key&#34; - the private key</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">secretName</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;harbor-tls&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># Only needed when the &#34;expose.type&#34; is &#34;ingress&#34;.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">notarySecretName</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;harbor-tls&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">ingress</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">hosts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># Ingress Host，如果需要允许任意域名/IP 都能访问，将其设置为空字符串（不建议）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># 这里填写的域名务必能解析到当前集群</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">core</span><span class="p">:</span><span class="w"> </span><span class="l">harbor.example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">notary</span><span class="p">:</span><span class="w"> </span><span class="l">notary.example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># Harbor external URL</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 与 Ingress Host 相对应，如果启用了 TLS，那就是 https://&lt;domain&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 如果没启用 TLS，那就是 http://&lt;domain&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 如果 expose type 为 nodePort，则填写 http(s)://&lt;IP_ADDRESS&gt;:3000X (端口号不能丢)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">externalURL</span><span class="p">:</span><span class="w"> </span><span class="l">https://harbor.example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 持久卷配置，默认为 true，如果是测试环境可以设置为 enabled: false (重新安装 Chart 时仓库里所有的数据都会丢失，不建议！)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 如果需要启用持久卷，可以在安装 Chart 之前提前创建好 PVC，并配置 subPath</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">persistence</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">resourcePolicy</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;keep&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">persistentVolumeClaim</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">registry</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># 填写已经创建好的 PVC</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">existingClaim</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;harbor-pvc&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">storageClass</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># 如果共用一个 PVC，需要设置子目录</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">subPath</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;registry&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">accessMode</span><span class="p">:</span><span class="w"> </span><span class="l">ReadWriteOnce</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">size</span><span class="p">:</span><span class="w"> </span><span class="l">5Gi</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">annotations</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">jobservice</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">jobLog</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">existingClaim</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;harbor-pvc&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">storageClass</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">subPath</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;jobservice&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">accessMode</span><span class="p">:</span><span class="w"> </span><span class="l">ReadWriteOnce</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">size</span><span class="p">:</span><span class="w"> </span><span class="l">1Gi</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">annotations</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">database</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">existingClaim</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;harbor-pvc&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">storageClass</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">subPath</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;database&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">accessMode</span><span class="p">:</span><span class="w"> </span><span class="l">ReadWriteOnce</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">size</span><span class="p">:</span><span class="w"> </span><span class="l">1Gi</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">annotations</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">redis</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">existingClaim</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;harbor-pvc&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">storageClass</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">subPath</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">accessMode</span><span class="p">:</span><span class="w"> </span><span class="l">ReadWriteOnce</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">size</span><span class="p">:</span><span class="w"> </span><span class="l">1Gi</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">annotations</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">trivy</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">existingClaim</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;harbor-pvc&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">storageClass</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">subPath</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;trivy&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">accessMode</span><span class="p">:</span><span class="w"> </span><span class="l">ReadWriteOnce</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">size</span><span class="p">:</span><span class="w"> </span><span class="l">5Gi</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">annotations</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># Admin 初始密码</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">harborAdminPassword</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;Harbor12345&#34;</span><span class="w">
</span></span></span></code></pre></div><h3 id="安装-helm-chart">安装 Helm Chart</h3>
<p>确保 Values 编辑无误后，就可以安装 Chart 了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> helm --namespace harbor install harbor .
</span></span></code></pre></div><p>如果安装后发现 Values 中有些配置需要修改，可以在修改完配置后以升级的方式使配置生效：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> helm --namespace harbor upgrade harbor .
</span></span></code></pre></div><p>查看 Chart 的 Pods 运行状态：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> kubectl --namespace harbor get pods
</span></span><span class="line"><span class="cl"><span class="go">NAME                                    READY   STATUS    RESTARTS      AGE
</span></span></span><span class="line"><span class="cl"><span class="go">harbor-core-7b75785b64-9vzkx            1/1     Running   0             65m
</span></span></span><span class="line"><span class="cl"><span class="go">harbor-database-0                       1/1     Running   0             77m
</span></span></span><span class="line"><span class="cl"><span class="go">harbor-jobservice-6f4d59bd95-25q44      1/1     Running   2 (65m ago)   65m
</span></span></span><span class="line"><span class="cl"><span class="go">harbor-notary-server-584698b475-lnt99   1/1     Running   1 (60m ago)   65m
</span></span></span><span class="line"><span class="cl"><span class="go">harbor-notary-signer-77685b6f94-pfngc   1/1     Running   0             65m
</span></span></span><span class="line"><span class="cl"><span class="go">harbor-portal-6fb6465fd6-hm4cg          1/1     Running   0             77m
</span></span></span><span class="line"><span class="cl"><span class="go">harbor-redis-0                          1/1     Running   0             77m
</span></span></span><span class="line"><span class="cl"><span class="go">harbor-registry-5bbccf79fb-7hcm9        2/2     Running   0             65m
</span></span></span><span class="line"><span class="cl"><span class="go">harbor-trivy-0                          1/1     Running   0             77m
</span></span></span></code></pre></div><h2 id="其他">其他</h2>
<p>安装完成后，就可以完美使用 Harbor Registry 了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> docker login harbor.example.com
</span></span><span class="line"><span class="cl"><span class="go">Username: admin
</span></span></span><span class="line"><span class="cl"><span class="go">Password:
</span></span></span><span class="line"><span class="cl"><span class="go">WARNING! Your password will be stored unencrypted in /home/user/.docker/config.json.
</span></span></span><span class="line"><span class="cl"><span class="go">Configure a credential helper to remove this warning. See
</span></span></span><span class="line"><span class="cl"><span class="go">https://docs.docker.com/engine/reference/commandline/login/#credentials-store
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="go">Login Succeeded
</span></span></span></code></pre></div><p>从 DockerHub 中 Mirror 一些镜像到 Harbor 中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> skopeo copy --all docker://archlinux:latest docker://harbor.example.com/library/archlinux:latest
</span></span><span class="line"><span class="cl"><span class="go">Getting image list signatures
</span></span></span><span class="line"><span class="cl"><span class="go">Copying 1 of 1 images in list
</span></span></span><span class="line"><span class="cl"><span class="go">Copying image sha256:076c0233d1996165721320957be9a037a760574d6334281354b07b3b3c9440b1 (1/1)
</span></span></span><span class="line"><span class="cl"><span class="go">Getting image source signatures
</span></span></span><span class="line"><span class="cl"><span class="go">Copying blob f0e04a7b4686 done
</span></span></span><span class="line"><span class="cl"><span class="go">Copying blob 352736306209 done
</span></span></span><span class="line"><span class="cl"><span class="go">Copying config cc4866169d done
</span></span></span><span class="line"><span class="cl"><span class="go">Writing manifest to image destination
</span></span></span><span class="line"><span class="cl"><span class="go">Storing signatures
</span></span></span><span class="line"><span class="cl"><span class="go">Writing manifest list to image destination
</span></span></span><span class="line"><span class="cl"><span class="go">Storing list signatures
</span></span></span></code></pre></div>]]></content:encoded>
    </item>
  </channel>
</rss>
