<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>学习资料 on STARRY-S&#39; Blog</title>
    <link>https://blog.starry-s.moe/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</link>
    <description>Recent content in 学习资料 on STARRY-S&#39; Blog</description>
    <image>
      <title>STARRY-S&#39; Blog</title>
      <url>https://blog.starry-s.moe/avatar.png</url>
      <link>https://blog.starry-s.moe/avatar.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>© 2016 - 2024 STARRY-S | [CC BY-NC-ND 4.0](https://creativecommons.org/licenses/by-nc-nd/4.0/) | Hosted on [GitHub Pages](https://pages.github.com)&lt;br /&gt;</copyright>
    <lastBuildDate>Mon, 10 May 2021 21:33:10 +0800</lastBuildDate><atom:link href="https://blog.starry-s.moe/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Learn OpenGL</title>
      <link>https://blog.starry-s.moe/posts/2021/learn_opengl/</link>
      <pubDate>Mon, 10 May 2021 21:33:10 +0800</pubDate>
      
      <guid>https://blog.starry-s.moe/posts/2021/learn_opengl/</guid>
      <description>&lt;p&gt;其实咱很久很久以前就开始看&lt;a href=&#34;https://learnopengl-cn.github.io/&#34;&gt;LearnOpenGL CN&lt;/a&gt;这个网站了&amp;hellip;&amp;hellip;&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>其实咱很久很久以前就开始看<a href="https://learnopengl-cn.github.io/">LearnOpenGL CN</a>这个网站了&hellip;&hellip;</p>
<meting-js server="netease" type="song" id="1322354976" theme="#233333"></meting-js>
<hr>
<h2 id="前言">前言</h2>
<p>首先需要明白什么是核心模式，什么是立即渲染模式，立即渲染模式的代码中都包含<code>glBegin()</code>和<code>glEnd()</code>，绘图的部分都是在这两个函数之间，比如画一个点就是<code>glVertex2f(x, y)</code>，这种方式画图确实很简单，用户只要提供坐标和颜色就好了，不用知道GPU干了什么，而缺点是性能低，有很多限制，所以新版本的OpenGL为了给开发者提供更多的可操作空间而逐渐废弃了立即渲染改用核心模式。</p>
<p>核心模式提供了很多强大的功能，可以管线编程，代码量增加了很多，所以对初学者不太友好。</p>
<p>LearnOpenGL CN上面的代码基于C++，而OpenGL是用C编写的，教程上的代码除了矩阵运算部分可以使用C++的运算符重载而使代码编写起来变得更简单一些外，其他部分基本没啥区别，而且教程为了便于教学使用的也是面向过程式编程，没有将各个功能封装到一个类里面，所以咱这篇教程用C编写。</p>
<p>要记住C就是C，C++就是C++，C不是C++的子集，只能说C++兼容部分C的代码，不要把C和C++混用，不要因为C++支持面向对象使得一些功能看起来简单很易于使用就轻易迈入C++的坑。</p>
<h2 id="准备工作">准备工作</h2>
<p>有关OpenGL的介绍以及安装GLFW、GLAD以及编译所需的CMake的部分可以直接看<a href="https://learnopengl-cn.github.io/01%20Getting%20started/02%20Creating%20a%20window/">教程</a>，咱尽可能把教程上没有提到的或者是刚开始学OpenGL很难理解的部分记录下来。</p>
<p>大体上就是安装<code>glfw</code>，Arch Linux使用包管理器<code>sudo pacman -S glfw-x11</code> (如果你使用的是wayland，那么安装<code>glfw-wayland</code>)，然后把下载的<code>glad/glad.h</code>复制到<code>/usr/include</code>下，把<code>glad.c</code>复制到工程文件夹的代码目录下。</p>
<p>为使用CMake生成Makefile，编写<code>CMakeLists.txt</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.0</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;Learn OpenGL&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">LANGUAGES</span> <span class="s">C</span>
</span></span><span class="line"><span class="cl">    <span class="s">VERSION</span> <span class="s">0.1.0</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">C_FLAGS</span> <span class="s2">&#34;-Wall -lm -ldl -std=c11&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_C_FLAGS</span> <span class="o">${</span><span class="nv">C_FLAGS</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">OpenGL_GL_PREFERENCE</span> <span class="s">LEGACY</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">find_package</span><span class="p">(</span><span class="s">glfw3</span> <span class="s">REQUIRED</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">find_package</span><span class="p">(</span><span class="s">OpenGL</span> <span class="s">REQUIRED</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">OPENGL_INCLUDE_DIR</span><span class="o">}</span> <span class="s">src</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">aux_source_directory</span><span class="p">(</span><span class="s2">&#34;src&#34;</span> <span class="s">GLSRC</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">main</span> <span class="o">${</span><span class="nv">GLSRC</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">main</span> <span class="o">${</span><span class="nv">OPENGL_gl_LIBRARY</span><span class="o">}</span> <span class="s">glfw</span><span class="p">)</span><span class="err">
</span></span></span></code></pre></div><p>完成上述步骤后，确保工程文件夹的结构如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">├── build/
</span></span><span class="line"><span class="cl">├── CMakeLists.txt
</span></span><span class="line"><span class="cl">└── src/
</span></span><span class="line"><span class="cl">    ├── glad.c
</span></span><span class="line"><span class="cl">    └── main.c
</span></span></code></pre></div><h2 id="创建窗口">创建窗口</h2>
<p>编辑<code>main.c</code>，加入所需的头文件</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// glad.h要加在glfw3.h之前
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;glad/glad.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;GLFW/glfw3.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span></code></pre></div><p>在main函数中初始化OpenGL并创建窗口</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">glfwInit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 使用OpenGL版本为3.3 */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MAJOR</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MINOR</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 使用核心模式 */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_OPENGL_PROFILE</span><span class="p">,</span> <span class="n">GLFW_OPENGL_CORE_PROFILE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef __APPLE__
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="nf">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_OPENGL_FORWARD_COMPAT</span><span class="p">,</span> <span class="n">GL_TRUE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 创建窗口 */</span>
</span></span><span class="line"><span class="cl">        <span class="n">GLFWwindow</span> <span class="o">*</span><span class="n">window</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">glfwCreateWindow</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="s">&#34;Hello World&#34;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">window</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Failed to create window.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">glfwTerminate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 初始化glad */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">gladLoadGLLoader</span><span class="p">((</span><span class="n">GLADloadproc</span><span class="p">)</span> <span class="n">glfwGetProcAddress</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Failed to initialize GLAD</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">glfwTerminate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* prepare render */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* main loop */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">glfwTerminate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>创建窗口的代码比较容易理解，到这里可以尝试编译一下代码检查有没有遇到什么问题，如果编译失败了可以尝试检查GLFW是否安装正确，代码哪里出现了什么问题。</p>
<p>编译代码并运行生成的程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cd build
</span></span><span class="line"><span class="cl">cmake .. &amp;&amp; make -j8
</span></span><span class="line"><span class="cl">./main
</span></span></code></pre></div><p>如果一切正常的话，可以看到窗口一闪而过就消失了，因为到目前为止我们只创建了一个窗口，创建完成后就结束了程序，所以窗口会瞬间消失。</p>
<hr>
<h2 id="准备绘图">准备绘图</h2>
<p>在绘制形状之前，我们需要一些准备工作比如设定视口、回调函数，创建顶点缓冲区等操作，然后在大循环中进行渲染绘制。</p>
<h3 id="视口">视口</h3>
<p>首先要告诉OpenGL咱的窗口尺寸是多少，以便OpenGL根据窗口大小显示数据和坐标。</p>
<p>在<code>/* prepare render */</code>处添加代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="nf">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">);</span>
</span></span></code></pre></div><p>首先需要知道你传给OpenGL的坐标都是<code>-1.0</code>到<code>1.0</code>之间的数，OpenGL再将其转换成屏幕上的像素点坐标，这个过程由GPU运算所得，所以你得告诉OpenGL你的屏幕尺寸，<code>glViewport</code>的前两个参数为<code>0, 0</code>指的是窗口左下角的位置，这个值咱目前不需要修改。</p>
<h3 id="回调函数">回调函数</h3>
<p>我们需要一个窗口被更改的回调函数，这样当窗口尺寸发生变化时，程序可以调用这个函数调整视口。</p>
<p>我们还需要一个<a href="https://www.glfw.org/docs/3.3/input_guide.html#input_key">按键回调函数</a>，当用户按下键盘上的某个按键后会调用这个回调函数处理按键操作。</p>
<p>编写函数<code>framebuffer_size_callback</code>用来处理窗口尺寸更改:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">framebuffer_size_callback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这样当你拖拽窗口进行缩放时，窗口里的图像也会跟着窗口尺寸改变而进行缩放。</p>
<p>编写<code>key_callback</code>函数处理用户按键操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">key_callback</span><span class="p">(</span><span class="n">GLFWwindow</span> <span class="o">*</span><span class="n">window</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">action</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">GLFW_KEY_ESCAPE</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="n">GLFW_PRESS</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">glfwSetWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">GL_TRUE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">GLFW_KEY_Q</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="n">GLFW_PRESS</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">glfwSetWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">GL_TRUE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>当用户按下<code>ESC</code>或<code>Q</code>键时，可以结束OpenGL窗口的运行。</p>
<p>然后我们需要注册这两个回调函数，在<code>/* prepare render */</code>处添加下面的代码:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="nf">glfwSetFramebufferSizeCallback</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">framebuffer_size_callback</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">glfwSetKeyCallback</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">key_callback</span><span class="p">);</span>
</span></span></code></pre></div><h3 id="大循环">大循环</h3>
<p>在大循环中，每循环一次代表绘制一帧画面。这里利用了双缓冲将绘制的图形放到缓存中，然后将缓存中的图形刷新到显示器上。(因为OpenGL绘图操作是逐行绘制的，如果不先将图形存到缓存中而直接显示在显示器上的话，在画面快速变动时你很可能会遇到画面撕裂，垂直不同步)</p>
<p>大循环部分的代码长这个样子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="nf">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 清空背景色为深灰色 */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">glClearColor</span><span class="p">(</span><span class="mf">0.1f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* draw something */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* swap buffer */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">glfwPollEvents</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>每次循环的开始需要使用<code>glClear</code>清空屏幕，这样就不会看到上一次渲染的结果。</p>
<p>这里我们使用<code>glClearColor</code>设定清空屏幕的颜色为接近纯黑色的灰色。</p>
<p>大循环每循环一次，OpenGL就渲染了一帧画面并显示在显示器上，所以你可以计算一秒钟循环的次数而估算游戏的帧率。</p>
<blockquote>
<p>因为我们使用了双缓冲，所以这时游戏的帧数被限制为等于显示的刷新帧数，
比如显示器刷新率为144帧，游戏的帧率就被锁为144，如果想解除这个限制需要改为单缓冲。</p>
</blockquote>
<hr>
<p>到此为止，我们已经创建了一个游戏引擎，但是这个引擎还什么都没有做。</p>
<p>尝试编译代码，可以看到一个黑色（深灰）的窗口，按<code>ESC</code>或<code>Q</code>即可结束运行。</p>
<p><img loading="lazy" src="images/create_window.png" alt="Window" />
<p style="margin-bottom: -0.8em;" class="image-title">创建窗口</p>
</p>
<p>如果你遇到什么问题，可以<a href="/posts/2021/learn_opengl/learn-code-1/main.c">对照一下代码</a>是否有问题。</p>
<hr>
<h2 id="三角形">三角形</h2>
<p>画三角形的过程很简单，首先要确定三角形的三个顶点坐标，然后告诉GPU这三个点坐标就可以了 :)</p>
<blockquote>
<p>如果你看不懂顶点着色器、几何着色器、片段着色器、光栅化这些难懂的知识点，那么你不必急于弄懂这个过程，等把图形绘制出来后再回来看这部分的内容。</p>
</blockquote>
<h3 id="标准化设备坐标">标准化设备坐标</h3>
<p>因为OpenGL的坐标为都是-1.0f到1.0f之间的数（我们先不考虑视口变换这些复杂的情形）</p>
<p>x, y, z的坐标为-1.0f到1.0f的坐标称作标准化设备坐标，坐标原点在窗口的正中央且在窗口的表面上，往右为x正方向，往上为y正方向，往屏幕里面为z正方向（这里是左手系）。</p>
<p>有关标准化设备坐标的介绍请看<a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/#_2">这里</a>。</p>
<p>所以我们先声明三角形的顶点和颜色值到一个一维数组里面（用一维数组是因为顶点坐标值在内存的分布都是连续的，这样方便给GPU传坐标）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>     <span class="c1">// 左下角
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>     <span class="c1">// red
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>     <span class="c1">// 右下角
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>     <span class="c1">// green
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>     <span class="c1">// y轴正上方
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span>      <span class="c1">// blue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><h3 id="顶点缓冲">顶点缓冲</h3>
<p>首先我们需要创建一个顶点缓冲对象，用来存我们的顶点信息，这个对象叫“Vertex Buffer Object”（VBO），之后创建一个顶点数组对象“Vertex Array Object”（VAO），用来存我们创建的VBO。</p>
<p>为便于理解，你可以把VBO当作为开辟了一块GPU上的显存(Buffer)，用来存顶点和颜色信息，然后VAO是一个包含多个VBO的数组(Array)。</p>
<p>绘图时可以把VBO中存的大量顶点信息发送给GPU，因为用CPU给显卡发顶点坐标的速度慢而且没办法一次发送大量的顶点坐标，所以我们把顶点坐标存到显存中，绘图时直接访问显存即可。</p>
<p>生成一个VBO和一个VAO的代码为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// VAO和VBO的ID都是非负整型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">GLuint</span> <span class="n">VBO</span><span class="p">,</span> <span class="n">VAO</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 生成一个VAO和一个VBO
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VBO</span><span class="p">);</span>
</span></span></code></pre></div><p>我们刚刚创建好了一个缓存对象，我们现在需要告诉这个缓存的数据空间大小以及数据（顶点坐标）。</p>
<p>首先我们绑定刚创建的VAO，然后绑定VBO</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="nf">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
</span></span></code></pre></div><p>之后给VBO传递数组信息</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="nf">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li>
<p>第一个参数是目标缓冲的类型，我们刚刚把VBO绑定到<code>GL_ARRAY_BUFFER</code>上了</p>
</li>
<li>
<p>第二个参数是顶点信息所占的空间大小，单位是字节。三角形一共3个顶点，每个顶点有3个坐标值和3个颜色值，</p>
<p>所以大小是<code>6 * 3 * sizeof(float)</code>，不过我们可以直接用<code>sizeof(vertices)</code>知道整个数组的大小。</p>
</li>
<li>
<p>第三个参数是数组的地址</p>
</li>
<li>
<p>第四个参数告诉GL我们的顶点数据几乎不会改变，所以是<code>GL_STATIC_DRAW</code>。</p>
<p>如果数据会被改变很多次，则为<code>GL_DYNAMIC_DRAW</code></p>
<p>如果数据每次绘制都会更改，则改为<code>GL_STREAM_DRAW</code></p>
</li>
</ul>
<p>然后我们告诉CPU我们给VBO传递的数组都是什么：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="nf">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">6</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">6</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl"><span class="nf">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li>
<p>第一个参数为位置，告诉这个数据传递到顶点着色器的哪个位置上</p>
</li>
<li>
<p>第二个参数为大小，我们定义的那个数组一个顶点有3个坐标，所以是3</p>
</li>
<li>
<p>第三个参数为数据类型，这里是float。</p>
</li>
<li>
<p>第四个参数为false，暂时不用管他</p>
</li>
<li>
<p>第五个参数为步长，一个顶点有三个坐标和三个颜色值，所以每传一个顶点，就走<code>6 * sizeof(float)</code>的长度。</p>
</li>
<li>
<p>第六个参数为偏移量，因为我们定义的数组中前三个数字代表顶点坐标，后三个数字代表颜色，所以传递顶点坐标时，偏移量为0，传递颜色时偏移量为<code>3 * sizeof(float)</code>。</p>
</li>
</ul>
<p><img loading="lazy" src="https://learnopengl-cn.github.io/img/01/05/vertex_attribute_pointer_interleaved.png" alt="VBO中内存数据" />
<p style="margin-bottom: -0.8em;" class="image-title">VBO中内存数据</p>
</p>
<p>之后使用<code>glEnableVertexAttribArray</code>告诉OpenGL启用顶点着色器上这个位置的数据。</p>
<p>最后使用完VAO后要记得将其解绑：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="nf">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span></code></pre></div><h3 id="着色器">着色器</h3>
<p>我们需要写两个着色器程序，分别为顶点着色器和片段着色器。</p>
<blockquote>
<p>开头说的核心模式可编程管线就是指我们可以写着色器程序，手动指定管线都进行什么操作。</p>
</blockquote>
<h4 id="顶点着色器">顶点着色器</h4>
<p>因为OpenGL使用的是标准化设备坐标而不是屏幕上的像素点为坐标，所以GPU需要把标准化设备坐标转换为屏幕上的像素点，这个过程由顶点着色器实现。</p>
<p>而顶点着色器不知道咱们三角形的每个顶点的坐标是多少，所以咱们得往着色器中传我们刚才创建的VBO里面存储的坐标。</p>
<p>着色器程序使用GLSL编写，其代码和C很像</p>
<p>在代码文件夹中新建一个<code>vertex.glsl</code>，编写以下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cp">#version 330 core</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">aPos</span><span class="p">;</span>     <span class="c1">// 传入坐标</span>
</span></span><span class="line"><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">aColor</span><span class="p">;</span>   <span class="c1">// 传入颜色</span>
</span></span><span class="line"><span class="cl"><span class="k">out</span> <span class="k">vec3</span> <span class="n">color</span><span class="p">;</span>     <span class="c1">// 向片段着色器发送颜色</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">color</span> <span class="o">=</span> <span class="n">aColor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>
<p>第一行代表我们使用OpenGL 3.3 核心模式</p>
</li>
<li>
<p>第二行声明了一个类型为<code>vec3</code>（三维坐标）的变量，该变量的位置为<code>0</code>，需要人为的通过这个位置给他传值，这个变量代表顶点的坐标</p>
</li>
<li>
<p>第三行声明的<code>aColor</code>用来代表颜色，顶点着色器不需要处理颜色，所以我们接收到颜色值后不需要处理，直接传出去即可。</p>
</li>
<li>
<p>main函数中<code>gl_Position</code>代表这个顶点的位置坐标，我们把CPU传给顶点着色器的<code>vec3</code>转换为<code>vec4</code>。</p>
</li>
</ul>
<h4 id="片段着色器">片段着色器</h4>
<p>顶点着色器处理完顶点后，由片段着色器计算每个像素点的颜色，所以如果我们想给三角形上色的话，也是在这个环节进行。</p>
<p>在代码文件夹中新建一个<code>fragment.glsl</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cp">#version 330 core</span>
</span></span><span class="line"><span class="cl"><span class="k">in</span> <span class="k">vec3</span> <span class="n">color</span><span class="p">;</span>    <span class="c1">// 接收顶点着色器发送的颜色</span>
</span></span><span class="line"><span class="cl"><span class="k">out</span> <span class="k">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>
<p>第一行同顶点着色器，代表OpenGL版本为3.3 核心模式</p>
</li>
<li>
<p>第二行表示接收顶点着色器发送的颜色数据到变量<code>color</code></p>
</li>
<li>
<p>第三行声明了一个类型为<code>vec4</code>(4维坐标)的变量，表示向外传递变量<code>FragColor</code>（该像素点的颜色值）</p>
</li>
<li>
<p>main函数中设定变量<code>FragColor</code>的值等于<code>color</code>，用来指颜色。</p>
<p>最后一个值恒为1.0f，我们暂时不需要修改它。</p>
</li>
</ul>
<h3 id="编译着色器">编译着色器</h3>
<p>因为我们只是写了着色器程序的代码，需要让GPU将其编译。</p>
<p>编译着色器的部分对应的LearnOpenGL CN教程<a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/#_4">在这里</a>，本篇不打算重复讲编译着色器部分的代码。</p>
<p>我们可以把编译着色器的代码封装到几个函数里面，这样可以减少main函数中重复代码的数量。</p>
<p>有关这部分的代码我推荐使用<a href="https://sh.alynx.one/posts/Learn-OpenGL-1/#%E7%9D%80%E8%89%B2%E5%99%A8%EF%BC%88Shader%EF%BC%89">这篇文章</a>中讲述的方式从文件中读取glsl代码并将其编译。</p>
<p>最后在main函数的准备阶段处的最下面，插入以下代码，编译你的着色器程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">GLuint</span> <span class="n">shaderProgram</span> <span class="o">=</span> <span class="nf">load_program</span><span class="p">(</span><span class="s">&#34;vertex.glsl&#34;</span><span class="p">,</span> <span class="s">&#34;fragment.glsl&#34;</span><span class="p">);</span>
</span></span></code></pre></div><h3 id="我们期待的三角形">我们期待的三角形</h3>
<p>经过了前面的一番准备，我们创建了缓冲对象存顶点的坐标和颜色信息，之后编写了着色器程序处理顶点坐标和颜色。</p>
<p>现在我们终于可以在大循环中画三角形了。</p>
<p>在大循环的<code>/* draw something */</code>下面添加如下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="nf">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span></code></pre></div><p>这串代码表示我们首先使用刚编译好的着色器程序，之后绑定VAO，绘制一个三角形，最后解绑。</p>
<hr>
<p>至此我们的工程文件夹结构修改如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">├── build/
</span></span><span class="line"><span class="cl">├── CMakeLists.txt
</span></span><span class="line"><span class="cl">└── src/
</span></span><span class="line"><span class="cl">    ├── fragment.glsl
</span></span><span class="line"><span class="cl">    ├── glad.c
</span></span><span class="line"><span class="cl">    ├── main.c
</span></span><span class="line"><span class="cl">    ├── shader.c
</span></span><span class="line"><span class="cl">    ├── shader.h
</span></span><span class="line"><span class="cl">    └── vertex.glsl
</span></span></code></pre></div><p>因为我们编写了<code>vertex.glsl</code>和<code>fragment.glsl</code>，需要修改<code>CMakeLists.txt</code>，使得编译时将代码文件夹下的着色器文件复制到<code>build</code>文件夹下。</p>
<p>在<code>CMakeLists.txt</code>的<code>find_package</code>下面添加如下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">configure_file(src/vertex.glsl vertex.glsl COPYONLY)
</span></span><span class="line"><span class="cl">configure_file(src/fragment.glsl fragment.glsl COPYONLY)
</span></span></code></pre></div><p>编译后运行程序，可以看到一个五颜六色的三角形，它的左下角为红色，右下角为绿色，顶点为蓝色。</p>
<p><img loading="lazy" src="images/draw_triangle.png" alt="三角形" />
<p style="margin-bottom: -0.8em;" class="image-title">三角形</p>
</p>
<p>如果你遇到了问题，或者哪里不太明白，可以看咱写好的代码：</p>
<ul>
<li>
<p><a href="/posts/2021/learn_opengl/learn-code-2/main.c">main.c</a></p>
</li>
<li>
<p><a href="/posts/2021/learn_opengl/learn-code-2/shader.h">shader.h</a></p>
</li>
<li>
<p><a href="/posts/2021/learn_opengl/learn-code-2/shader.c">shader.c</a></p>
</li>
<li>
<p><a href="/posts/2021/learn_opengl/learn-code-2/vertex.glsl">vertex.glsl</a></p>
</li>
<li>
<p><a href="/posts/2021/learn_opengl/learn-code-2/fragment.glsl">fragment.glsl</a></p>
</li>
<li>
<p><a href="/posts/2021/learn_opengl/learn-code-2/CMakeLists.txt">CMakeLists.txt</a></p>
</li>
</ul>
<hr>]]></content:encoded>
    </item>
    
    <item>
      <title>51单片机习题整理</title>
      <link>https://blog.starry-s.moe/posts/2020/learn-mcs8051/</link>
      <pubDate>Tue, 03 Nov 2020 20:19:36 +0800</pubDate>
      
      <guid>https://blog.starry-s.moe/posts/2020/learn-mcs8051/</guid>
      <description>&lt;p&gt;赶在&lt;del&gt;期中考试&lt;/del&gt;(骑磨烤柿)前把单片机的课后习题整理出来&amp;hellip;&lt;/p&gt;
&lt;p&gt;(实在是没什么可拿来更新博客的了, 就干脆写点复习资料吧&amp;hellip;)&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>赶在<del>期中考试</del>(骑磨烤柿)前把单片机的课后习题整理出来&hellip;</p>
<p>(实在是没什么可拿来更新博客的了, 就干脆写点复习资料吧&hellip;)</p>
<hr>
<blockquote>
<p>本篇内容为作者整理资料所得, 仅供学习使用。如需转载请务必遵循CC BY-NC-ND 4.0协议。
请勿将本篇内容作为权威的教学辅导资料使用, 因无法保证100%准确, 仅供参考。</p>
<p>如果发现了本篇存在的错误, 欢迎在页面下方提issue指正。</p>
<p>本篇文章使用MathJax显示数学公式，在使用RSS阅读器时会出现无法正确显示的情况。</p>
</blockquote>
<meting-js server="netease" type="song" id="1429420739" theme="#233333"></meting-js>
<h2 id="硬件结构指令系统">硬件结构&amp;指令系统</h2>
<ol>
<li>
<p>8051复位后从地址<code>0000H</code>开始执行程序, SP的值为<code>07H</code>。</p>
<p>PC: 两字节(16位)寄存器, 也称程序计数器。</p>
<p>SP: 堆栈指针, 指示出堆栈顶部在<strong>内部RAM块</strong>中的位置。</p>
<p>单片机的堆栈设在了内部RAM区, 单片机复位后, SP中的内容为<code>07H</code>(指向第0组工作寄存器的R7), 堆栈实际上从<code>08H</code>开始。</p>
<p>若SP被初始化为<code>39H</code>, 则堆栈实际上是从<code>3AH</code>开始的。</p>
<p>执行<code>LCALL addr16</code>指令时，单片机先将PC的低字节压栈，再将PC的高字节压栈，最后把转移地址送入PC中。</p>
<p>与之类似的<code>LJMP</code>类无条件转移指令，单片机只修改PC的值，并不堆栈保存跳转前的PC中保存的地址。</p>
<p>执行<code>RET</code>指令后, SP值减2 (因为PC为2字节寄存器), 进行两次出栈操作，第一次出栈送PC的高位，第二次出栈送PC的低位。</p>
<p>中断服务程序结束指令<code>RETI</code>不仅将堆栈中保存的2字节地址分别送入PC的高位和低位中，而且复位中断系统。因此<code>RET</code>和<code>RETI</code>不同。</p>
<p><code>RET</code>和<code>RETI</code>对堆栈的操作是相同的。</p>
</li>
<li>
<p>PSW中的<code>RS1 RS0</code>=<code>10B</code>时, R2的RAM地址为<code>12H</code>。</p>
<p>PSW： 程序状态字寄存器, 从<code>PSW.7</code>至<code>PSW.0</code>分别为<code>Cy</code>(进位标志位), <code>Ac</code>(辅助进位标志位), <code>F0</code>(标志位), <code>RS1</code>和<code>RS0</code>(寄存器区选择控制位), <code>OV</code>(溢出位), 保留位, <code>P</code>(奇偶标志位, 奇数为1, 偶数为0)。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">D7</th>
<th style="text-align:center">D6</th>
<th style="text-align:center">D5</th>
<th style="text-align:center">D4</th>
<th style="text-align:center">D3</th>
<th style="text-align:center">D2</th>
<th style="text-align:center">D1</th>
<th style="text-align:center">D0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PSW</td>
<td style="text-align:center">Cy</td>
<td style="text-align:center">Ac</td>
<td style="text-align:center">F0</td>
<td style="text-align:center">RS1</td>
<td style="text-align:center">RS0</td>
<td style="text-align:center">OV</td>
<td style="text-align:center"></td>
<td style="text-align:center">P</td>
</tr>
</tbody>
</table>
<p><code>RS1 RS0</code> = <code>10B</code>时, 使用第二组工作寄存器区, 第0组工作寄存器区R0-R7的地址为<code>00H-07H</code>, 第1组为<code>08H-0FH</code>, 第2组为<code>10H-17H</code>, 第3组为<code>18H-1FH</code>(每组长度为8个字节, 每个寄存器占1个字节)。</p>
<p>因此, 当A为<code>01110010B</code>时, PSW中P为0(偶数个1)。</p>
<p><code>INC A</code>指令不改变<code>PSW</code>中的<code>Cy</code>，只有可能改变奇偶标志位<code>P</code>。</p>
<p>假设PSW为<code>18H</code>, 即<code>00011000B</code>, 此时使用第3组工作寄存器, R0地址为<code>18H</code>, R7地址为<code>1FH</code>。</p>
<p>复位后, 默认选择的寄存器区是0区。</p>
</li>
<li>
<p>8051片外数据存储器的寻址空间为<code>0000H~0FFFFH</code></p>
</li>
<li>
<p>位地址<code>07H</code>位于字节地址<code>20H</code>, 位地址<code>7FH</code>位于字节地址<code>2FH</code>。</p>
<p>片内RAM中<code>20H~2FH</code>这16个单元即可进行共128位的位寻址, 也可进行字节寻址。</p>
<p>字节地址及其位地址见下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字节地址</th>
<th style="text-align:center">D7</th>
<th style="text-align:center">D6</th>
<th style="text-align:center">D5</th>
<th style="text-align:center">D4</th>
<th style="text-align:center">D3</th>
<th style="text-align:center">D2</th>
<th style="text-align:center">D1</th>
<th style="text-align:center">D0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2FH</td>
<td style="text-align:center">7FH</td>
<td style="text-align:center">7EH</td>
<td style="text-align:center">7DH</td>
<td style="text-align:center">7CH</td>
<td style="text-align:center">7BH</td>
<td style="text-align:center">7AH</td>
<td style="text-align:center">79H</td>
<td style="text-align:center">78H</td>
</tr>
<tr>
<td style="text-align:center">2EH</td>
<td style="text-align:center">77H</td>
<td style="text-align:center">76H</td>
<td style="text-align:center">75H</td>
<td style="text-align:center">74H</td>
<td style="text-align:center">73H</td>
<td style="text-align:center">72H</td>
<td style="text-align:center">71H</td>
<td style="text-align:center">70H</td>
</tr>
<tr>
<td style="text-align:center">2DH</td>
<td style="text-align:center">6FH</td>
<td style="text-align:center">6EH</td>
<td style="text-align:center">6DH</td>
<td style="text-align:center">6CH</td>
<td style="text-align:center">6BH</td>
<td style="text-align:center">6AH</td>
<td style="text-align:center">69H</td>
<td style="text-align:center">68H</td>
</tr>
<tr>
<td style="text-align:center">&hellip;</td>
<td style="text-align:center">&hellip;</td>
<td style="text-align:center">&hellip;</td>
<td style="text-align:center">&hellip;</td>
<td style="text-align:center">&hellip;</td>
<td style="text-align:center">&hellip;</td>
<td style="text-align:center">&hellip;</td>
<td style="text-align:center">&hellip;</td>
<td style="text-align:center">&hellip;</td>
</tr>
<tr>
<td style="text-align:center">21H</td>
<td style="text-align:center">0FH</td>
<td style="text-align:center">0EH</td>
<td style="text-align:center">0DH</td>
<td style="text-align:center">0CH</td>
<td style="text-align:center">0BH</td>
<td style="text-align:center">0AH</td>
<td style="text-align:center">09H</td>
<td style="text-align:center">08H</td>
</tr>
<tr>
<td style="text-align:center">20H</td>
<td style="text-align:center">07H</td>
<td style="text-align:center">06H</td>
<td style="text-align:center">05H</td>
<td style="text-align:center">04H</td>
<td style="text-align:center">03H</td>
<td style="text-align:center">02H</td>
<td style="text-align:center">01H</td>
<td style="text-align:center">00H</td>
</tr>
</tbody>
</table>
<p>因此<code>00H~07H</code>位于字节地址<code>20H</code>, <code>78H-7FH</code>位于字节地址<code>2FH</code>。</p>
<p>除此之外，一些特殊功能寄存器（SFR）可进行位寻址（字节地址能够被8整除），SFR中位地址有83个（共有88个，5个未用），能够位寻址的SFR的字节地址末位均为<code>0H</code>或<code>8H</code>。</p>
</li>
<li>
<p>访问外部存储器时, P0口用来传输低8位地址和数据, P2口用来传送高8位地址。</p>
</li>
<li>
<p>访问外部存储器时, ALE的输出用于锁存低8位地址。</p>
</li>
<li>
<p>一个机器周期为12个震荡周期</p>
</li>
<li>
<p>为保证读入数据正确, 在读一个端口引脚之前应先向相应的端口锁存器写1。</p>
<p>如果在读一个端口引脚之前向对应的输出锁存器写了0, 将总是读到0。</p>
<p>8051访问片外存储器时, 利用ALE信号锁存来自P0的低8位地址信号。</p>
</li>
<li>
<p>只能用直接寻址方式访问特殊功能寄存器。</p>
<p>如果为8052单片机, 在访问高128字节的RAM时, 只能用间接寻址方式寻址。</p>
<p>访问片外数据存储器64Kbyte时, 使用<code>DPTR</code>做间接寻址寄存器。</p>
<p>使用<code>MOVX @DPTR</code>类指令访问外部扩展存储器时, P2口输出高8位地址, P0口传送低8位地址和数据。</p>
<p>8051中, <code>PC</code>和<code>DPTR</code>都用于提供地址时, <code>PC</code>是<strong>用户程序不可访问的</strong>, <code>DPTR</code>可以分为两个8位寄存器<code>DPH</code>和<code>DPL</code>使用。</p>
</li>
<li>
<p>累加器A的值为<code>30H</code>, 指令<code>MOVC A, @A+PC</code>位于地址<code>3000H</code>。执行该指令时, 程序存储器地址<code>3031H</code>的内容被传送至累加器A。</p>
</li>
</ol>
<p>指令<code>MOVC A, @A+PC</code>长度为1字节, 位于地址<code>3000H</code>, 因此PC值为<code>3001H</code>, 故<code>A+PC</code>为<code>3031H</code>。</p>
<ol start="11">
<li>设SP的值为<code>5FH</code>, 指令<code>LCALL DELAY</code>所在地址为<code>2030H</code>, 子程序DELAY所在地址为<code>20A0H</code>, 则该指令完成的操作是将地址<code>2033H</code>压入堆栈保存, 将地址<code>20A0H</code>送入PC, SP的值应在该指令执行结束后变成<code>61H</code>。</li>
</ol>
<p>单片机执行子程序或中断服务程序时, 需要保护现场, 即将PC当前的值压栈保存, 当子程序或中断服务程序运行结束后再进行出栈。(所以如果子程序修改了栈的内容, 在子程序运行结束后程序有可能会运行错误)。</p>
<p><strong>PC是16字节寄存器</strong>, 所以SP需要加2, 以此分别保存PC的高、低8位的数据。</p>
<p><code>LCALL addr16</code>这条指令占3字节, 其中addr16占两字节, 因此程序可跳转64KB范围内的地址。</p>
<p>(<code>ACALL</code>指令只能跳转当前所在的<strong>2K范围内</strong>的地址, 如果不涉及到片外数据存储器的话, 通常只用<code>SJMP</code>和<code>AJMP</code>)</p>
<blockquote>
<p>在网上搜到的答案「将<code>3500H</code>送入PC」是错误的, 实际是将<code>20A0H</code>送入PC, 因为DELAY所在的地址为<code>20A0H</code>, 和<code>3500H</code>一点关系都没有。</p>
</blockquote>
<ol start="12">
<li><code>MOVC</code>访问 <strong>程序(ROM)</strong> 存储器, <code>MOVX</code>指令访问 <strong>外部数据</strong> 存储器。</li>
</ol>
<p><code>MOVC</code>为查表指令, 只有<code>MOVC @A+PC</code>和<code>MOVC @A+DPTR</code>这两条, 均为单字节指令。</p>
<p><code>MOVX</code>用于累加器A与外部数据存储器进行传送。</p>
<p>可以是<code>MOVX A, @DPTR</code>, <code>MOVX A, @Ri</code>, <code>MOVX @DPTR, A</code>, <code>MOVX @Ri, A</code>，其中i为0或1.</p>
<p>当使用<code>MOVX @Ri</code>类指令时，只有P0口用来传送地址和数据，P2口的状态不会发生改变，因此可使用<code>MOV P2, #12H</code>指令设定高8位的地址。</p>
<p>当采用Ri作间接寻址时, 只能寻找片外256个单元的数据存储器, 此时8位地址和数据均由P0口传送，P2口的状态不发生改变。</p>
<ol start="13">
<li>假设指令<code>DJNZ R7, rel</code>位于<code>005FH</code>, 如果在执行该指令前寄存器R7值为<code>00H</code>, 偏移量rel为<code>02H</code>, 则该指令执行后下一条要执行的指令所在的地址是<code>005FH</code>。</li>
</ol>
<p><code>DJNZ R7, rel</code>位于<code>005FH</code>, 该指令长度为<strong>2字节</strong> (书上写的3字节是错的), 所以在执行这条指令开始时PC值在原来的基础上 + 2 变为<code>0061H</code>。又因为rel为<code>02H</code>, 所以执行这条指令后, PC值变为<code>0063H</code>。</p>
<ol start="14">
<li>分析下面子程序的功能, 假设8051单片机的震荡频率为6MHz。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">DL:</span> <span class="nf">MOV</span> <span class="no">R7</span><span class="p">,</span> <span class="c1">#0AH
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">L0:</span> <span class="nf">MOV</span> <span class="no">R6</span><span class="p">,</span> <span class="c1">#250
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">L1:</span> <span class="nf">NOP</span>
</span></span><span class="line"><span class="cl">     <span class="nf">NOP</span>
</span></span><span class="line"><span class="cl">     <span class="nf">DJNZ</span> <span class="no">R6</span><span class="p">,</span> <span class="no">L1</span>
</span></span><span class="line"><span class="cl">     <span class="nf">DJNZ</span> <span class="no">R7</span><span class="p">,</span> <span class="no">L0</span>
</span></span><span class="line"><span class="cl">     <span class="nf">RET</span>
</span></span></code></pre></div><p>R7为10, R6为250, 因此两个<code>NOP</code>加上一个<code>DJNZ</code>一共循环了250次, 该250次的循环一共执行了10次。</p>
<p><code>NOP</code>为1周期指令, <code>DJNZ</code>为2周期指令, 两个<code>NOP</code>加一个<code>DJNZ</code>共4周期。</p>
<p>6MHz下一个机器周期为<span class="has-mathjax">\(12 \div (6 \times 10^6)= 2{\mu}s\)</span>, 12MHz下一个机器周期为1微秒。</p>
<p>故程序该子程序延时了<span class="has-mathjax">\((4 \times 250 \times 10 \times 12) \div (6 \times 10^6) = 20(ms)\)</span></p>
<p>(实际上有10次<code>MOV R6, #250</code>和10次<code>DJNZ R7, L0</code>造成的30个机器周期的约0.6ms的误差)</p>
<hr>
<blockquote>
<p>以下部分写于2020年11月25日</p>
</blockquote>
<h2 id="汇编语言程序">汇编语言程序</h2>
<ol>
<li>
<p>编写一个子程序, 将内部RAM 40H~4FH的内容复制到50H~5FH。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">COPY:</span> <span class="nf">MOV</span> <span class="no">R0</span><span class="p">,</span> <span class="c1">#40H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">MOV</span> <span class="no">R1</span><span class="p">,</span> <span class="c1">#50H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">MOV</span> <span class="no">R2</span><span class="p">,</span> <span class="c1">#10H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">; 40H~4FH一共复制了16次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">LOOP:</span>
</span></span><span class="line"><span class="cl">      <span class="nf">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">R0</span>
</span></span><span class="line"><span class="cl">      <span class="nf">MOV</span> <span class="err">@</span><span class="no">R1</span><span class="p">,</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl">      <span class="nf">INC</span> <span class="no">R0</span>
</span></span><span class="line"><span class="cl">      <span class="nf">INC</span> <span class="no">R1</span>
</span></span><span class="line"><span class="cl">      <span class="nf">DJNZ</span> <span class="no">R2</span><span class="p">,</span> <span class="no">LOOP</span>
</span></span><span class="line"><span class="cl">      <span class="nf">RET</span>
</span></span></code></pre></div><p>因为没有<code>MOV @RX, @RX</code>这条指令, 所以用A做数据的中转站。</p>
</li>
<li>
<p>将任何无符号8位二进制数转换为BCD码的子程序, 入口参数为内部RAM单元20H, 出口参数为内部RAM单元30H和31H, 30H存放百位数, 31H存放十位数和个位数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">CV:</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">R0</span><span class="p">,</span> <span class="c1">#20H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">R0</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">B</span><span class="p">,</span> <span class="c1">#100
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">DIV</span> <span class="no">AB</span><span class="c1">; A除以100, 得到的百位数存在A中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="mi">30</span><span class="no">H</span><span class="p">,</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="no">B</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">B</span><span class="p">,</span> <span class="c1">#10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">DIV</span> <span class="no">AB</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">SWAP</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl"><span class="nf">ADD</span> <span class="no">A</span><span class="p">,</span> <span class="no">B</span><span class="c1">; 也可以用ORL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="mi">31</span><span class="no">H</span><span class="p">,</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl"><span class="nf">RET</span>
</span></span></code></pre></div><p><code>DIV AB</code>和<code>MUL AB</code>的A和B之间没有逗号。</p>
</li>
<li>
<p>内部RAM 30H单元存放两位十进制数 (压缩BCD码), 编写将该十进制数转换为对应ASCII码的子程序, 转换结果存放到内部RAM 40H (十位数) 和41H (个位数) 单元。</p>
<blockquote>
<p>ASCII码： <code>30H</code>为<code>0</code>, <code>41H</code>为<code>A</code>, <code>61H</code>为<code>a</code></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">CV:</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="mi">30</span><span class="no">H</span>
</span></span><span class="line"><span class="cl"><span class="nf">ANL</span> <span class="no">A</span><span class="p">,</span> <span class="c1">#0FH
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="no">DPTR</span><span class="p">,</span> <span class="c1">#DATA; 或者直接用ADD A, #30H即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOVC</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">A</span><span class="err">+</span><span class="no">DPTR</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="mi">41</span><span class="no">H</span><span class="p">,</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="mi">30</span><span class="no">H</span>
</span></span><span class="line"><span class="cl"><span class="nf">SWAP</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl"><span class="nf">ANL</span> <span class="no">A</span><span class="p">,</span> <span class="c1">#0FH
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOVC</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">A</span><span class="err">+</span><span class="no">DPTR</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="mi">40</span><span class="no">H</span><span class="p">,</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">RET</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">DATA:</span>
</span></span><span class="line"><span class="cl"><span class="nf">DB</span> <span class="mi">30</span><span class="no">H</span><span class="p">,</span> <span class="mi">31</span><span class="no">H</span><span class="p">,</span> <span class="mi">32</span><span class="no">H</span><span class="p">,</span> <span class="mi">33</span><span class="no">H</span><span class="p">,</span> <span class="mi">34</span><span class="no">H</span><span class="p">,</span> <span class="mi">35</span><span class="no">H</span><span class="p">,</span> <span class="mi">36</span><span class="no">H</span><span class="p">,</span> <span class="mi">37</span><span class="no">H</span><span class="p">,</span> <span class="mi">38</span><span class="no">H</span><span class="p">,</span> <span class="mi">39</span><span class="no">H</span>
</span></span></code></pre></div></li>
<li>
<p>8个8位数相加, 求平均值, 入口地址为<code>30H</code>~<code>37H</code>, 结果存到<code>40H</code>。</p>
<p>把8位数相加存在溢出, 所以把相加结果以16进制存到R2、R3中, 再除以8( 右移3次), 即可求得不四舍五入的平均值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">R0</span><span class="p">,</span> <span class="c1">#30H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="no">R1</span><span class="p">,</span> <span class="c1">#08H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="no">R2</span><span class="p">,</span> <span class="c1">#00H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="no">R3</span><span class="p">,</span> <span class="c1">#00H
</span></span></span><span class="line"><span class="cl"><span class="c1">; 初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">LOOP:</span>
</span></span><span class="line"><span class="cl"><span class="nf">CLR</span> <span class="no">C</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">R0</span>
</span></span><span class="line"><span class="cl"><span class="nf">ADD</span> <span class="no">A</span><span class="p">,</span> <span class="no">R3</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">R3</span><span class="p">,</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl"><span class="nf">JNC</span> <span class="no">SKIP</span>
</span></span><span class="line"><span class="cl"><span class="nf">INC</span> <span class="no">R2</span>
</span></span><span class="line"><span class="cl"><span class="nl">SKIP:</span>
</span></span><span class="line"><span class="cl"><span class="nf">INC</span> <span class="no">R0</span>
</span></span><span class="line"><span class="cl"><span class="nf">DJNZ</span> <span class="no">R1</span><span class="p">,</span> <span class="no">LOOP</span>
</span></span></code></pre></div><p>这样结果被保存到R2、R3中, 然后需要写一个循环右移3位的程序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">R4</span><span class="p">,</span> <span class="c1">#03H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">LOOP2:</span>
</span></span><span class="line"><span class="cl"><span class="nf">RRC</span> <span class="no">R2</span>
</span></span><span class="line"><span class="cl"><span class="nf">RRC</span> <span class="no">R3</span>
</span></span><span class="line"><span class="cl"><span class="nf">DJNZ</span> <span class="no">R4</span><span class="p">,</span> <span class="no">LOOP2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="mi">40</span><span class="no">H</span><span class="p">,</span> <span class="no">R3</span>
</span></span><span class="line"><span class="cl"><span class="c1">; 右移3次后R2的低4位为0, 结果保存在R3中
</span></span></span></code></pre></div><p>这样R3中求得的是不带四舍五入的结果。</p>
<p>如果需要带四舍五入的话第一种方法是判断最后一次右移时最低位是否为<span class="has-mathjax">\(1\)</span>，<span class="has-mathjax">\((1 / 2 = 0.5)\)</span>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">R4</span><span class="p">,</span> <span class="c1">#03H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">LOOP2:</span>
</span></span><span class="line"><span class="cl"><span class="nf">RRC</span> <span class="no">R2</span>
</span></span><span class="line"><span class="cl"><span class="nf">RRC</span> <span class="no">R3</span>
</span></span><span class="line"><span class="cl"><span class="nf">DJNZ</span> <span class="no">R4</span><span class="p">,</span> <span class="no">LOOP2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">JNC</span> <span class="no">SKIP2</span>
</span></span><span class="line"><span class="cl"><span class="nf">INC</span> <span class="no">R3</span>
</span></span><span class="line"><span class="cl"><span class="nl">SKIP2:</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="mi">40</span><span class="no">H</span><span class="p">,</span> <span class="no">R3</span>
</span></span><span class="line"><span class="cl"><span class="c1">; 右移3次后R2肯定为0
</span></span></span></code></pre></div><p>这样是带四舍五入的结果。</p>
<p>第二种方法，8个8位数相加求平均值，要求四舍五入的话，只需要在这8个数求和后再加4（<code>0100B</code>），之后右移3次。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">ADD</span> <span class="no">A</span><span class="p">,</span> <span class="c1">#04H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="no">R3</span><span class="p">,</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl"><span class="nf">JNC</span> <span class="no">SKIP2</span>
</span></span><span class="line"><span class="cl"><span class="nf">INC</span> <span class="no">R2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">SKIP2:</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">R4</span><span class="p">,</span> <span class="c1">#03H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">LOOP2:</span>
</span></span><span class="line"><span class="cl"><span class="nf">RRC</span> <span class="no">R2</span>
</span></span><span class="line"><span class="cl"><span class="nf">RRC</span> <span class="no">R3</span>
</span></span><span class="line"><span class="cl"><span class="nf">DJNZ</span> <span class="no">R4</span><span class="p">,</span> <span class="no">LOOP2</span>
</span></span></code></pre></div><p>结果保存在R3中。</p>
</li>
</ol>
<hr>
<h2 id="中断系统">中断系统</h2>
<ol>
<li>
<p>8051的外部中断有低电平触发和下降沿触发两种触发方式。外部中断1的中断向量地址是<code>0013H</code>。</p>
<p>在响应中断时, 单片机自动生成一条长调用指令<code>LCALL addr16</code>, 其地址为中断入口地址。</p>
<table>
<thead>
<tr>
<th style="text-align:center">中断源</th>
<th style="text-align:center">入口地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">INT0</td>
<td style="text-align:center">0003H</td>
</tr>
<tr>
<td style="text-align:center">T0</td>
<td style="text-align:center">000BH</td>
</tr>
<tr>
<td style="text-align:center">INT1</td>
<td style="text-align:center">0013H</td>
</tr>
<tr>
<td style="text-align:center">T1</td>
<td style="text-align:center">001BH</td>
</tr>
<tr>
<td style="text-align:center">串行口</td>
<td style="text-align:center">0023H</td>
</tr>
</tbody>
</table>
<p>通常在中断入口地址处放一条<strong>无条件转移指令</strong><code>*JMP</code>。</p>
<p>内部查询顺序同入口地址的顺序，由高到低。</p>
</li>
<li>
<p>执行指令<code>MOV IP, #0BH</code>( <code>#00001011B</code>)后, 中断优先级最高者为<code>PX0</code>, 最低为<code>PS</code>。</p>
<p>IP: 中断优先级寄存器, 其前3为无意义, 后5位( IP.4至IP.0)为：<code>PS</code>, <code>PT1</code>, <code>PX1</code>, <code>PT0</code>, <code>PX0</code>, 分别对应串行口、定时器T1、外部中断1、定时器0、外部中断0。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">D7</th>
<th style="text-align:center">D6</th>
<th style="text-align:center">D5</th>
<th style="text-align:center">D4</th>
<th style="text-align:center">D3</th>
<th style="text-align:center">D2</th>
<th style="text-align:center">D1</th>
<th style="text-align:center">D0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IP</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">PS</td>
<td style="text-align:center">PT1</td>
<td style="text-align:center">PX1</td>
<td style="text-align:center">PT0</td>
<td style="text-align:center">PX0</td>
</tr>
</tbody>
</table>
<p>单片机复位以后, IP的内容为0, 各个中断源均为低优先级中断。</p>
<p>在同时收到几个同一优先级的中断请求时, 中断响应取决于内部查询顺序, 其顺序由高到低为：<code>INT0</code>、<code>T0</code>、<code>INT1</code>、<code>T1</code>、<code>串行口</code>。</p>
<p>当中断源均为同一优先级时, 当它们同时申请中断时CPU首先响应外部中断0</p>
</li>
<li>
<p>8051的晶振频率为12MHz, 则最短的外部中断响应时间为3<span class="has-mathjax">\(\mu\)</span>s, 最长的外部中断响应时间为12<span class="has-mathjax">\(\mu\)</span>。</p>
</li>
<li>
<p>中断标记位于单片机寄存器的<code>TCON</code>和<code>SCON</code>中。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">D7</th>
<th style="text-align:center">D6</th>
<th style="text-align:center">D5</th>
<th style="text-align:center">D4</th>
<th style="text-align:center">D3</th>
<th style="text-align:center">D2</th>
<th style="text-align:center">D1</th>
<th style="text-align:center">D0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TCON</td>
<td style="text-align:center">TF1</td>
<td style="text-align:center">TR1</td>
<td style="text-align:center">TF0</td>
<td style="text-align:center">TR0</td>
<td style="text-align:center">IE1</td>
<td style="text-align:center">IT1</td>
<td style="text-align:center">IE0</td>
<td style="text-align:center">IT0</td>
</tr>
<tr>
<td style="text-align:center">SCON</td>
<td style="text-align:center">SM0</td>
<td style="text-align:center">SM1</td>
<td style="text-align:center">SM2</td>
<td style="text-align:center">REN</td>
<td style="text-align:center">TB8</td>
<td style="text-align:center">RB8</td>
<td style="text-align:center">TI</td>
<td style="text-align:center">RI</td>
</tr>
</tbody>
</table>
<p><code>TCON</code>中<code>TF1</code>和<code>TF0</code>为定时器/计数器中断标志位, <code>TR1</code>和<code>TR0</code>为定时/计数启动位, <code>IE1</code>和<code>IE0</code>为外部中断标志位, <code>IT1</code>和<code>IT0</code>为选择外部中断为边沿触发(1)还是电平触发(0)方式。</p>
<p><code>SCON</code>中前几位与串行口有关，第1位和第2位的<code>TI</code>和<code>RI</code>(是大写字母I不是数字1)分别为串行口中断发送中断请求标志位(发送成功后置1)和接受中断请求标志位( 接受成功后置1)。串口中断无法硬件清零, 只能软件清零。</p>
<p>当IE中EA为1、ES为1时，TI或RI为1时，CPU执行无条件转移指令<code>LJMP 0023H</code>, 执行串行口中断服务程序。</p>
</li>
<li>
<p>要使8051能够响应定时器T1的中断和串行口中断, 不响应其他中断, 则中断允许寄存器<code>IE</code>的内容为<code>98H</code>(<code>10011000B</code>)。</p>
<p>中断允许寄存器IE：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">D7</th>
<th style="text-align:center">D6</th>
<th style="text-align:center">D5</th>
<th style="text-align:center">D4</th>
<th style="text-align:center">D3</th>
<th style="text-align:center">D2</th>
<th style="text-align:center">D1</th>
<th style="text-align:center">D0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IE</td>
<td style="text-align:center">EA</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">ES</td>
<td style="text-align:center">ET1</td>
<td style="text-align:center">EX1</td>
<td style="text-align:center">ET0</td>
<td style="text-align:center">EX0</td>
</tr>
</tbody>
</table>
<p><code>EA</code>为总控制位, 当<code>EA</code>为1时, CPU才可以响应中断请求。</p>
<p><code>ES</code>为串行口中断允许位, <code>ET1</code>和<code>ET0</code>为定时器中断允许位, <code>EX1</code>和<code>EX0</code>为外部中断允许位。</p>
</li>
</ol>
<hr>
<h2 id="定时器和计数器">定时器和计数器</h2>
<ol>
<li>
<p>使T0工作方式1的溢出周期最长的初值是<code>0000H</code>。</p>
<p>定时器/计数器工作在方式0为13位计数器, 由<code>TLX</code>的低5位和<code>THX</code>的高8位组成13位计数器, 最大值为<span class="has-mathjax">\(2^{13}-1 = 8191\)</span>, 晶振频率12MHz下计时周期最长为8.192ms。工作在方式1时由均为8位的<code>TLX</code>和<code>THX</code>组成16位计数器, 最大值为65535, 晶振频率为12M下最长为65.536ms。</p>
<p>当定时器/计数器工作在方式2时, 可以循环定时/计数。当计数溢出后, 自动将8位的<code>THX</code>装入8位的<code>TLX</code>中, 可省去重装初值的时间, 最大值为<code>255</code>, 晶振频率12M下计时周期最长为0.256ms。</p>
</li>
<li>
<p><code>T1</code>配置为方式3时, 停止计数, 方式3只适用于定时器0。</p>
<p>定时器<code>T0</code>的方式3将其分为两个8位定时器, 其中<code>TH0</code>只能做定时器使用。</p>
</li>
<li>
<p>设8051单片机的晶振频率为12MHz, 定时器作计数器使用时, 其计数输入信号的最高频率为500KHz。</p>
<p>当定时器用作计数器时, 当检测到引脚上的负跳变时计数器的值增一。检测下降沿需要2个机器周期, 即24个震荡周期, 所以输入信号最高频率为 <span class="has-mathjax">\(12M \div 24 = 500KHz\)</span>。</p>
</li>
<li>
<p>用定时器方式2扩展一个下降沿触发的外部中断, 计数初值应为<code>FFH</code>。</p>
<p>此处定时器2以计数器方式运行, 当检测到一个下降沿后, 计数器加一后溢出, 因此会执行定时器中断的中断子程序。</p>
</li>
</ol>
<hr>
<blockquote>
<p>2020年12月3日：
前两天感冒, 休息了几天(<del>打了两天的游戏</del>)后继续。</p>
</blockquote>
<h2 id="串行口">串行口</h2>
<ol>
<li>
<p>串行口TXD为高电平, 表示这是数据位或停止位或空闲状态。</p>
<p>串行口工作在方式1时, <code>TXD</code>用来发送数据、<code>RXD</code>用来接受数据。方式1的一帧数据为10位, 起始为为0, 停止位为1, 数据位和空闲状态均可能为0或1。</p>
</li>
<li>
<p>串行口工作在方式3时, 发送的第9位数据要事先写入寄存器<code>SCON</code>的<code>TB8</code>, 接收的第9位数据被写入同一寄存器的<code>RB8</code>。</p>
<p>串行口控制寄存器SCON：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">D7</th>
<th style="text-align:center">D6</th>
<th style="text-align:center">D5</th>
<th style="text-align:center">D4</th>
<th style="text-align:center">D3</th>
<th style="text-align:center">D2</th>
<th style="text-align:center">D1</th>
<th style="text-align:center">D0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SCON</td>
<td style="text-align:center">SM0</td>
<td style="text-align:center">SM1</td>
<td style="text-align:center">SM2</td>
<td style="text-align:center">REN</td>
<td style="text-align:center">TB8</td>
<td style="text-align:center">RB8</td>
<td style="text-align:center">TI</td>
<td style="text-align:center">RI</td>
</tr>
</tbody>
</table>
<p>其中<code>SM0</code>、<code>SM1</code>为串口的工作方式选择位, 方式0为同步移位寄存器方式, 方式1为8位异步收发, 方式2和方式3为9位异步收发。</p>
<p>波特率：串行口每秒钟传送的比特位数，单位bits/s。</p>
<p>方式0的波特率<strong>固定</strong>为 <span class="has-mathjax">\(f_{osc}/12\)</span>, 方式2的波特率为 <span class="has-mathjax">\(f_{osc}/64\)</span> 或 <span class="has-mathjax">\(f_{osc}/32\)</span> (由SMOD控制)。</p>
<p>方式1的波特率和方式3的波特率可变, 公式为 <span class="has-mathjax">\((2^{SMOD} / 32) \times 定时器T1的溢出率\)</span>。</p>
<p>T1的溢出率为定时器T1的周期的倒数，定时器的周期为</p>
<div class="has-mathjax">
  
   $$T = \frac{12\times (2^n - X )}{f\_{osc}}$$
   
</div>
<p>当T1工作在方式2时，n为8，波特率为：</p>
<div class="has-mathjax">
  
   $$波特率=\frac{(2^{SMOD} \div 32) \times f_{osc}}{12 \times (256 - X)}$$
   
</div>
<p><span class="has-mathjax">\(X\)</span>为定时器T1的初值。</p>
<p>串口工作在方式1，波特率为2400，则每秒钟最大能发送/接收 <span class="has-mathjax">\(2400 \div 10 = 240Byte\)</span> 的数据。</p>
<blockquote>
<p>单片机工作在方式1时, 1帧数据为1个起始位、8个数据位、1个停止位共10位。</p>
</blockquote>
<p>8051的UART工作在方式3，要求每秒钟能传送不少于900个字节的数据，则波特率应当大于 <span class="has-mathjax">\(900 \times 8 = 7200bits/s\)</span>。</p>
</li>
<li>
<p>比特率2400Kbits/s，时钟频率12M，PC机发送8个字节的数据存到单片机的<code>30H-37H</code>中，随后单片机发送2个确认字节<code>55H</code>和<code>AAH</code>给PC机，使用查询方式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">ORG</span> <span class="mi">0000</span><span class="no">H</span>
</span></span><span class="line"><span class="cl"><span class="nl">MAIN:</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">SCON</span><span class="p">,</span> <span class="c1">#50H
</span></span></span><span class="line"><span class="cl"><span class="c1">; 串口使用方式1，且允许接收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="no">PCON</span><span class="p">,</span> <span class="c1">#00H
</span></span></span><span class="line"><span class="cl"><span class="c1">; 波特率不加倍
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="no">TMOD</span><span class="p">,</span> <span class="c1">#20H
</span></span></span><span class="line"><span class="cl"><span class="c1">; 定时器1使用方式2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">TL1</span><span class="p">,</span> <span class="c1">#0F3H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="no">TH1</span><span class="p">,</span> <span class="c1">#0F3H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">SETB</span> <span class="no">TR1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">LOOP:</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">R0</span><span class="p">,</span> <span class="c1">#30H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="no">R1</span><span class="p">,</span> <span class="c1">#08H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">REC:</span>
</span></span><span class="line"><span class="cl"><span class="nf">JNB</span> <span class="no">RI</span><span class="p">,</span> <span class="no">$</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="err">@</span><span class="no">R0</span><span class="p">,</span> <span class="no">SBUF</span>
</span></span><span class="line"><span class="cl"><span class="nf">CLR</span> <span class="no">RI</span> <span class="c1">; 软件清零RI
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">INC</span> <span class="no">R0</span>
</span></span><span class="line"><span class="cl"><span class="nf">DJNZ</span> <span class="no">R1</span><span class="p">,</span> <span class="no">REC</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">SBUF</span><span class="p">,</span> <span class="c1">#55H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">JNB</span> <span class="no">TI</span><span class="p">,</span> <span class="no">$</span>
</span></span><span class="line"><span class="cl"><span class="nf">CLR</span> <span class="no">TI</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">SBUF</span><span class="p">,</span> <span class="c1">#0AAH
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">JNB</span> <span class="no">TI</span><span class="p">,</span> <span class="no">$</span>
</span></span><span class="line"><span class="cl"><span class="nf">CLR</span> <span class="no">TI</span>
</span></span><span class="line"><span class="cl"><span class="nf">AJMP</span> <span class="no">LOOP</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">END</span>
</span></span></code></pre></div><p>单片机接收到数据后，RI被置1，代表SBUF中的数据有效，取走SBUF中的数据后需要软件清零RI（串口中断不会自动清零RI）。</p>
<p>当单片机执行写SBUF操作时，串口发送开始，TI被自动置1，在发送完成后TI被自动清0。</p>
</li>
</ol>
<hr>
<blockquote>
<p>2020年12月7日：</p>
</blockquote>
<h2 id="io口--外部存储器拓展">I/O口 &amp; 外部存储器拓展</h2>
<ol>
<li>
<p>8051使用指令<code>MOVX A, @R0</code>读外部数据存储器时，不起作用的信号是<code>WR</code>。</p>
<p>8051在使用<code>MOVX @DPTR</code>类指令读外部数据存储器时，P0和P2先输出外部数据的地址，单片机发出的<code>ALE</code>信号的负跳沿将P0口输出的地址锁存在地址锁存器(74HC573)里，之后单片机发出<code>RD</code>信号，读取外部数据存储器（RAM）的数据到总线再传送到P0口上。最后单片机从P0口读取数据保存到A中。</p>
<p>如果是写外部数据存储器时，单片机将不发出<code>RD</code>信号而是<code>WR</code>信号，将A中的数据写入外部数据存储器中。</p>
</li>
<li>
<p>存储器芯片6264需要13根地址线。</p>
<p>62256的容量为 <span class="has-mathjax">\(256Kbit \div 8 = 32KB = 2^{15}\)</span>, 需要15根地址线。</p>
<p>6264的容量为 <span class="has-mathjax">\(64Kbit \div 8 = 8KB = 2^{13}\)</span>，所以需要13根地址线。</p>
<p>6116容量为 <span class="has-mathjax">\(16Kbit \div 8 = 2KB = 2^{11}\)</span>, 需要11根地址线。</p>
<p>计算方法是62 <span class="has-mathjax">\(X\)</span> 的 <span class="has-mathjax">\(容量=X \div 8(K)\)</span>。</p>
</li>
<li>
<p>使用16位地址模式时，8051的外部数据存储器寻址空间为64KB。</p>
</li>
<li>
<p>基于8051的单片机系统能拓展的外部数据存储器容量无限制。</p>
<p>有的书上说最大只能拓展64KB，实际是最大寻址空间为64KB，拓展的外部数据存储器容量无限制。</p>
</li>
<li>
<p>8051的程序存储器可用来存放用户程序和数据。 例如使用<code>DW</code>或<code>DB</code>指令用来定义数据。</p>
<p>所以应用程序也可以使用<code>MOVC A, @A+DPTR</code>访问程序存储器中的数据。</p>
</li>
</ol>
<blockquote>
<p>除此之外LED数码管和外部存储器拓展、外部I/O设备拓展部分有很多需要根据线路图计算地址和DA转换的题，因为线路图源自老师提供的PDF，而老师为PDF加了密码，意味着不允许外传，所以我就不放到博客上面了，<del>除非我自己用Porteus画一个类似的</del></p>
</blockquote>
<ol start="6">
<li>
<p>LED段码入口地址8004H，位选入口地址8002H，将30H-32H保存的6个压缩BCD码发送到6位共阴极数码管上显示， 要求编写延时1ms的子程序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">MAIN:</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">R0</span><span class="p">,</span> <span class="c1">#30H
</span></span></span><span class="line"><span class="cl"><span class="c1">; R2用来计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="no">R2</span><span class="p">,</span> <span class="c1">#03H
</span></span></span><span class="line"><span class="cl"><span class="c1">; R3用来位选
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="no">R3</span><span class="p">,</span> <span class="c1">#01H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">LOOP:</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">R0</span>
</span></span><span class="line"><span class="cl"><span class="nf">SWAP</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl"><span class="nf">ANL</span> <span class="no">A</span><span class="p">,</span> <span class="c1">#0FH
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="no">DPTR</span><span class="p">,</span> <span class="c1">#TAB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOVC</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">A</span><span class="err">+</span><span class="no">DPTR</span>
</span></span><span class="line"><span class="cl"><span class="c1">; 取高4位BCD码对应的段码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">DPTR</span><span class="p">,</span> <span class="c1">#8004H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOVX</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">A</span><span class="err">+</span><span class="no">DPTR</span>
</span></span><span class="line"><span class="cl"><span class="c1">; 先送段码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="no">R3</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">DPTR</span><span class="p">,</span> <span class="c1">#8002H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOVX</span> <span class="err">@</span><span class="no">DPTR</span><span class="p">,</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl"><span class="nf">RL</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">R3</span><span class="p">,</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl"><span class="c1">; 再送位选
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">LCALL</span> <span class="no">DELAY</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">R0</span>
</span></span><span class="line"><span class="cl"><span class="nf">ANL</span> <span class="no">A</span><span class="p">,</span> <span class="c1">#0FH
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="no">DPTR</span><span class="p">,</span> <span class="c1">#TAB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOVC</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">A</span><span class="err">+</span><span class="no">DPTR</span>
</span></span><span class="line"><span class="cl"><span class="c1">; 取低4位BCD码对应的段码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">DPTR</span><span class="p">,</span> <span class="c1">#8004H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOVX</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">A</span><span class="err">+</span><span class="no">DPTR</span>
</span></span><span class="line"><span class="cl"><span class="c1">; 送段码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="no">R3</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">DPTR</span><span class="p">,</span> <span class="c1">#8002H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOVX</span> <span class="err">@</span><span class="no">DPTR</span><span class="p">,</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl"><span class="nf">RL</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">R3</span><span class="p">,</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl"><span class="c1">; 送位选
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">LCALL</span> <span class="no">DELAY</span>
</span></span><span class="line"><span class="cl"><span class="nf">INC</span> <span class="no">R0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">DJNZ</span> <span class="no">R2</span><span class="p">,</span> <span class="no">LOOP</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">DELAY:</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">R7</span><span class="p">,</span> <span class="c1">#250
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">DL:</span>
</span></span><span class="line"><span class="cl"><span class="nf">NOP</span>
</span></span><span class="line"><span class="cl"><span class="nf">NOP</span>
</span></span><span class="line"><span class="cl"><span class="nf">DJNZ</span> <span class="no">R7</span><span class="p">,</span> <span class="no">DL</span>
</span></span><span class="line"><span class="cl"><span class="nf">RET</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">TAB:</span>
</span></span><span class="line"><span class="cl"><span class="nf">DB</span> <span class="mi">3</span><span class="no">FH</span><span class="p">,</span> <span class="mi">06</span><span class="no">H</span><span class="p">,</span> <span class="mi">5</span><span class="no">BH</span><span class="p">,</span> <span class="mi">4</span><span class="no">FH</span><span class="p">,</span> <span class="mi">66</span><span class="no">H</span><span class="p">,</span> <span class="mi">6</span><span class="no">DH</span><span class="p">,</span> <span class="mi">7</span><span class="no">DH</span><span class="p">,</span> <span class="mi">07</span><span class="no">H</span><span class="p">,</span> <span class="mi">7</span><span class="no">FH</span><span class="p">,</span> <span class="mi">6</span><span class="no">FH</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">END</span>
</span></span></code></pre></div></li>
<li>
<p>打印机数据输入接口和P1直接相连，STB接口和P3.4相连，BUSY接口和P3.3相连，不使用ACK应答信号，编写将外部存储器<code>1000H-100FH</code>的数据发送到打印机打印的子程序。</p>
<p><img loading="lazy" src="images/1.jpg#center" alt="" />

</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">PRINT:</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">DPTR</span><span class="p">,</span> <span class="c1">#1000H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="no">R2</span><span class="p">,</span> <span class="c1">#10H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">LOOP:</span>
</span></span><span class="line"><span class="cl"><span class="nf">JB</span> <span class="no">P3.3</span><span class="p">,</span> <span class="no">$</span>
</span></span><span class="line"><span class="cl"><span class="c1">; 确保打印机处于空闲状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOVX</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">DPTR</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">P1</span><span class="p">,</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl"><span class="nf">CLR</span> <span class="no">P3.4</span>
</span></span><span class="line"><span class="cl"><span class="nf">SETB</span> <span class="no">P3.4</span>
</span></span><span class="line"><span class="cl"><span class="nf">INC</span> <span class="no">DPTR</span>
</span></span><span class="line"><span class="cl"><span class="nf">DJNZ</span> <span class="no">R2</span><span class="p">,</span> <span class="no">LOOP</span>
</span></span><span class="line"><span class="cl"><span class="nf">RET</span>
</span></span></code></pre></div><p>如果打印机没有和P1直接相连，而是连接到数据锁存器上（74HC374），锁存器的时钟信号的入口地址为<code>A000H</code>。</p>
<p>使用堆栈保护间接寻址寄存器的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">PRINT:</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">R2</span><span class="p">,</span> <span class="c1">#10H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOV</span> <span class="no">DPTR</span><span class="p">,</span> <span class="c1">#1000H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">LOOP:</span>
</span></span><span class="line"><span class="cl"><span class="nf">JB</span> <span class="no">P3.3</span><span class="p">,</span> <span class="no">$</span>
</span></span><span class="line"><span class="cl"><span class="c1">; 确保打印机处于空闲状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">MOVX</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">DPTR</span>
</span></span><span class="line"><span class="cl"><span class="nf">PUSH</span> <span class="no">DPL</span>
</span></span><span class="line"><span class="cl"><span class="nf">PUSH</span> <span class="no">DPH</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">DPTR</span><span class="p">,</span> <span class="c1">#0A000H
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">MOVX</span> <span class="err">@</span><span class="no">DPTR</span><span class="p">,</span> <span class="no">A</span>
</span></span><span class="line"><span class="cl"><span class="nf">POP</span> <span class="no">DPH</span>
</span></span><span class="line"><span class="cl"><span class="nf">POP</span> <span class="no">DPL</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">CLR</span> <span class="no">P3.4</span>
</span></span><span class="line"><span class="cl"><span class="nf">SETB</span> <span class="no">P3.4</span>
</span></span><span class="line"><span class="cl"><span class="nf">INC</span> <span class="no">DPTR</span>
</span></span><span class="line"><span class="cl"><span class="nf">DJNZ</span> <span class="no">R2</span><span class="p">,</span> <span class="no">LOOP</span>
</span></span><span class="line"><span class="cl"><span class="nf">RET</span>
</span></span></code></pre></div></li>
</ol>
<hr>
<h2 id="sfr列表">SFR列表</h2>
<table>
<thead>
<tr>
<th style="text-align:center">87H</th>
<th style="text-align:center">D7</th>
<th style="text-align:center">D6</th>
<th style="text-align:center">D5</th>
<th style="text-align:center">D4</th>
<th style="text-align:center">D3</th>
<th style="text-align:center">D2</th>
<th style="text-align:center">D1</th>
<th style="text-align:center">D0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PCON</td>
<td style="text-align:center">SMOD</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">PD</td>
<td style="text-align:center">IDL</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">88H</th>
<th style="text-align:center">D7</th>
<th style="text-align:center">D6</th>
<th style="text-align:center">D5</th>
<th style="text-align:center">D4</th>
<th style="text-align:center">D3</th>
<th style="text-align:center">D2</th>
<th style="text-align:center">D1</th>
<th style="text-align:center">D0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TCON</td>
<td style="text-align:center">TF1</td>
<td style="text-align:center">TR1</td>
<td style="text-align:center">TF0</td>
<td style="text-align:center">TR0</td>
<td style="text-align:center">IE1</td>
<td style="text-align:center">IT1</td>
<td style="text-align:center">IE0</td>
<td style="text-align:center">IT0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">89H</th>
<th style="text-align:center">D7</th>
<th style="text-align:center">D6</th>
<th style="text-align:center">D5</th>
<th style="text-align:center">D4</th>
<th style="text-align:center">D3</th>
<th style="text-align:center">D2</th>
<th style="text-align:center">D1</th>
<th style="text-align:center">D0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TMOD</td>
<td style="text-align:center">GATE</td>
<td style="text-align:center">C/T</td>
<td style="text-align:center">M1</td>
<td style="text-align:center">M0</td>
<td style="text-align:center">GATE</td>
<td style="text-align:center">C/T</td>
<td style="text-align:center">M1</td>
<td style="text-align:center">M0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">98H</th>
<th style="text-align:center">D7</th>
<th style="text-align:center">D6</th>
<th style="text-align:center">D5</th>
<th style="text-align:center">D4</th>
<th style="text-align:center">D3</th>
<th style="text-align:center">D2</th>
<th style="text-align:center">D1</th>
<th style="text-align:center">D0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SCON</td>
<td style="text-align:center">SM0</td>
<td style="text-align:center">SM1</td>
<td style="text-align:center">SM2</td>
<td style="text-align:center">REN</td>
<td style="text-align:center">TB8</td>
<td style="text-align:center">RB8</td>
<td style="text-align:center">TI</td>
<td style="text-align:center">RI</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">A8H</th>
<th style="text-align:center">D7</th>
<th style="text-align:center">D6</th>
<th style="text-align:center">D5</th>
<th style="text-align:center">D4</th>
<th style="text-align:center">D3</th>
<th style="text-align:center">D2</th>
<th style="text-align:center">D1</th>
<th style="text-align:center">D0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IE</td>
<td style="text-align:center">EA</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">ES</td>
<td style="text-align:center">ET1</td>
<td style="text-align:center">EX1</td>
<td style="text-align:center">ET0</td>
<td style="text-align:center">EX0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">B8H</th>
<th style="text-align:center">D7</th>
<th style="text-align:center">D6</th>
<th style="text-align:center">D5</th>
<th style="text-align:center">D4</th>
<th style="text-align:center">D3</th>
<th style="text-align:center">D2</th>
<th style="text-align:center">D1</th>
<th style="text-align:center">D0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IP</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">PS</td>
<td style="text-align:center">PT1</td>
<td style="text-align:center">PX1</td>
<td style="text-align:center">PT0</td>
<td style="text-align:center">PX0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">D0H</th>
<th style="text-align:center">D7</th>
<th style="text-align:center">D6</th>
<th style="text-align:center">D5</th>
<th style="text-align:center">D4</th>
<th style="text-align:center">D3</th>
<th style="text-align:center">D2</th>
<th style="text-align:center">D1</th>
<th style="text-align:center">D0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PSW</td>
<td style="text-align:center">Cy</td>
<td style="text-align:center">Ac</td>
<td style="text-align:center">F0</td>
<td style="text-align:center">RS1</td>
<td style="text-align:center">RS0</td>
<td style="text-align:center">OV</td>
<td style="text-align:center">-</td>
<td style="text-align:center">P</td>
</tr>
</tbody>
</table>
<hr>]]></content:encoded>
    </item>
    
  </channel>
</rss>
