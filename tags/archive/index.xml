<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Archive on STARRY-S&#39; Blog</title>
    <link>https://blog.starry-s.moe/tags/archive/</link>
    <description>Recent content in Archive on STARRY-S&#39; Blog</description>
    <image>
      <title>STARRY-S&#39; Blog</title>
      <url>https://blog.starry-s.moe/avatar.png</url>
      <link>https://blog.starry-s.moe/avatar.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>© 2016 - 2023 STARRY-S | [CC BY-NC-ND 4.0](https://creativecommons.org/licenses/by-nc-nd/4.0/) | Hosted on [GitHub Pages](https://pages.github.com)</copyright>
    <lastBuildDate>Sun, 12 Nov 2023 01:35:41 +0800</lastBuildDate><atom:link href="https://blog.starry-s.moe/tags/archive/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>如何选择 zip 和 tar 文件格式</title>
      <link>https://blog.starry-s.moe/posts/2023/zip-tar/</link>
      <pubDate>Sun, 12 Nov 2023 01:35:41 +0800</pubDate>
      
      <guid>https://blog.starry-s.moe/posts/2023/zip-tar/</guid>
      <description>&lt;p&gt;最近遇到了一个归档文件格式选择的问题，于是顺手记录下来水一篇博客。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>最近遇到了一个归档文件格式选择的问题，于是顺手记录下来水一篇博客。</p>
<hr>
<h2 id="tar-文件格式">tar 文件格式</h2>
<p>tar 格式早期是为了将数据记录在磁带上的（现在貌似也可以？），这种归档格式很简单，要将一个文件写入 tar 包的时候，首先写入记录文件信息的 header，在 header 之后记录文件的数据（tar 格式不支持压缩所以是直接把文件数据拷贝在了 header 后面）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">+--------+
</span></span><span class="line"><span class="cl">| header |
</span></span><span class="line"><span class="cl">+--------+
</span></span><span class="line"><span class="cl">|  data  |
</span></span><span class="line"><span class="cl">+--------+
</span></span><span class="line"><span class="cl">| header |
</span></span><span class="line"><span class="cl">+--------+
</span></span><span class="line"><span class="cl">|  data  |
</span></span><span class="line"><span class="cl">+--------+
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">+--------+
</span></span><span class="line"><span class="cl">| header |
</span></span><span class="line"><span class="cl">+--------+
</span></span><span class="line"><span class="cl">|  data  |
</span></span><span class="line"><span class="cl">+--------+
</span></span><span class="line"><span class="cl">|  end   |
</span></span><span class="line"><span class="cl">+--------+
</span></span></code></pre></div><p>tar 有多种不同格式的 header。这里可以看 Linux 系统上常用的 <code>tar</code> 工具（GNU tar）代码，
GNU tar 中实现的 header 结构定义文档参考这个 <a href="https://www.gnu.org/software/tar/manual/html_node/Standard.html">Basic Tar Format</a>。</p>
<p>GNU tar 的源码可以通过下面的方式克隆下载下来。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> git clone https://git.savannah.gnu.org/git/tar.git
</span></span></code></pre></div><p>在 <code>src/tar.h</code> 源码中可以找到 header 结构定义，其中 <code>posix_header</code> 的定义为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">posix_header</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>				<span class="cm">/* byte offset */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>		<span class="cm">/*   0 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">mode</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>			<span class="cm">/* 100 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">uid</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>			<span class="cm">/* 108 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">gid</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>			<span class="cm">/* 116 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">size</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>		<span class="cm">/* 124 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">mtime</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>		<span class="cm">/* 136 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">chksum</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>		<span class="cm">/* 148 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">typeflag</span><span class="p">;</span>		<span class="cm">/* 156 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">linkname</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>		<span class="cm">/* 157 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">magic</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>		<span class="cm">/* 257 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">version</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>		<span class="cm">/* 263 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">uname</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>		<span class="cm">/* 265 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">gname</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>		<span class="cm">/* 297 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">devmajor</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>		<span class="cm">/* 329 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">devminor</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>		<span class="cm">/* 337 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">prefix</span><span class="p">[</span><span class="mi">155</span><span class="p">];</span>		<span class="cm">/* 345 */</span>
</span></span><span class="line"><span class="cl">				<span class="cm">/* 500 */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>上面 header 结构可以看出默认情况下文件名 <code>name</code> 长度不能超过 99 (最后一位要存储 <code>\0</code>)，但似乎后面 tar 协议支持了长文件名的情况，至于如何支持的各位感兴趣的可以自行去搜一下。</p>
<p>除了 <code>posix_header</code> 之外，还有 <code>star_header</code>、<code>gnu_header</code> 等 header 结构，header 结构体占据的空间小于 512 字节，而 tar 的每个 block 都是 512 字节，所以一个 header block 占据 512 字节，末尾空余的字节填写 <code>\0</code>，文件也以 512 字节为单位写在 header block 后面，多出来的空间填写 <code>\0</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* tar files are made in basic blocks of this size.  */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define BLOCKSIZE 512
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">union</span> <span class="n">block</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BLOCKSIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">posix_header</span> <span class="n">header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">star_header</span> <span class="n">star_header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">oldgnu_header</span> <span class="n">oldgnu_header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">sparse_header</span> <span class="n">sparse_header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">star_in_header</span> <span class="n">star_in_header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">star_ext_header</span> <span class="n">star_ext_header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>tar 文件的 end 是由至少两个 block size （1024字节）的空白（<code>\0</code>）组成，但是 GNU tar 创建出来的 tar 包的 end 长度可能大于两个 block size，因为似乎它创建的 tar 包的文件体积以 10K 为单位进行了对齐，可以用下面的方式验证一下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&#34;hello world&#34;</span> &gt; 1.txt
</span></span><span class="line"><span class="cl"><span class="gp">$</span> tar -cv 1.txt -f test.tar
</span></span><span class="line"><span class="cl"><span class="go">1.txt
</span></span></span><span class="line"><span class="cl"><span class="go"></span><span class="gp">$</span> ls -al test.tar
</span></span><span class="line"><span class="cl"><span class="go">-rw-r--r-- 1 starry-s starry-s 10K Nov 12 11:42 test.tar
</span></span></span></code></pre></div><p>用 <code>hexdump</code> 可以看一下创建的 tar 包中包含的数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> hexdump -C ./test.tar
</span></span><span class="line"><span class="cl"><span class="go">0000000   1   .   t   x   t  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">0000010  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">*
</span></span></span><span class="line"><span class="cl"><span class="go">0000060  \0  \0  \0  \0   0   0   0   0   6   4   4  \0   0   0   0   1
</span></span></span><span class="line"><span class="cl"><span class="go">0000070   7   5   0  \0   0   0   0   1   7   5   0  \0   0   0   0   0
</span></span></span><span class="line"><span class="cl"><span class="go">0000080   0   0   0   0   0   1   4  \0   1   4   5   2   4   0   4   5
</span></span></span><span class="line"><span class="cl"><span class="go">0000090   3   5   4  \0   0   1   2   1   1   2  \0       0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">00000a0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">*
</span></span></span><span class="line"><span class="cl"><span class="go">0000100  \0   u   s   t   a   r          \0   s   t   a   r   r   y   -
</span></span></span><span class="line"><span class="cl"><span class="go">0000110   s  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">0000120  \0  \0  \0  \0  \0  \0  \0  \0  \0   s   t   a   r   r   y   -
</span></span></span><span class="line"><span class="cl"><span class="go">0000130   s  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">0000140  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">*
</span></span></span><span class="line"><span class="cl"><span class="go">0000200   h   e   l   l   o       w   o   r   l   d  \n  \0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">0000210  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
</span></span></span><span class="line"><span class="cl"><span class="go">*
</span></span></span><span class="line"><span class="cl"><span class="go">0002800
</span></span></span></code></pre></div><p>其中前 <code>0x200</code> 长度 (512 bytes) 存储的是 header，<code>0x200</code> ~ <code>0x2800</code> (10240 bytes) 区域存储了文件的数据 (<code>hello world\n</code>)，文件数据后面均为空白 <code>\0</code>，整体的 tar 包文件大小对齐到了 10K。</p>
<h3 id="栗子">栗子</h3>
<p>因此这里可以用上面的 <code>posix_header</code> 结构体简单的写一个创建 tar 归档的程序。</p>
<p>因为 header 中还包含了简易的计算 header 校验和的步骤，所以代码比较长，可以在 <a href="https://github.com/STARRY-S/tar-example-c">这里</a> 找到。</p>
<h3 id="压缩">压缩</h3>
<p>在创建 tar 格式的文件时是不支持压缩的，文件的数据直接写在了 header 后面（除非你想魔改创建 tar 格式的步骤，但没这个必要）。如果需要压缩的话是把整个 tar 归档用 gzip/bzip2/zstd 等其他压缩格式进行压缩，文件后缀为 <code>tar.gz/tar.bz2/tar.zstd</code> 等。因为是先将文件写入 tar 归档，再将 tar 归档进行压缩，所以压缩的效果会比把文件单独压缩再合并成一个 tar 包效果要好一些。</p>
<h3 id="特点">特点</h3>
<p>从上面的 tar 归档文件格式可以看出，tar 包中的文件是一个一个顺序排列起来的，因此 tar 包中是允许两个相同名称的文件存在的。</p>
<p>如果想向 tar 包末尾附加新的文件的话也很简单，只需要找到末尾的 end block，将其覆盖重写新的文件的 header，之后再写入新文件的数据即可，因此向未压缩的 tar 包附加新的文件（甚至是覆盖掉末尾的一些文件）都是可行的。但是如果想向已压缩的 tar 包（例如 <code>tar.gz</code>）附加文件就不太可行了，除非先把 <code>tar.gz</code> 解压为 <code>tar</code> 格式，附加新的文件后再重新压缩成 <code>tar.gz</code>，但这样如果 tar 文件体积很大的话会造成额外的磁盘空间浪费和性能、时间的浪费。</p>
<p>还有一点是 tar 中存储的文件是顺序排列起来的，但他没有一个 index 索引记录了每个文件的 header 所处的 offset。所以如果想知道一个 tar 包里面存了哪些文件的话，要从头到尾的遍历一遍 tar 包，因此如果这个 tar 包文件体积很大且包含很多零散的小文件的话，每次都要遍历读取 tar 包中的所有 header，会很麻烦。</p>
<p>因此 tar 包不适合随机读取，未压缩的 tar 包还好，只要在首次打开文件时遍历一下把每个文件的 header 和 offset 记录下来就行，但如果是压缩过的例如 <code>tar.gz</code> 格式的压缩包，几乎就没办法随机读取（除非你得再去折腾 <code>gzip</code> 数据流，但几乎没人去这么做），如果想随机解压 <code>tar.gz</code> 中的某个文件，要从头开始先解压 <code>gzip</code> 数据流，从解压的数据流中遍历每个 tar header，在查找到待解压的文件 header 后再将其解压存储下来，麻烦得很！</p>
<p>所以 <code>tar</code> 以及 <code>tar.gz</code> 等压缩的 <code>tar</code> 归档格式通常适合用在不需要随机读取，不需要向归档末尾附加文件的场景。</p>
<h2 id="zip-文件格式">zip 文件格式</h2>
<blockquote>
<p>睡觉，明天再写。</p>
</blockquote>]]></content:encoded>
    </item>
    
  </channel>
</rss>
