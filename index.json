[{"content":"磁盘的扩容和分区的扩/缩容场景很常见，比如分区用着用着快满了，而磁盘有空闲的未分区空间，而这块区域恰好在这块分区的后面，这时可以对分区扩容。 在使用虚拟机（例如 QEMU）时，假设起初虚拟机的磁盘只创建了 20G，但用久了会存在不够用的情况，这时可以对磁盘扩容，之后再调整分区的大小。\n但是最近遇到了一个需要对磁盘缩容的场景，例如把一个 64G 的 U 盘用 dd 将整个磁盘的数据写入到一个 8G 的 U盘中（当然这个 64G U盘实际使用的分区大小不能大于前 8G）。 或者要把一个原本 50G 的 qcow2 虚拟磁盘缩小成 10G，用来制作别的镜像什么的。\n按照正常的思路，缩小磁盘空间之前要先缩小分区（还要缩小文件系统），确保分区都位于磁盘的前面，这样磁盘在截断后文件系统不会受损，大致步骤可以分为：\n缩小文件系统：例如使用 btrfs filesystem resize 缩小 BTRFS 文件系统至待缩小的分区的大小，确保文件系统的大小不超过分区大小。\n缩小分区：可以使用 fdisk 先删掉待缩小的分区，之后再重新创建新的分区，重建分区时设定新的分区的大小，且不要删除已有的 btrfs 或其他文件系统签名。这样在缩小分区的同时，不需要重新格式化，因此分区中的文件没有丢失。\n（除了 fdisk，还可以用 sfdisk，gdisk 或 parted 等工具调整分区）\n确保分区都位于磁盘的起始位置后，执行磁盘缩小的操作，将磁盘末端未使用的数据截断。\nGPT / MBR 分区表咱凭感觉来猜的话，是存储在磁盘的起始位置的，所以如果磁盘缩小时，将磁盘末端一些数据截断正常情况下应该是不会影响到存储在起始位置的分区表的。\n但是，在一些情况下，会出现缩小完磁盘空间后分区表受损的情况。\n举个栗子 首先使用 qemu-img create 创建一块 10G 的 QEMU 虚拟机磁盘。\n$ qemu-img create -f qcow2 disk1.qcow2 10G Formatting \u0026#39;disk1.qcow2\u0026#39;, fmt=qcow2 cluster_size=65536 extended_l2=off compression_type=zlib size=10737418240 lazy_refcounts=off refcount_bits=16 使用 qemu-nbd 工具将 qcow2 磁盘镜像与 Linux 内核通过 nbd 连接，这样可以在不启动 QEMU 虚拟机的情况下直接对 qcow2 磁盘分区进行操作。\n加载 nbd 内核模块，其中 max_part 参数是磁盘允许的最大分区数，默认为 0 所以这里需要把数值改大一点。\n$ sudo modprobe nbd max_part=8 将创建的 disk1.qcow2 镜像与 /dev/nbd0 连接。\n$ sudo qemu-nbd -c /dev/nbd0 ./disk1.qcow2 $ lsblk /dev/nbd0 NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS nbd0 43:0 0 10G 0 disk 使用 fdisk 初始化 GPT 分区表，并随便新建几个分区。\n咱都是 Arch Linux 用户了，fdisk 就不用我再详细说了吧。\n$ sudo fdisk /dev/nbd0 Welcome to fdisk (util-linux 2.39.2). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Device does not contain a recognized partition table. Created a new DOS (MBR) disklabel with disk identifier 0xf5c43a4b. Command (m for help): g Created a new GPT disklabel (GUID: 2EB767AB-0958-461B-B56D-697B3305AC83). Command (m for help): n Partition number (1-128, default 1): First sector (2048-20971486, default 2048): Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-20971486, default 20969471): +512M Created a new partition 1 of type \u0026#39;Linux filesystem\u0026#39; and of size 512 MiB. Command (m for help): t Selected partition 1 Partition type or alias (type L to list all): 1 Changed type of partition \u0026#39;Linux filesystem\u0026#39; to \u0026#39;EFI System\u0026#39;. Command (m for help): n Partition number (2-128, default 2): First sector (1050624-20971486, default 1050624): Last sector, +/-sectors or +/-size{K,M,G,T,P} (1050624-20971486, default 20969471): Created a new partition 2 of type \u0026#39;Linux filesystem\u0026#39; and of size 9.5 GiB. Command (m for help): w The partition table has been altered. Calling ioctl() to re-read partition table. Syncing disks. 本栗中，磁盘新建了两个分区，/dev/nbd0p1 是 512M 大小的 EFI 分区，剩余空间 /dev/nbd0p2 是 root 分区。\n$ sudo fdisk -l /dev/nbd0 Disk /dev/nbd0: 10 GiB, 10737418240 bytes, 20971520 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: gpt Disk identifier: 2EB767AB-0958-461B-B56D-697B3305AC83 Device Start End Sectors Size Type /dev/nbd0p1 2048 1050623 1048576 512M EFI System /dev/nbd0p2 1050624 20969471 19918848 9.5G Linux filesystem 之后简单的格式化一下两个分区，挂载并往里面写一些文件进去。\n$ sudo mkfs.vfat -F 32 /dev/nbd0p1 mkfs.fat 4.2 (2021-01-31) $ sudo mkfs.btrfs /dev/nbd0p2 btrfs-progs v6.5.2 See https://btrfs.readthedocs.io for more information. Performing full device TRIM /dev/nbd0p2 (9.50GiB) ... NOTE: several default settings have changed in version 5.15, please make sure this does not affect your deployments: - DUP for metadata (-m dup) - enabled no-holes (-O no-holes) - enabled free-space-tree (-R free-space-tree) Label: (null) UUID: a5fb30e5-eb5f-4a0b-8d2a-106e04e1488b Node size: 16384 Sector size: 4096 Filesystem size: 9.50GiB Block group profiles: Data: single 8.00MiB Metadata: DUP 256.00MiB System: DUP 8.00MiB SSD detected: yes Zoned device: no Incompat features: extref, skinny-metadata, no-holes, free-space-tree Runtime features: free-space-tree Checksum: crc32c Number of devices: 1 Devices: ID SIZE PATH 1 9.50GiB /dev/nbd0p2 $ mkdir -p mnt $ sudo mount /dev/nbd0p2 mnt $ sudo mkdir ./mnt/{boot,home} $ sudo mount /dev/nbd0p1 mnt/boot $ sudo touch ./mnt/example.txt 使用 btrfs filesystem resize 缩小 root 分区中的 BTRFS 文件系统大小至 7G，之后使用 fdisk 缩小 root 分区大小至 7G。\n$ sudo btrfs filesystem resize 7G mnt Resize device id 1 (/dev/nbd0p2) from 9.50GiB to 7.00GiB $ sudo sync $ sudo umount -R ./mnt $ sudo fdisk /dev/nbd0 Welcome to fdisk (util-linux 2.39.2). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Command (m for help): d Partition number (1,2, default 2): 2 Partition 2 has been deleted. Command (m for help): n Partition number (2-128, default 2): First sector (1050624-20971486, default 1050624): Last sector, +/-sectors or +/-size{K,M,G,T,P} (1050624-20971486, default 20969471): +7G Created a new partition 2 of type \u0026#39;Linux filesystem\u0026#39; and of size 7 GiB. Partition #2 contains a btrfs signature. Do you want to remove the signature? [Y]es/[N]o: N Command (m for help): w The partition table has been altered. Calling ioctl() to re-read partition table. Syncing disks. $ sudo fdisk -l /dev/nbd0 Disk /dev/nbd0: 10 GiB, 10737418240 bytes, 20971520 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: gpt Disk identifier: 2EB767AB-0958-461B-B56D-697B3305AC83 Device Start End Sectors Size Type /dev/nbd0p1 2048 1050623 1048576 512M EFI System /dev/nbd0p2 1050624 15730687 14680064 7G Linux filesystem 调整完分区大小后，因为这里没有移除 BTRFS 签名，所以分区的文件没有被删除，执行 lsblk -no NAME,UUID /dev/nbd0 可以看到 /dev/nbd0p2 的 UUID 也没有变化，和上面执行 mkfs.btrfs 时输出的一致。\n$ lsblk -no NAME,UUID /dev/nbd0 nbd0 ├─nbd0p1 C6B7-EF70 └─nbd0p2 a5fb30e5-eb5f-4a0b-8d2a-106e04e1488b 断开 NBD 连接，缩小 qcow2 磁盘大小到 8G。\n$ sudo qemu-nbd -d /dev/nbd0 /dev/nbd0 disconnected $ qemu-img resize ./disk1.qcow2 --shrink 8G Image resized. 重新将 qcow2 磁盘连接到 /dev/nbd0，会发现上面创建的磁盘中的几块分区不见了！\n$ sudo qemu-nbd -c /dev/nbd0 ./disk1.qcow2 $ sudo fdisk -l /dev/nbd0 GPT PMBR size mismatch (20971519 != 16777215) will be corrected by write. Disk /dev/nbd0: 8 GiB, 8589934592 bytes, 16777216 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x00000000 Device Boot Start End Sectors Size Id Type /dev/nbd0p1 1 16777215 16777215 8G ee GPT fdisk 输出中包含一条错误提示：GPT PMBR size mismatch (20971519 != 16777215) will be corrected by write.，大致意思是 GPT 分区表中记录的区块数量 (sectors) 和磁盘实际的区块数不一致。\n修复受损的分区表 所以修复上面栗子中受损的 GPT 分区表的办法是，重新建一个 GPT 分区表，并按照之前的分区位置，重建分区。\n这里重建分区时要注意，需要输入精确的区块位置，而不是类似 +50M 这样模糊的值。\n$ sudo fdisk /dev/nbd0 Welcome to fdisk (util-linux 2.39.2). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. GPT PMBR size mismatch (20971519 != 16777215) will be corrected by write. Command (m for help): g Created a new GPT disklabel (GUID: 3C587DB1-5978-45D2-AB05-9135D273D06D). The device contains \u0026#39;PMBR\u0026#39; signature and it will be removed by a write command. See fdisk(8) man page and --wipe option for more details. Command (m for help): n Partition number (1-128, default 1): First sector (2048-16777182, default 2048): Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-16777182, default 16775167): 1050623 Created a new partition 1 of type \u0026#39;Linux filesystem\u0026#39; and of size 512 MiB. Partition #1 contains a vfat signature. Do you want to remove the signature? [Y]es/[N]o: N Command (m for help): n Partition number (2-128, default 2): First sector (1050624-16777182, default 1050624): Last sector, +/-sectors or +/-size{K,M,G,T,P} (1050624-16777182, default 16775167): 15730687 Created a new partition 2 of type \u0026#39;Linux filesystem\u0026#39; and of size 7 GiB. Partition #2 contains a btrfs signature. Do you want to remove the signature? [Y]es/[N]o: N Command (m for help): t Partition number (1,2, default 2): 1 Partition type or alias (type L to list all): 1 Changed type of partition \u0026#39;Linux filesystem\u0026#39; to \u0026#39;EFI System\u0026#39;. Command (m for help): w The partition table has been altered. Calling ioctl() to re-read partition table. Syncing disks. 重建分区表后，不出意外的话，重新挂载分区是能访问分区中的文件的，分区的 UUID 也没有发生改动。\n$ lsblk -no NAME,UUID /dev/nbd0 nbd0 ├─nbd0p1 C6B7-EF70 └─nbd0p2 a5fb30e5-eb5f-4a0b-8d2a-106e04e1488b $ sudo -l fdisk /dev/nbd0 Disk /dev/nbd0: 8 GiB, 8589934592 bytes, 16777216 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: gpt Disk identifier: 3C587DB1-5978-45D2-AB05-9135D273D06D Device Start End Sectors Size Type /dev/nbd0p1 2048 1050623 1048576 512M EFI System /dev/nbd0p2 1050624 15730687 14680064 7G Linux filesystem $ sudo mount /dev/nbd0p2 mnt $ sudo mount /dev/nbd0p1 mnt/boot $ ls -alh mnt total 20K drwxr-xr-x 2 root root 4.0K Jan 1 1970 boot -rw-r--r-- 1 root root 0 Oct 18 22:36 example.txt drwxr-xr-x 1 root root 0 Oct 18 22:34 home sfdisk 备份分区表 如果觉得重建分区表时，分区的位置记不住的话（废话正常人谁能背下来这一串数字），sfdisk 的 --dump 参数可以备份分区表。\n$ sudo sfdisk --dump /dev/nbd0 label: gpt label-id: 3C587DB1-5978-45D2-AB05-9135D273D06D device: /dev/nbd0 unit: sectors first-lba: 2048 last-lba: 16777182 sector-size: 512 /dev/nbd0p1 : start= 2048, size= 1048576, type=C12A7328-F81F-11D2-BA4B-00A0C93EC93B, uuid=496140B3-C491-470B-98D7-BB95F55266A7 /dev/nbd0p2 : start= 1050624, size= 14680064, type=0FC63DAF-8483-4772-8E79-3D69D8477DE4, uuid=F918E93D-FB1D-4652-9657-CE24A29ADEA5 在执行磁盘缩小操作之前，可以先使用 sfdisk 导出分区表，缩小磁盘后再恢复。\nBackup partition table $ sudo sfdisk --dump /dev/nbd0 \u0026gt; nbd0.txt Remove the `last-lba` line $ grep -v last-lba nbd0.txt \u0026gt; partition-backup.txt After shrinking the disk size... Restore the backup partition table $ sudo sfdisk /dev/nbd0 \u0026lt; partition-backup.txt ","permalink":"https://blog.starry-s.moe/posts/2023/fix-shrunken-disk-broken-partition-table/","summary":"\u003cp\u003e磁盘的扩容和分区的扩/缩容场景很常见，比如分区用着用着快满了，而磁盘有空闲的未分区空间，而这块区域恰好在这块分区的后面，这时可以对分区扩容。\n在使用虚拟机（例如 QEMU）时，假设起初虚拟机的磁盘只创建了 20G，但用久了会存在不够用的情况，这时可以对磁盘扩容，之后再调整分区的大小。\u003c/p\u003e\n\u003cp\u003e但是最近遇到了一个需要对磁盘缩容的场景，例如把一个 64G 的 U 盘用 \u003ccode\u003edd\u003c/code\u003e 将整个磁盘的数据写入到一个 8G 的 U盘中（当然这个 64G U盘实际使用的分区大小不能大于前 8G）。\n或者要把一个原本 50G 的 qcow2 虚拟磁盘缩小成 10G，用来制作别的镜像什么的。\u003c/p\u003e","title":"修复缩小磁盘空间后受损的 GPT 分区表"},{"content":"今年的六月初的时候赶着 618 活动入手了 Kobo Libra 2 电纸书，距离上次博客更新刚好过去一个月，想于是想着把 Kobo Libra 2 安装 KOReader 踩坑的记录写在这里刚好可以水一篇博客。\n这首歌很魔性……\nKOReader\nKobo 安装 KOReader 的教程可以参照 KOReader Wiki。\nImportant Notes 首先把 Kobo 连接到电脑，用文本编辑器打开 .kobo/Kobo/Kobo eReader.conf，确保存在以下配置文件，禁止阅读器加载隐藏文件夹中的内容：\n[FeatureSettings] ExcludeSyncFolders=(\\\\.(?!kobo|adobe).+|([^.][^/]*/)+\\\\..+) Manual Installation Methods 按照手动安装 KOReader 的步骤，有两种安装方式可选择：\n第一种是在 KFMon 的基础上安装 KOReader，需要先安装 KFMon，安装 KFMon 的教程以及文件的下载连接在这里。\n除此之外另一种安装方法是基于 NickelMenu 的方式安装 KOReader。\n这里咱使用的是第二种基于 NickelMenu 的方式安装 KOReader。\n首先下载 NickelMenu 的 KoboRoot.tgz 安装包，像升级系统那样把压缩包拖到 .kobo 文件夹内，弹出 USB 后 Kobo 会自动重新更新。安装完成后 Kobo 右下角菜单栏会多一个 NickelMenu 菜单。\n在 此处 下载 KOReader 安装包，因为 Libra 2 等使用相似主板的电子书存在死机重启的不稳定 Bug 建议先下载包含修复此问题的 nightly build（参考 Issue），文件名以 koreader-kobo 开头的为 Kobo 使用的安装包。\n再次将 Kobo 连接到电脑，将 KOReader 安装包解压到 .adds 目录下。\n新建 .adds/nm/koreader 文件，写入以下内容：\nmenu_item:main:KOReader:cmd_spawn:quiet:exec /mnt/onboard/.adds/koreader/koreader.sh 弹出 USB，等待设备同步完数据后，就可以在 Kobo 的右下角菜单栏中启动 KOReader 了。\nKnown Issues 使用过程中只遇到一个 KOReader 的严重影响体验的问题，就是上面说的阅读过程中会经常死机重启，可以在 这篇 Issue 跟踪进度，目前可以尝试使用 这个 Patch，安装 nightly build 的安装包尝试解决。\nOthers 贴几张看电纸书的效果图供参考，Kobo 的显示效果比咱之前用过的 KPW4 好太多了。图书的话基本是从网络上找盗版资源了，KOReader 能够对 PDF 重排所以对 PDF 的支持效果也比 Kindle 好很多。\n","permalink":"https://blog.starry-s.moe/posts/2023/kobo-libra-2/","summary":"\u003cp\u003e今年的六月初的时候赶着 618 活动入手了 Kobo Libra 2 电纸书，距离上次博客更新刚好过去一个月，想于是想着把 Kobo Libra 2 安装 KOReader 踩坑的记录写在这里刚好可以水一篇博客。\u003c/p\u003e","title":"Kobo Libra 2 安装 KOReader"},{"content":"这个 Minecraft 存档是咱在 2020 年年初的时候建立的，起初是 1.15.2 单机生存，当时在 B 站学着 TIS 以及其他生电服的思路安装了一些生存辅助插件，后来升级到了 1.16.5，并在去年年底迁移到了我的 NAS 上改成了私人服务器。尽管玩了三年多的时间了但我从来没详细的在博客上记录这个存档，只有在前几年的年终总结中提到过“我在玩 Mincraft，今年建了什么建筑……”，眼瞅着三周年已经过去了，本来想录个纪念视频发 B 站上的，但因为太懒、不想学视频剪辑，这个计划一直咕咕了，不过最近想到可以把存档截图放博客里作为三周年纪念。\n出生点空置域 出生点空置域\n出生点已经被咱炸成空置域了，当时是在 2020 年花了几天的时间用三向轰炸机清理的空置域，y11 高度以下的岩浆并不碍事所以没有清理，现在的出生点空置域有一个收集末地刷沙机的简单收集装置（以后打算改成自动分类+潜影盒收集装置），橙色的建筑是地铁出生点站，图片右侧的是一个简易的刷鱼农场，主要靠这个农场获取墨鱼的黑色染料。\n原点空置域 原点\n原点空置域是咱的第二个空置域，之所以叫原点是因为空置域的中心座标为 (x:0, z:0)，原点空置域里只有一个全物品（垃圾桶）分类装置，这个原点空置域我记得是 2021 年用三向炸的，全物品也是在 21 年上半年建的，现在全物品已经全部完工并正常使用了，不过这个全物品目前只收集了一半左右的可堆叠物品，因为有许多物品在单人生存中很少用到。\n全物品垃圾桶右边蓝色圆形的建筑是地铁原点站，顶上是一个仅装饰作用的“停机坪”。\n全物品分类是这个存档里工程量最大的机器，当时建全物品时特地新建了一个村民交易所，买了巨多的石英和红石、萤石等建筑材料，清理水道时也花了巨长的时间。\n生存基地 生存时第一个建造的房子\n由村庄改造的庭院\n生存基地俯瞰\n刷铁机、工厂、地铁站\n当初建立存档后，是生存在出生点旁边的一个村庄里的，后来搬到了附近的河边，现在村庄已经没有村民了，被我改建成了一个中式的庭院。\n这个生存基地有一个简易的工厂，工厂一层是一个小型牧场和小型熔炉组和 1.15 版本能用的经验熔炉（升级到 1.16 后特性被修复了就不能用了），工厂二层有一个附魔台，三层是简易的村民交易所。工厂旁边有一个简易的刷铁机，尽管后来又盖更大的刷铁机了但这个没拆，尽管效率低点但一直能用。\n工厂侧面还有一个白桦树树场，效率蛮高的单人生存足够用了，后期的木材全是从这里获取的。生存基地的地下有一个能换乘三条线路的超大地铁站。\n1 号线站厅\n1 号线站台\n空置域线站台\n2 号线站台\n工业基地 工业基地有一个 320 超大熔炉组，然后是一个效率蛮高的刷石机和一个简易的复制铁轨的机器，地下有一个地铁工业基地站。\n320 熔炉组\n刷石机 \u0026amp; 铁轨复制机\n机场（在建） 不得不说生存修机场真的太麻烦了，时间全用来整地形了，铺混凝土倒不是很费事。现在这个机场只有一条跑道，打算建航站楼但是工程量很大，需要很长的时间整理地形，所以一直在咕咕姑中。\n地铁站 \u0026amp; 刷铁机 \u0026amp; 刷怪塔\n机场旁边的海上有一个大型的 8 核心刷铁机、一个简易的混凝土固化机和一个刷怪塔以及一个地铁站。后期建地铁等建筑的所有混凝土都是在这个混凝土固化机固化的，然后尽管这个刷铁机效率不是特别高但是单机生存勉强够用了，不够用的话就多挂机刷一会（/tick rate 200 警告）……\n摩天楼 其实这个地方我起的地名叫“三号村庄”，因为是第三个发现的村庄……\n本来计划建两个摩天楼的，但是建完一个之后，另一个楼就一直处于咕咕的状态。摩天楼旁边是一个大型的双岛式站台地铁站。\n跨海大桥 这个存档里一共有俩跨海大桥，第一个桥是 2020 年暑期时建的，第二个桥是 22 年下半年建的。\n甘蔗农场 甘蔗农场是今年上半年修建的，是一个简易的全自动甘蔗机，收集的甘蔗主要用于生成烟花火箭的原材料：纸。\n村民交易所 在修建全物品分类以及地铁站装饰时，需要大量的石英和萤石，因此修建了这个带打折的村民交易所，因为没有建袭击农场，所以目前与村民交易的绿宝石都是从村民交易所卖铁换取的，而铁是靠村民制作的刷铁机刷出来的。深刻体现了什么叫“取之于民，用之于民”的资本家思想（逃\n村民交易所旁边还有一个咱自己设计的全自动农场，但是因为咱不缺食物（可以从村民那里买金胡萝卜吃），所以这个自动农场建好后一直在闲置。\n海底神殿（守卫者农场） 生存中第一个发现的海底神殿，已经被改成了不需要清空水的袭击者农场（排水实在太麻烦了），目前所有建筑的海晶灯的原材料都是从这个农场获取的，海底神殿旁边是三号线地铁海底神殿站。\n地狱猪人农场 因为光影在地狱的效果不好所以咱把光影关掉了……\n这个猪人农场用来挂机刷经验以及获取金子，农场还包含了猪灵交易所，可以把刷取的金锭与猪灵换取石英、黑曜石、火焰弹等物品。\n地铁 这个存档里目前有三十多个已建成的地铁站，还有十多个在建的地铁站，这里贴几张咱自认为设计得比较有特点的地铁站。\n首先是这个双层侧式站台的地铁站，上层是已经建成的 2 号线，下层是正在建设的通往机场的 6 号线：\n这个是 3 号线的末地传送门站，这个站直接修在了末地要塞里，上层是地铁站台，下层是由末地要塞改造成的末地传送门入口，同时保留了要塞的书房作为该地铁站的小型图书馆：\n末地传送门 - 站台\n末地传送门 \u0026amp; 图书馆\n这个是村民交易所的地下的地铁站，用的云杉木作为柱子，还挺好看的：\n村民交易所 - 站台\n空置域西站：\n3 号线（左）、1 号线（右）\n一号线的保留了正线的侧式站台地铁站，方便甩站用（本次裂车本站不停靠）：\n南湖公园站\n一号线的地上段，弄了红石灯做了点简易的装饰：\n冰工厂站\n全物品分类旁边的原点站也很有特色，车站是圆柱体结构，两条线路十字交叉：\n原点站\n这个是二号线的车辆段，目前存档里只有二号线有车辆段（因为二号线太长了），别的线路还没有修车辆段的计划。\n以上基本是咱玩了三年的单人生存存档的全部内容了，还有些在建和小型的建筑个人认为没必要贴到这里，因为最近逐渐没有玩下去的兴趣了所以不知道以后还能不能继续坚持玩下去，所以想了一下这三年时间建的建筑蛮多的因此写到这里水一篇博客。\n","permalink":"https://blog.starry-s.moe/posts/2023/minecraft/","summary":"\u003cp\u003e这个 Minecraft 存档是咱在 2020 年年初的时候建立的，起初是 1.15.2 单机生存，当时在 B 站学着 TIS 以及其他生电服的思路安装了一些生存辅助插件，后来升级到了 1.16.5，并在去年年底迁移到了我的 NAS 上改成了私人服务器。尽管玩了三年多的时间了但我从来没详细的在博客上记录这个存档，只有在前几年的年终总结中提到过“我在玩 Mincraft，今年建了什么建筑……”，眼瞅着三周年已经过去了，本来想录个纪念视频发 B 站上的，但因为太懒、不想学视频剪辑，这个计划一直咕咕了，不过最近想到可以把存档截图放博客里作为三周年纪念。\u003c/p\u003e","title":"玩了三年的 Minecraft 生存存档"},{"content":"Controller 对初学着来说有那么亿点点抽象，虽然网络上能找到很多有关 Kubernetes Controller 的讲解，但是 Kubernetes 的学习过程往往是一个离散的而不是连续的过程。如果想弄懂 Controller 还是有蛮高门槛的，不要想着看完 Kubernetes 的文档，速成了 Kubernetes 的基本知识就去尝试写 Controller，这种操作就好比刚过完新手教程就去打高难副本，尽管能仿着 sample-controller 写一个能“跑”的 Controller，但仅仅只能做到能“跑”的程度……\n与标题有些不同，这篇博客主要讲的是萌新如何上手编写 Controller，如果你是 Kubernetes 初学者，希望这篇博客能帮助你建立编写 Controller 的学习曲线。\n前期准备 对刚接触 Kubernetes 的萌新来讲，这个体系还是蛮复杂和抽象的，只靠读文档看教程自学可不是那么容易。光是怎么安装一个 Kubernetes 集群，在不同的教程里就有无数种方法了。传统的安装 Kubernetes 的方法过于硬核，现在几乎没人选择这种方式部署集群了。咱常用的比较简单的方式有 k3s，光靠一个脚本就能在虚拟机上一键部署一个轻量级的集群，很适合萌新（前提是你没有必须用包管理器安装任何软件的强迫症），但是如果你想在国内的网络环境靠这个脚本安装 k3s 的话，需要一些参数配置国内源，这里不再赘述。除此之外还可以用 Docker 方式部署一个单节点 Rancher，Rancher 的 Web 界面可以更好的帮助萌新去管理 Kubernetes 资源（当然你还可以选择敲 kubectl 指令的方式），还有很多教程会推荐你使用 minikube，当然你可以选择任何一种方式去部署你自己的集群，只要你觉得这种方法适合你，而且部署的集群版本不要太低即可。\n如果想编写 Controller，你得有一定的 Kubernetes 基础（废话），并且熟悉 Go 语言（废话 x 2）。在看完 Kubernetes 文档，熟悉了 k8s 的资源和如何使用 kubectl 操作他们后，先别急着上手写 Controller。首先你得熟悉 client-go，client-go 的代码能在 GitHub (https://github.com/kubernetes/client-go) 中下载到，但记住它的 Go Module 为 k8s.io/client-go，不在 github.com。\n首先了解一些常见的 Kuberntes API 类型，知道 Kubernetes 的资源对象是怎么在 client-go 中用 Go 语言表示的，并如何调用 API 去管理他们（而不是仅凭 kubectl 命令行客户端去管理他们）， 这里不单单有 client-go 这一个 Git 仓库，还有 k8s.io/api, k8s.io/apimachinery 等仓库，后面写 Controller 时会经常用到这些 API。认识一下 TypeMeta 和 ObjectMeta （代码位置在这里），每个资源对象的 Go 结构中都包含这些数据（除此之外每个资源还有 Spec, Status 等），写代码时会经常用到 json/yaml 的 Marshal/Unmarshal 操作，熟悉到这个程度就可以了。\n然后是 Kubernetes 的自定义资源（Custom Resource, CR）这个概念，k8s 内置了一些 Resource 资源对象，例如 pod, deployment, service, secret 等，你可以用 kubectl 去 get/describe/create/delete... 这些资源，但如果你想往 k8s 中添加一些你自己的自定义资源，比如你想定义一个资源叫做 database，你用 kubectl create database ... 就能创建一个你自己想要的数据库，像 create pod, create secret 那样，然后还能对你的自定义资源对象进行 describe/delete/update... 等操作，就需要用到自定义资源（开发者更习惯叫他的简写 CR，以及自定义资源定义的简写 CRD）。Controller 就是用来管理这些 CRs 的。在开发 Controller 时我们需要定义 CR 中包含哪些数据，然后使用代码生成器生成资源的 DeepCopy 等方法，减少不必要的重复代码编写。\n可以不用把每个细节都尝试弄懂，把基本概念过一遍就行，学习 Kubernetes 的过程是一个离散的过程而不是连续的过程，当碰到哪个地方不明白卡住的时候直接跳过去看后面的内容就行啦~\n什么是 Controller 在上面介绍 CR 的定义时有解释 Controller 是用来管理 CR 的，比如我们执行 kubectl create database ... （实际是执行 kubectl apply -f 部署了一个 Kind 为 database 的 YAML，不能直接 create database，但这么说比较方便理解~）创建了一个 database 类型的资源，因为这个资源是我们自定义的，所以 Kubernetes 只是在 etcd 数据库中记录了：“我们创建了一个 database 资源，他的数据内容是什么什么……”，并没有进行创建数据库的操作！而 Controller 就是用来管理 Database 资源的生命周期的，比如我们 create database 之后，Controller 会发现我们新建了一个 Database 资源，然后会去创建一个 Database Deployment。当我们 delete database 时，Controller 会注意到我们删除了 Database，之后执行资源释放一系列操作。\n往简单了讲，Controller 干的事情就是对比资源当前实际的状态和我们设定的资源状态是否一致。比如这个资源定义的 replicas 为 2，但实际只有一个 Pod 在运行，Controller 就会再去创建一个 Pod 使其实际的 replicas 为 2。\n当然 Controller 实现起来比这复杂多了，可不是一个简单的 for 循环不断从 Kube API 中查询资源然后做对比这么简单，这用到了 Cache 缓存机制和 Informer 消息提醒机制，减少 Kube API 请求次数，读取内存中的状态缓存什么的，听不懂没关系，以后会懂的……\nsample-controller github.com/kubernetes/sample-controller 项目是一个样例 Controller，所有的初学者都是靠这个项目学习 Controller 的，相当于是高难副本中最简单的了，可以把这个样例 Controller 改造为自己的 Controller，用来学习。\n本篇教程以编写 database-controller 为例，按照 sample-controller 的 Controller 框架编写一个数据库的 Controller，重点在于怎么上手写 Controller，不在数据库。\n将 sample-controller 代码克隆到本地 $GOPATH 目录下：\n$ midir -p $GOPATH/src/github.com/\u0026lt;USERNAME\u0026gt;/ \u0026amp;\u0026amp; cd $GOPATH/src/github.com/\u0026lt;USERNAME\u0026gt;/ $ git clone git@github.com:kubernetes/sample-controller.git \u0026amp;\u0026amp; cd sample-controller 初始化 Controller 按照 sample-controller 的 Controller 框架，将其修改为我们想要实现的 Controller。\n修改项目名称为 database-controller，修改 git remote。 编辑 go.mod 修改 Module 名称，把代码的 k8s.io/sample-controller 改为 github.com/\u0026lt;USERNAME\u0026gt;/database-controller。 编辑 hack/boilerplate.go.txt 中的版权信息。 修改 README，OWNERS，SECURITY_CONTACTS 等信息。 编辑执行代码生成器的脚本 hack/update-codegen.sh 编辑脚本中的代码生成器所在位置，脚本中原本写的是使用了 go mod vendor 将 Go 依赖都放到了项目的 vendor 目录下时生成器的位置，按实际情况进行修改（比如改成 $GOPATH 目录下）。 编辑 code-generator 的参数，把 k8s.io/sample-controller 改成 github.com/\u0026lt;USERNAME\u0026gt;/database-controller, 并编辑 --output-base 的目录位置。 执行代码生成器脚本，确保能正确生成代码。 之后修改 pkg/apis/samplecontroller 目录为 pkg/apis/databasecontroller，同时把 samplecontroller 包修改为 databasecontroller。\n把代码中所有使用了 samplecontroller 包的地方都改为 databasecontroller（被代码生成器生成的代码可以不用改，后面会重新生成代码）。 修改 pkg/apis/databasecontroller/register.go 的 GroupName 为 database.\u0026lt;YOUR_DOMAIN\u0026gt;，例如 database.example.io。 修改代码生成器的注释，把 pkg/apis/databasecontroller/v1alpha1/doc.go 的 groupName 修改为 database.example.io。 重新执行代码生成器 ./hack/update-codegen.sh。 先简单熟悉一下修改后的项目的代码结构：\nmain.go 中先构建了 Kubernetes 和 database-controller 的 Client，之后基于 Client 构建了 SharedInformer，最后创建并启动 Controller。\n简单来讲，Informer 在资源发生改动时，调用相应事件的处理函数，它可以对“增加”，“更新”，“删除”三种事件进行“监控”处理（一点也不简单，太抽象了）。然后 Informer 还充当了缓存的作用，查询资源状态时只需要查询 Informer 的缓存即可，不需要反复调用 Kube API，减少性能损耗。\ncontroller.go 包含这些内容：\n构建 Controller 的 NewController、启动 Controller 的 Run，还有 Informer 在不同事件（Event）进行处理的函数…… 创建 Deployment 的函数，sample-controller 中的 CRD Kind 为 foo，这个 foo 创建的 Deployment 是一个 nginx Pod，有点抽象，后面要把 foo 改成咱们要实现的 database，原理实际都没变。 Controller 结构体中包含了：\nkubernetes 和代码生成器生成的 database 的 clientSet。 Informer 的 Lister，用来从缓存中获取资源。 workqueue：Rate Limit 消息队列。 Controller 在运行时实际是一直尝试从 workqueue 中获取资源并处理。Informer 在接收到状态更新后，会把更新的状态入队列，然后另一个 Routine 中会获取到队列中的消息，拿去处理。 （蛮复杂的，这里还是去直接看代码比较好） 修改 Controller 接下来按照上面讲的那样，修改 pkg/apis/databasecontroller/v1alpha1/types.go 中的 Spec 和 Status 字段，Spec 中的字段是你想定义的 Database 的状态，然后 Controller 负责按照你定义的 Spec 去创建 Deployments 并更新 Status。\n首先需要把 Foo 改名成 Database，然后编辑 Spec 中的字段，例如数据库所使用的镜像名称及 Tag，Replicas 冗余数以及其他你觉得创建 Deployment 所需的自定义配置。在修改完 Spec 和 Status 后需要重新执行代码生成器。\n之后在项目根目录下编辑 controller.go，修改控制器创建 Deployment 的逻辑，把 Foo 对象修改为 Database，然后按照你定义的 Spec，编辑 artifacs/example 目录下的 crd.yaml 和 example-database.yaml 文件，这部分咱就不把详细的步骤写到这里了，你可以根据你的想法尝试编写你的 Controller，在这里遇到问题最好还是自行尝试动手解决。\n其他 后面还有好多关于 Controller 相关的知识点我也还没搞懂，就不写到博客里误导别人了。除了 sample-controller 这种框架的 Controller 之外，还有很多人使用其他的框架编写 Controller，因为很多时候我们更关注于实现业务逻辑，因此可以套用一些 Operator 模板，常用的有 Operator SDK，可以通过这个工具生成一份 Controller 模板，然后按照你想实现的功能去修改代码即可，还有很多其他 Operator 可供选择，比如 Rancher 的开发者们使用 Wrangler 编写 Controller，基于 Wrangler 编写的 Rancher 使用的 Operator 有 eks-operator 等一堆 Operator，感兴趣的话可以去看看。Wrangler 的 README 中写的这一段蛮有意思的：\nMost people writing controllers are a bit lost as they find that there is nothing in Kubernetes that is like type Controller interface where you can just do NewController. Instead a controller is really just a pattern of how you use the generated clientsets, informers, and listers combined with some custom event handlers and a workqueue.\n之后如果想把你编写的 Controller (Operator) 应用到生产环境，打包给更多的人使用，可以把编译好的 Operator 二进制文件放到容器镜像中，之后使用 Helm 创建一个 \u0026ldquo;应用程序 (Chart)\u0026quot;，通过编写 模板，在安装 Helm Chart 时编辑 values.yaml 中定义的字段来自定义 CRD 的参数。Helm 的模板本质上是 Go Template 模板渲染引擎，所以用起来都是很简单的（确信）。\n","permalink":"https://blog.starry-s.moe/posts/2023/kube-controller/","summary":"\u003cp\u003eController 对初学着来说有那么亿点点抽象，虽然网络上能找到很多有关 Kubernetes Controller 的讲解，但是 Kubernetes 的学习过程往往是一个离散的而不是连续的过程。如果想弄懂 Controller 还是有蛮高门槛的，不要想着看完 Kubernetes 的文档，速成了 Kubernetes 的基本知识就去尝试写 Controller，这种操作就好比刚过完新手教程就去打高难副本，尽管能仿着 \u003ccode\u003esample-controller\u003c/code\u003e 写一个能“跑”的 Controller，但仅仅只能做到能“跑”的程度……\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e与标题有些不同，这篇博客主要讲的是萌新如何上手编写 Controller，如果你是 Kubernetes 初学者，希望这篇博客能帮助你建立编写 Controller 的学习曲线。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"当你刚开始尝试去写 Kubernetes Controller……"},{"content":"打算尝试在咱的 NAS 上搭一个 Harbor Registry Server 玩。\n首先介绍一下 NAS 上的环境，咱的 Kubernetes 集群运行在几个 QEMU 虚拟机里，虚拟机里运行的是 ArchLinux，因为就是咱折腾着玩的所以使用的 k3s 搭建的轻量级的 kubernetes 集群，然后其中一个集群安装了 Rancher 作为 Local 集群。\n环境准备 新建一个 Namespace，将 Harbor 的资源与其他资源隔离：\n$ kubectl create namespace harbor 为了启用 HTTPS，提前创建一个 TLS 类型的 Secret，存放证书:\n$ cat \u0026gt; cert.pem \u0026lt;\u0026lt; EOF -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- EOF $ cat \u0026gt; cert.key \u0026lt;\u0026lt; EOF -----BEGIN PRIVATE KEY----- ... -----END PRIVATE KEY----- EOF $ kubectl -n harbor create secret tls harbor-tls \\ --cert=cert.pem \\ --key=cert.key 提前创建 PVC (PersistentVolumeClaim)，咱这里先在 NAS 上新建了一个 NFS 服务器，之后创建了 NFS 类型的 PV (PersistentVolumes)，再基于这个 PV 创建的 PVC。\nArchLinux 上搭建 NFS 服务器：https://wiki.archlinux.org/title/NFS\n在配置 exports 时，需要配置上 no_root_squash 和 no_subtree_check，使挂载的目录及子目录具有写权限。\n# /etc/exports - exports(5) - directories exported to NFS clients # Use `exportfs -arv` to reload. /var/nfs/harbor\t10.0.0.0/8(rw,sync,no_root_squash,no_subtree_check) 获取 Helm Chart Harbor 的 Helm Chart 可以在 GitHub 获取，这里使用将 Chart 源码克隆到本地的方式安装，方便编辑 values.yaml。\n$ git clone https://github.com/goharbor/harbor-helm.git \u0026amp;\u0026amp; cd harbor-helm $ git checkout v1.12.1 写这篇博客时 Chart 的最新版本是 v1.12.1 (Harbor OSS v2.8.1)。\n编辑 values.yaml Harbor 的配置都定义在了 values.yaml 文件中，根据需要进行修改。\n这里列举些常用的可以修改的选项：\nexpose: # expose type, 可以设置为 ingress, clusterIP, nodePort, nodeBalancer，区分大小写 # 默认为 ingress（如果不想使用 80/443 标准端口，可以设置为 nodePort，端口为高位 3000X） type: ingress tls: # 是否启用 TLS (HTTPS)，建议启用 enabled: true # TLS Certificate 的来源，可以为 auto, secret 或 none # 如果为 secret，需要在安装 Chart 之前先创建 TLS Secret # 1) auto: generate the tls certificate automatically # 2) secret: read the tls certificate from the specified secret. # The tls certificate can be generated manually or by cert manager # 3) none: configure no tls certificate for the ingress. If the default # tls certificate is configured in the ingress controller, choose this option certSource: secret secret: # The name of secret which contains keys named: # \u0026#34;tls.crt\u0026#34; - the certificate # \u0026#34;tls.key\u0026#34; - the private key secretName: \u0026#34;harbor-tls\u0026#34; # Only needed when the \u0026#34;expose.type\u0026#34; is \u0026#34;ingress\u0026#34;. notarySecretName: \u0026#34;harbor-tls\u0026#34; ingress: hosts: # Ingress Host，如果需要允许任意域名/IP 都能访问，将其设置为空字符串（不建议） # 这里填写的域名务必能解析到当前集群 core: harbor.example.com notary: notary.example.com # Harbor external URL # 与 Ingress Host 相对应，如果启用了 TLS，那就是 https://\u0026lt;domain\u0026gt; # 如果没启用 TLS，那就是 http://\u0026lt;domain\u0026gt; # 如果 expose type 为 nodePort，则填写 http(s)://\u0026lt;IP_ADDRESS\u0026gt;:3000X (端口号不能丢) externalURL: https://harbor.example.com # 持久卷配置，默认为 true，如果是测试环境可以设置为 enabled: false (重新安装 Chart 时仓库里所有的数据都会丢失，不建议！) # 如果需要启用持久卷，可以在安装 Chart 之前提前创建好 PVC，并配置 subPath persistence: enabled: true resourcePolicy: \u0026#34;keep\u0026#34; persistentVolumeClaim: registry: # 填写已经创建好的 PVC existingClaim: \u0026#34;harbor-pvc\u0026#34; storageClass: \u0026#34;\u0026#34; # 如果共用一个 PVC，需要设置子目录 subPath: \u0026#34;registry\u0026#34; accessMode: ReadWriteOnce size: 5Gi annotations: {} jobservice: jobLog: existingClaim: \u0026#34;harbor-pvc\u0026#34; storageClass: \u0026#34;\u0026#34; subPath: \u0026#34;jobservice\u0026#34; accessMode: ReadWriteOnce size: 1Gi annotations: {} database: existingClaim: \u0026#34;harbor-pvc\u0026#34; storageClass: \u0026#34;\u0026#34; subPath: \u0026#34;database\u0026#34; accessMode: ReadWriteOnce size: 1Gi annotations: {} redis: existingClaim: \u0026#34;harbor-pvc\u0026#34; storageClass: \u0026#34;\u0026#34; subPath: \u0026#34;redis\u0026#34; accessMode: ReadWriteOnce size: 1Gi annotations: {} trivy: existingClaim: \u0026#34;harbor-pvc\u0026#34; storageClass: \u0026#34;\u0026#34; subPath: \u0026#34;trivy\u0026#34; accessMode: ReadWriteOnce size: 5Gi annotations: {} # Admin 初始密码 harborAdminPassword: \u0026#34;Harbor12345\u0026#34; 安装 Helm Chart 确保 Values 编辑无误后，就可以安装 Chart 了：\n$ helm --namespace harbor install harbor . 如果安装后发现 Values 中有些配置需要修改，可以在修改完配置后以升级的方式使配置生效：\n$ helm --namespace harbor upgrade harbor . 查看 Chart 的 Pods 运行状态：\n$ kubectl --namespace harbor get pods NAME READY STATUS RESTARTS AGE harbor-core-7b75785b64-9vzkx 1/1 Running 0 65m harbor-database-0 1/1 Running 0 77m harbor-jobservice-6f4d59bd95-25q44 1/1 Running 2 (65m ago) 65m harbor-notary-server-584698b475-lnt99 1/1 Running 1 (60m ago) 65m harbor-notary-signer-77685b6f94-pfngc 1/1 Running 0 65m harbor-portal-6fb6465fd6-hm4cg 1/1 Running 0 77m harbor-redis-0 1/1 Running 0 77m harbor-registry-5bbccf79fb-7hcm9 2/2 Running 0 65m harbor-trivy-0 1/1 Running 0 77m 其他 安装完成后，就可以完美使用 Harbor Registry 了。\n$ docker login harbor.example.com Username: admin Password: WARNING! Your password will be stored unencrypted in /home/user/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded 从 DockerHub 中 Mirror 一些镜像到 Harbor 中：\n$ skopeo copy --all docker://archlinux:latest docker://harbor.example.com/library/archlinux:latest Getting image list signatures Copying 1 of 1 images in list Copying image sha256:076c0233d1996165721320957be9a037a760574d6334281354b07b3b3c9440b1 (1/1) Getting image source signatures Copying blob f0e04a7b4686 done Copying blob 352736306209 done Copying config cc4866169d done Writing manifest to image destination Storing signatures Writing manifest list to image destination Storing list signatures ","permalink":"https://blog.starry-s.moe/posts/2023/harbor-helm-chart/","summary":"\u003cp\u003e打算尝试在咱的 NAS 上搭一个 Harbor Registry Server 玩。\u003c/p\u003e","title":"使用 Helm Chart 方式部署 Harbor"},{"content":"最近总在弄些容器镜像相关的东西，于是分享一些咱自己总结的有关容器镜像 Manifest 格式、常用工具以及代码相关的芝士。\nskopeo skopeo 是一个肥肠好用的容器镜像的辅助工具，常用到的功能有镜像拷贝 (skopeo copy)、镜像 Manifest 查询 (skopeo inspect)等……\nskopeo 仅支持 Linux 和 macOS 系统。\n安装 skopeo # ArchLinux sudo pacman -S skopeo # macOS brew install skopeo 除此之外还可以使用 skopeo 的容器镜像：\n$ docker run docker://quay.io/skopeo/stable:latest copy --help skopeo 由 Go 编写，但它启用了 cgo，编译的二进制文件需要动态链接第三方依赖，所以不同的系统编译的 skopeo 二进制文件并不一定互相通用，如果你的发行版的官方源没有提供 skopeo 软件包的话，只能手动安装 Go 和 skopeo 的一些依赖，然后 自行编译 skopeo 二进制文件。\nskopeo copy copy 可以灵活的拷贝容器镜像，它可以将容器镜像从 Registry Server 之间拷贝，还可以将镜像从 Registry Server 拷贝到本地的文件夹中，或者像 docker pull 那样拷贝到 Docker Daemon 中。\n在执行 skopeo copy 时还可以用 --format 参数指定拷贝过去的容器镜像的格式，用参数 --dest-compress-format 可以指定压缩格式。\n将容器镜像从第三方 DockerHub Registry Server 拷贝到自建的 Private Registry Server：\n$ skopeo copy docker://docker.io/library/nginx:latest docker://private.registry.io/library/nginx:latest --all 将镜像从 DockerHub Registry Server 拷贝到本地文件夹中：\n$ mkdir -p nginx $ skopeo copy docker://docker.io/library/nginx:latest dir:./nginx 将镜像从本地文件夹中拷贝到 Docker Daemon 中：\n$ skopeo copy dir:./nginx docker-daemon:nginx:latest $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest 448a08f1d2f9 13 days ago 142MB skopeo inspect skopeo inspect 查看容器镜像的信息，例如镜像的 Manifest、Config。\n$ skopeo inspect docker://docker.io/library/nginx:latest $ skopeo inspect docker://docker.io/library/nginx:latest --raw $ skopeo inspect docker://docker.io/library/nginx:latest --raw --config skopeo inspect 不加任何参数时，查询的是容器镜像相关的信息，输出的内容包括镜像 Digest、该镜像其他的所有 Tag 等一系列信息。\n在添加 --raw 参数时，输出的是该镜像的 Manifest 原始信息，因为是 RAW，所以输出的 Json 可能格式不是很友好，通常与 jq 一起使用。\n添加 --raw 和 --config 参数后，输出的是该镜像的 Config 的原始信息，Config 中包括容器运行时的一些配置项等信息。\nManifest Docker 文档 Registry image manifests 中介绍了几种常见的 Docker 镜像的 Manifest 格式。\n可以通过 skopeo 工具，从 Docker Hub 上挑一个容器镜像 (例如 nginx:latest)，查看这个镜像的 Manifest。\n// skopeo inspect docker://nginx:latest --raw | jq { \u0026#34;manifests\u0026#34;: [ { \u0026#34;digest\u0026#34;: \u0026#34;sha256:3f01b0094e21f7d55b9eb7179d01c49fdf9c3e1e3419d315b81a9e0bae1b6a90\u0026#34;, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.v2+json\u0026#34;, \u0026#34;platform\u0026#34;: { \u0026#34;architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;os\u0026#34;: \u0026#34;linux\u0026#34; }, \u0026#34;size\u0026#34;: 1570 }, { \u0026#34;digest\u0026#34;: \u0026#34;sha256:bc4cb92540db42f21dd806c4451f33b623a9b6441c882e8554325f3a3702da76\u0026#34;, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.v2+json\u0026#34;, \u0026#34;platform\u0026#34;: { \u0026#34;architecture\u0026#34;: \u0026#34;arm\u0026#34;, \u0026#34;os\u0026#34;: \u0026#34;linux\u0026#34;, \u0026#34;variant\u0026#34;: \u0026#34;v5\u0026#34; }, \u0026#34;size\u0026#34;: 1570 }, ...... ], \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.list.v2+json\u0026#34;, \u0026#34;schemaVersion\u0026#34;: 2 } 这里输出的 json object 的 schemaVersion 为 2，mediaType 为 application/vnd.docker.distribution.manifest.list.v2+json。\nschemaVersion \u0026amp; mediaType 容器镜像的 Manifest 有很多种不同的格式，先列举一下常见的 Docker 镜像的 Manifest 格式：\nschemaVersion: 1, mediaType: \u0026quot;application/vnd.docker.distribution.manifest.v1+json\u0026quot;\n旧版本的 Docker 使用这种 Manifest 格式，现已被弃用，有些旧的容器镜像依旧是这种格式的 Manifest。\n// skopeo inspect docker://mysql:5.5.40 --raw | jq { \u0026#34;name\u0026#34;: \u0026#34;library/mysql\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;5.5.40\u0026#34;, \u0026#34;architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;fsLayers\u0026#34;: [ { \u0026#34;blobSum\u0026#34;: \u0026#34;sha256:a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4\u0026#34; } ...... ], \u0026#34;history\u0026#34;: [ ...... ], \u0026#34;schemaVersion\u0026#34;: 1, \u0026#34;signatures\u0026#34;: [ { ...... } ] } (输出太长了所以我把不关键的内容省略掉了……)\n这里用 docker.io/library/mysql:5.5.40 这个镜像举例，实际这个镜像的 Manifest 格式为 schemaVersion: 1，mediaType: \u0026quot;application/vnd.docker.distribution.manifest.v1+prettyjws\u0026quot;，因为包含了签名信息。\nschemaVersion: 2, mediaType: \u0026quot;application/vnd.docker.distribution.manifest.v2+json\u0026quot;\n这个是现在常见的 Docker 镜像的 Manifest 格式。\n// skopeo inspect docker://hxstarrys/nginx:1.22-amd64 --raw | jq { \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.v2+json\u0026#34;, \u0026#34;config\u0026#34;: { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.container.image.v1+json\u0026#34;, \u0026#34;size\u0026#34;: 7898, \u0026#34;digest\u0026#34;: \u0026#34;sha256:0f8498f13f3adef3f3c8b52cdf069ecc880b081159be6349163d144e8aa5fb29\u0026#34; }, \u0026#34;layers\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.image.rootfs.diff.tar.gzip\u0026#34;, \u0026#34;size\u0026#34;: 31411405, \u0026#34;digest\u0026#34;: \u0026#34;sha256:f1f26f5702560b7e591bef5c4d840f76a232bf13fd5aefc4e22077a1ae4440c7\u0026#34; }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.image.rootfs.diff.tar.gzip\u0026#34;, \u0026#34;size\u0026#34;: 25573496, \u0026#34;digest\u0026#34;: \u0026#34;sha256:fd03b214f77493ccb73705ac5417f16c7625a7ea7ea997e939c9241a3296763b\u0026#34; }, ...... ] } 这个格式的 Manifest 包含了镜像的 Config 的信息以及 Layer 的格式和 Digest 信息。\nschemaVersion: 2, mediaType: \u0026quot;application/vnd.docker.distribution.manifest.list.v2+json\u0026quot;\n这个格式的 Manifest List 包含一个 manifests 列表：\n// skopeo inspect docker://docker.io/library/nginx:1.22 --raw | jq { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.list.v2+json\u0026#34;, \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;manifests\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.v2+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:9081064712674ffcff7b7bdf874c75bcb8e5fb933b65527026090dacda36ea8b\u0026#34;, \u0026#34;size\u0026#34;: 1570, \u0026#34;platform\u0026#34;: { \u0026#34;architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;os\u0026#34;: \u0026#34;linux\u0026#34; } }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.v2+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:cf4ffe24f08a167176c84f2779c9fc35c2f7ce417b411978e384cbe63525b420\u0026#34;, \u0026#34;size\u0026#34;: 1570, \u0026#34;platform\u0026#34;: { \u0026#34;architecture\u0026#34;: \u0026#34;arm64\u0026#34;, \u0026#34;os\u0026#34;: \u0026#34;linux\u0026#34; } } ] } 例如在 x86_64 (amd64) 架构的 Linux 主机上拉取 TAG docker.io/library/nginx:1.22 时，会根据此 Manifest List，拉取 Digest 为 sha256:9081064712674ffcff7b7bdf874c75bcb8e5fb933b65527026090dacda36ea8b 的镜像。在 aarch64 (arm64v8) 架构的 Linux 主机上拉取此 TAG 时，会根据 Manifest List，拉取 Digest 为 sha256:cf4ffe24f08a167176c84f2779c9fc35c2f7ce417b411978e384cbe63525b420 的镜像，在其他 OS 的主机上无法拉取这个 TAG 对应的镜像 (例如在 arm32v7 的 Linux 主机上拉取会失败)。\nmanifests 列表中，每个 digest 字段存储的是这个镜像的 Manifest 内容的 sha256 校验和。\n可以用 skopeo inspect 查看一下这个 digest 的镜像的 Manifest 内容，其格式为 schemaVersion: 2, mediaType: \u0026quot;application/vnd.docker.distribution.manifest.v2+json\u0026quot;\n// skopeo inspect docker://nginx@sha256:9081064712674ffcff7b7bdf874c75bcb8e5fb933b65527026090dacda36ea8b --raw | jq { \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.v2+json\u0026#34;, \u0026#34;config\u0026#34;: { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.container.image.v1+json\u0026#34;, \u0026#34;size\u0026#34;: 7898, \u0026#34;digest\u0026#34;: \u0026#34;sha256:0f8498f13f3adef3f3c8b52cdf069ecc880b081159be6349163d144e8aa5fb29\u0026#34; }, \u0026#34;layers\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.image.rootfs.diff.tar.gzip\u0026#34;, \u0026#34;size\u0026#34;: 31411405, \u0026#34;digest\u0026#34;: \u0026#34;sha256:f1f26f5702560b7e591bef5c4d840f76a232bf13fd5aefc4e22077a1ae4440c7\u0026#34; }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.image.rootfs.diff.tar.gzip\u0026#34;, \u0026#34;size\u0026#34;: 25573496, \u0026#34;digest\u0026#34;: \u0026#34;sha256:fd03b214f77493ccb73705ac5417f16c7625a7ea7ea997e939c9241a3296763b\u0026#34; }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.image.rootfs.diff.tar.gzip\u0026#34;, \u0026#34;size\u0026#34;: 626, \u0026#34;digest\u0026#34;: \u0026#34;sha256:ef2fc869b944b87eaf25f4c92953dc69736d5d05aa09f66f54b0eea598e13c9c\u0026#34; }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.image.rootfs.diff.tar.gzip\u0026#34;, \u0026#34;size\u0026#34;: 958, \u0026#34;digest\u0026#34;: \u0026#34;sha256:ac713a9ef2cca7a82e27f0277e4e3d25c64d1cf31e4acd798562d5532742f5ef\u0026#34; }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.image.rootfs.diff.tar.gzip\u0026#34;, \u0026#34;size\u0026#34;: 773, \u0026#34;digest\u0026#34;: \u0026#34;sha256:fd071922d543e072b21cb41a513634657049d632fe48cfed240be2369f998403\u0026#34; }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.image.rootfs.diff.tar.gzip\u0026#34;, \u0026#34;size\u0026#34;: 1405, \u0026#34;digest\u0026#34;: \u0026#34;sha256:2a9f38700bb5a0462e326fe3541b45f24a677ac3cd386c4922d48da5fbb6f0a8\u0026#34; } ] } 镜像的 Digest 实际上是这个镜像的 Manifest 内容的 sha256sum 校验和：\n$ skopeo inspect --raw docker://nginx@sha256:9081064712674ffcff7b7bdf874c75bcb8e5fb933b65527026090dacda36ea8b { \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.v2+json\u0026#34;, \u0026#34;config\u0026#34;: { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.container.image.v1+json\u0026#34;, \u0026#34;size\u0026#34;: 7898, \u0026#34;digest\u0026#34;: \u0026#34;sha256:0f8498f13f3adef3f3c8b52cdf069ecc880b081159be6349163d144e8aa5fb29\u0026#34; }, ...... $ skopeo inspect --raw docker://nginx@sha256:9081064712674ffcff7b7bdf874c75bcb8e5fb933b65527026090dacda36ea8b | sha256sum 9081064712674ffcff7b7bdf874c75bcb8e5fb933b65527026090dacda36ea8b - 同理，Config 的 Digest 为镜像的 Config 内容的 sha256sum 校验和：\n$ skopeo inspect --raw --config docker://nginx@sha256:9081064712674ffcff7b7bdf874c75bcb8e5fb933b65527026090dacda36ea8b | sha256sum 0f8498f13f3adef3f3c8b52cdf069ecc880b081159be6349163d144e8aa5fb29 - 除了上面的几种 Docker 镜像的 Manifest 格式外，还有 OCI 容器镜像 这种格式的 Manifest:\nschemaVersion: 2, mediaType: \u0026quot;application/vnd.oci.image.manifest.v1+json\u0026quot; // skopeo inspect docker://quay.io/skopeo/stable@sha256:9da6763a4d35592a6279e851738472d9cdaa8ff5a5da3c50b560f065d22c2bff --raw | jq { \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34;, \u0026#34;config\u0026#34;: { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.config.v1+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:6acf3c9f5dd48704618fa7ec2b95968a45c9e7809926a1f90f383bea4e9b3ede\u0026#34;, \u0026#34;size\u0026#34;: 3032 }, \u0026#34;layers\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.layer.v1.tar+gzip\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:529411ad578ab92819185dd8ef493eaa1eecc4f62b2ed2199db99ae23e6bf4cd\u0026#34;, \u0026#34;size\u0026#34;: 73881106 }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.layer.v1.tar+gzip\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:eeaa0b0d534352a9398996bcff9dc1184a78d310c22800aa6de07a6e2b1f8864\u0026#34;, \u0026#34;size\u0026#34;: 54520878 }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.layer.v1.tar+gzip\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:5ebf46cd2e6b356313b1dce504191fefce45df90dd8b5df7fe6b8cdd0fd06667\u0026#34;, \u0026#34;size\u0026#34;: 1849 }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.layer.v1.tar+gzip\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:d4779f97b4911cd73b8bbe8b96c6759b6f5c210928020e0c351294e7136aeb94\u0026#34;, \u0026#34;size\u0026#34;: 4061 }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.layer.v1.tar+gzip\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:f2e09c14b28b7453b48d13aace7cef657580e3b1cfdc0be8cfb9e685862a068f\u0026#34;, \u0026#34;size\u0026#34;: 228 } ], \u0026#34;annotations\u0026#34;: { \u0026#34;org.opencontainers.image.base.digest\u0026#34;: \u0026#34;sha256:7acf70fa27721ef08357823d79324a19d7e9b0d34873c93f33a1b654d784e3c4\u0026#34;, \u0026#34;org.opencontainers.image.base.name\u0026#34;: \u0026#34;registry.fedoraproject.org/fedora:latest\u0026#34; } } schemaVersion: 2, mediaType: \u0026quot;application/vnd.oci.image.index.v1+json\u0026quot; // skopeo inspect docker://quay.io/skopeo/stable:latest --raw | jq { \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.index.v1+json\u0026#34;, \u0026#34;manifests\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:3f678eca3035c64243c70598efeb4f60ef06a07b156444e21feed9488d47944b\u0026#34;, \u0026#34;size\u0026#34;: 1239, \u0026#34;platform\u0026#34;: { \u0026#34;architecture\u0026#34;: \u0026#34;arm64\u0026#34;, \u0026#34;os\u0026#34;: \u0026#34;linux\u0026#34; } }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:72464a265722c05436b5f46b9247929a882e73462f33ac1c000f4a34094fc90c\u0026#34;, \u0026#34;size\u0026#34;: 1239, \u0026#34;platform\u0026#34;: { \u0026#34;architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;os\u0026#34;: \u0026#34;linux\u0026#34; } } ] } Library containers 和 opencontainers Org 提供了许多容器镜像相关的 Go Library，例如：\ncontainers/image containers/common opencontainers/image-spec Docker Manifest 格式的定义位于代码：containers/image/v5/manifest\nOCI 容器镜像的 Manifest 格式定义位于代码：opencontainers/image-spec/specs-go/v1\nskopeo inspect 的代码位于 containers/skopeo/cmd/skopeo/inspect.go，skopeo 用了 cobra 框架来处理用户的命令行参数（这里悄悄安利一下 cobra 框架真的很好用，尤其是当你的程序有许多的子命令，每个子命令需要处理的参数还都不一样的情况），执行查询镜像 Manifest 的代码都在 run 函数里面。\n下面是咱写的一个栗子，使用上述的 Library 模拟一下 skopeo inspect 查看容器镜像 Manifest 的功能，其实查看容器镜像 Manifest 的代码实现还是蛮简单的：\npackage example import ( \u0026#34;context\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/containers/image/v5/transports/alltransports\u0026#34; \u0026#34;github.com/containers/image/v5/types\u0026#34; ) func Test_Inspect(t *testing.T) { // reference name format: docker://\u0026lt;image\u0026gt;:\u0026lt;tag\u0026gt; refName := \u0026#34;docker://docker.io/library/nginx:latest\u0026#34; ref, err := alltransports.ParseImageName(refName) if err != nil { t.Errorf(\u0026#34;ParseImageName: %v\u0026#34;, err) return } sysCtx := \u0026amp;types.SystemContext{ DockerAuthConfig: \u0026amp;types.DockerAuthConfig{ Username: \u0026#34;\u0026#34;, // docker username (optional) Password: \u0026#34;\u0026#34;, // docker password (optional) }, // set to true if server is HTTP or using insecure certificate OCIInsecureSkipTLSVerify: false, DockerInsecureSkipTLSVerify: types.NewOptionalBool(false), } source, err := ref.NewImageSource(context.TODO(), sysCtx) if err != nil { t.Errorf(\u0026#34;NewImageSource: %v\u0026#34;, err) return } data, mime, err := source.GetManifest(context.TODO(), nil) if err != nil { t.Errorf(\u0026#34;GetManifest: %v\u0026#34;, err) return } fmt.Printf(\u0026#34;Manifest mediaType: %v\\n\u0026#34;, mime) fmt.Printf(\u0026#34;Manifest RAW data: \\n%v\\n\u0026#34;, string(data)) // reformat output var obj any if err = json.Unmarshal(data, \u0026amp;obj); err != nil { t.Errorf(\u0026#34;Unmarshal: %v\u0026#34;, err) return } if data, err = json.MarshalIndent(obj, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;); err != nil { t.Errorf(\u0026#34;MarshalIndent: %v\u0026#34;, err) return } fmt.Printf(\u0026#34;===================================\\n\u0026#34;) fmt.Printf(\u0026#34;Manifest data: \\n%v\\n\u0026#34;, string(data)) } 接下来，是构建 Manifest List 索引的一个简单栗子，假设你分别向 Registry Server 上传了 \u0026lt;namespace\u0026gt;/example:v1.0.0-amd64 和 \u0026lt;namespace\u0026gt;/example:v1.0.0-arm64 两个不同架构的容器镜像，你希望用户在 AMD64 架构的主机上拉取 \u0026lt;namespace\u0026gt;/example:v1.0.0 的 TAG 时，自动拉取 \u0026lt;namespace\u0026gt;/example:v1.0.0-amd64 这个镜像，而在 ARM64 架构的主机上拉取时，自动拉取 \u0026lt;namespace\u0026gt;/example:v1.0.0-arm64 这个镜像。\n这里说的 Manifest List 实际是 schemaVersion 2, mediaType: \u0026quot;application/vnd.docker.distribution.manifest.list.v2+json\u0026quot;\n基本上你可以使用任何的 Registry Server，但 Harbor V1 除外，因为 Harbor V1 不支持 Manifest List。\npackage example import ( \u0026#34;context\u0026#34; \u0026#34;crypto/sha256\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/containers/image/v5/manifest\u0026#34; \u0026#34;github.com/containers/image/v5/transports/alltransports\u0026#34; \u0026#34;github.com/containers/image/v5/types\u0026#34; \u0026#34;github.com/opencontainers/go-digest\u0026#34; ) func sha256sum(data []byte) string { sum := sha256.Sum256(data) return fmt.Sprintf(\u0026#34;%x\u0026#34;, sum) } func getManifest(refName string, ctx *types.SystemContext) ([]byte, string, error) { // reference name format: docker://\u0026lt;image\u0026gt;:\u0026lt;tag\u0026gt; ref, err := alltransports.ParseImageName(refName) if err != nil { return nil, \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;ParseImageName: %w\u0026#34;, err) } source, err := ref.NewImageSource(context.TODO(), ctx) if err != nil { return nil, \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;NewImageSource: %v\u0026#34;, err) } return source.GetManifest(context.TODO(), nil) } func Test_BuildManifest(t *testing.T) { // reference name format: docker://\u0026lt;image\u0026gt;:\u0026lt;tag\u0026gt; refName := \u0026#34;docker://\u0026lt;REGISTRY_URL:PORT\u0026gt;/\u0026lt;NAMESPACE\u0026gt;/example:v1.0.0\u0026#34; ref, err := alltransports.ParseImageName(refName) if err != nil { t.Errorf(\u0026#34;ParseImageName: %v\u0026#34;, err) return } sysCtx := \u0026amp;types.SystemContext{ DockerAuthConfig: \u0026amp;types.DockerAuthConfig{ Username: \u0026#34;\u0026#34;, // registry username (required) Password: \u0026#34;\u0026#34;, // registry password (required) }, // set to true if server is HTTP or using insecure certificate OCIInsecureSkipTLSVerify: false, DockerInsecureSkipTLSVerify: types.NewOptionalBool(false), } manifestList := manifest.Schema2List{ SchemaVersion: 2, MediaType: manifest.DockerV2ListMediaType, Manifests: []manifest.Schema2ManifestDescriptor{}, } // add amd64 data data, mime, err := getManifest(\u0026#34;docker://\u0026lt;REGISTRY_URL:PORT\u0026gt;/\u0026lt;NAMESPACE\u0026gt;/example:v1.0.0-amd64\u0026#34;, sysCtx) if err != nil { t.Errorf(\u0026#34;getManifest: %v\u0026#34;, err) return } manifestList.Manifests = append(manifestList.Manifests, manifest.Schema2ManifestDescriptor{ Schema2Descriptor: manifest.Schema2Descriptor{ MediaType: mime, Size: int64(len(data)), Digest: digest.Digest(sha256sum(data)), }, Platform: manifest.Schema2PlatformSpec{ Architecture: \u0026#34;amd64\u0026#34;, OS: \u0026#34;linux\u0026#34;, OSVersion: \u0026#34;\u0026#34;, Variant: \u0026#34;\u0026#34;, }, }) // add arm64 data data, mime, err = getManifest(\u0026#34;docker://\u0026lt;REGISTRY_URL:PORT\u0026gt;/\u0026lt;NAMESPACE\u0026gt;/example:v1.0.0-arm64\u0026#34;, sysCtx) if err != nil { t.Errorf(\u0026#34;getManifest: %v\u0026#34;, err) return } manifestList.Manifests = append(manifestList.Manifests, manifest.Schema2ManifestDescriptor{ Schema2Descriptor: manifest.Schema2Descriptor{ MediaType: mime, Size: int64(len(data)), Digest: digest.Digest(sha256sum(data)), }, Platform: manifest.Schema2PlatformSpec{ Architecture: \u0026#34;arm64\u0026#34;, OS: \u0026#34;linux\u0026#34;, OSVersion: \u0026#34;\u0026#34;, Variant: \u0026#34;v8\u0026#34;, }, }) dest, err := ref.NewImageDestination(context.TODO(), sysCtx) if err != nil { t.Errorf(\u0026#34;NewImageSource: %v\u0026#34;, err) return } if data, err = json.MarshalIndent(manifestList, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;); err != nil { t.Errorf(\u0026#34;MarshalIndent: %v\u0026#34;, err) return } if err = dest.PutManifest(context.TODO(), data, nil); err != nil { t.Errorf(\u0026#34;PutManifest: %v\u0026#34;, err) return } } 构建 Manifest 的栗子中，用到了一部分 Manifest 的代码，用来获取 amd64 架构的镜像和 arm64 架构镜像的 Manifest 文本长度，并计算 Digest。\n","permalink":"https://blog.starry-s.moe/posts/2023/container-manifest/","summary":"\u003cp\u003e最近总在弄些容器镜像相关的东西，于是分享一些咱自己总结的有关容器镜像 Manifest 格式、常用工具以及代码相关的芝士。\u003c/p\u003e","title":"容器镜像 Manifest 相关内容整理"},{"content":"年初逛了一趟漫展之后突然想换新的相机了，因为对手里的 EOS 800D 成像不是很满意，暗光的高感表现很差，ISO 800 的时候 RAW 格式稍微拉一下阴影就会出现许多噪点，所以打算换个更专业点的相机，开拓些新的领域。\n预算方面我把相机和镜头控制在了 1W 出头，尽管这个价位能买到前几年的全画幅微单，但是综合考虑了一阵子后还是入手了佳能去年新出的 APS-C 画幅的 R7，用转接环可以搭配我已有的 EF/EF-S 镜头，能稍微节省一点镜头的开销，主要是我还挺喜欢手里的适马 17-50 这个镜头的。\n因为 RF 卡口的镜头价格太贵了，所以入手相机之后搜了一些评价不错的 EF-S 镜头，于是就买了广角镜头适马 18-35，所以最终还是超预算了。\n相机到了之后试着到处溜达拍了一些照片，用着记忆里很久以前用诺基亚自学摄影时的那点知识拍了些照片，挑几张自认为觉得还行的照片放在这里。\n第一张是在中街用适马 17-50 拍的，后面那几张是在买了适马 18-35 之后去辽宁省博物馆拍的，最后一张是笨蛋公主的 Q 版手办，也是用适马 18-35 拍的，这几张我就稍微调了颜色，没有其他后期，很久没练习拍照了，这几张图就看看就行。\n拿巨沉的人像广角镜头去拍实物特写，唉我真的是不知道咋想的……\n","permalink":"https://blog.starry-s.moe/posts/2023/canon-eos-r7/","summary":"\u003cp\u003e年初逛了一趟漫展之后突然想换新的相机了，因为对手里的 EOS 800D 成像不是很满意，暗光的高感表现很差，ISO 800 的时候 RAW 格式稍微拉一下阴影就会出现许多噪点，所以打算换个更专业点的相机，开拓些新的领域。\u003c/p\u003e","title":"“关于我逛了一趟漫展然后换了新的相机和镜头这件事”"},{"content":"为了让咱的 NAS 长时间稳定运行，斥巨资买了一台 APC BK650M2-CH，在 Arch Wiki 上看 APC 的 UPS 对 Linux 的支持比较友好，于是挑了个最便宜的带停电自动关机的 APC UPS，防止咱啥时候忘了交电费导致停电数据受损。\n参烤链接: APC UPS - ArchWiki\nUPS 到手后花了半个多小时读使用说明书，然后第一件事是把 UPS 的断电报警蜂鸣器关掉，省得我不在公寓的时候停电了 UPS 叫个没完吵到邻居。\n之后在装 UPS 之前先把我电脑支架背面一团电线重新整理了一遍，现在是台式机、显示器、NAS、光猫、路由器、无线 AP 都放在一起了，他们的电源线、网线、数据线、显示器线都团在了一起，整理起来炒鸡麻烦。\n先把漏油器、光猫和 NAS 的电源都插 UPS 上，然后接好 UPS 的 USB 数据线到 NAS 上。\n安装 apcupsd 安装 apcupsd，然后 systemctl enable --now apcupsd.service。\n$ sudo apcaccess status APC : 001,036,0869 DATE : 2023-01-08 11:09:23 +0800 HOSTNAME : ApertureNAS VERSION : 3.14.14 (31 May 2016) unknown UPSNAME : ApertureNAS CABLE : USB Cable DRIVER : USB UPS Driver UPSMODE : Stand Alone STARTTIME: 2023-01-02 23:57:44 +0800 MODEL : Back-UPS BK650M2-CH STATUS : ONLINE ...... 先把 NAS 里所有的应用都停掉，之后编辑 /etc/apcupsd/apcupsd.conf，把 TIMEOUT 改为 1，然后给 UPS 断电，这时 NAS 会自动关机。\nUPS 重新连接电源后，NAS 可能会自动开机，我的 NAS 是这样，但不确定所有 NAS 都这样。\n配置自动休眠 按照 Wiki 配置停电后自动休眠 (Hibernate / 休眠到硬盘)。\n在此之前，需要创建 swap 分区 (或 swap file)，然后配置休眠需要的内核参数并重构 initramfs。\n以 root 用户创建 /usr/local/bin/hibernate：\n#!/bin/bash # Hibernate the system - designed to be called via symlink from /etc/apcupsd # directory in case of apcupsd initiating a shutdown/reboot. Can also be used # interactively or from any script to cause a hibernate. # 可以在这里加一些在休眠之前执行的操作，例如让 bot 发个邮件提醒停电了之类的 # Wall message # 广播消息 wall -n System will be hibernate soon sleep 1 # Do the hibernate # 执行休眠 /usr/bin/systemctl hibernate # At this point system should be hibernated - when it comes back, we resume this script here # 现在，系统应当已经休眠了，当系统恢复运行的时候，脚本会继续从这里执行 # 可以在这里加一些在系统恢复之后的操作，例如让 bot 发个邮件提醒电力恢复了啥的 # On resume, tell controlling script (/etc/apcupsd/apccontrol) NOT to continue with default action (i.e. shutdown). exit 99 别忘了赋予可执行权限。\n# chmod +x /usr/local/bin/hibernate 创建软链接把脚本链接到 /etc/apcupsd 目录下面。\n# ln -s /usr/local/bin/hibernate /etc/apcupsd/doshutdown 此时给 UPS 断电后，NAS 会自动休眠，等一两分钟 NAS 会完成休眠，但 UPS 仍处于运行状态没有关机，长时间停电的话，UPS 的电量会耗尽。\nUPS 接回电源后，NAS 会从休眠中恢复。\n配置休眠后关闭 UPS 电源 创建 /usr/lib/systemd/system-sleep/ups-kill：\n#!/bin/bash case $2 in # In the event the computer is hibernating. hibernate) case $1 in # Going into a hibernate state. pre) # See if this is a powerfail situation. if [ -f /etc/apcupsd/powerfail ]; then echo echo \u0026#34;ACPUPSD will now power off the UPS\u0026#34; echo /etc/apcupsd/apccontrol killpower echo echo \u0026#34;Please ensure that the UPS has powered off before rebooting\u0026#34; echo \u0026#34;Otherwise, the UPS may cut the power during the reboot!!!\u0026#34; echo fi ;; # Coming out of a hibernate state. post) # If there are remnants from a powerfail situation, remove them. if [ -f /etc/apcupsd/powerfail ]; then rm /etc/apcupsd/powerfail fi # This may also exist, need to remove it. if [ -f /etc/nologin ]; then rm /etc/nologin fi # Restart the daemon; otherwise it may be unresponsive in a # second powerfailure situation. systemctl restart apcupsd ;; esac ;; esac 赋予可执行权限：\n# chmod +x /usr/lib/systemd/system-sleep/ups-kill 接下来给 UPS 断电，NAS 会自动休眠，等 NAS 休眠后再过几分钟 UPS 也会关机。\nUPS 关机后，给 UPS 接上电源，这时 UPS 会自动开机，然后 NAS 也会从休眠中恢复。\n不要在 UPS 还没关机的时候给 UPS 重新接回电源，会导致 UPS 关机后 NAS 刚从休眠中恢复就被强制断电。\n其他 折腾 UPS 的时候顺手给 NAS 换了个散热器升级了一下内存。AMD 原装散热器有亿点点吵所以换成了咱之前买的 ITX 散热器。\n用咱写的 telebot 查看一下空载时的 CPU 温度才不到 30 度。\nCPU: +28.2°C Uptime: 0.15 Hour TotalRAM: 46.45G FreeRAM: 42.66G AvailableRAM: 43.91G TotalSwap: 46.00G FreeSwap: 46.00G 运行一个虚拟机一个 MineCraft 服务器，CPU 温度不到 40，所以很安静。\n但是 UPS 它有噪音，晚上睡觉的时候能听见 UPS 它嗡嗡响，比 AMD 散热器的风扇动静还大，这个实在是无解，算了就先这样吧。\n","permalink":"https://blog.starry-s.moe/posts/2023/apc-ups/","summary":"\u003cp\u003e为了让咱的 NAS 长时间稳定运行，斥巨资买了一台 APC BK650M2-CH，在 Arch Wiki 上看 APC 的 UPS 对 Linux 的支持比较友好，于是挑了个最便宜的带停电自动关机的 APC UPS，防止咱啥时候忘了交电费导致停电数据受损。\u003c/p\u003e","title":"入手一台家用级 APC UPS"},{"content":"差不多去年的这个时候尝试过用树莓派插移动硬盘的方式试探性的组装了一个 NAS，但实际上用了不到两天这个方案就被废弃掉了……\n起因 不用树莓派的原因是，它是 ARM 架构的微型“电脑”，Arch Linux 官方只支持 x86_64 架构的系统，Arch Linux ARM 准确来说实际上是个第三方的系统。 然后树莓派的性能很差，只有一个板载网卡和 2.4G 无线网卡（我手里的是树莓派 3B），所以这玩意实际上更适合做嵌入式什么的，或者给初学者折腾入门 Linux 来用（但是看了眼现在树莓派的售价，我想应该不会有初学者买树莓派入门 Linux 了）。\n后来买了 NanoPi R4S 软路由，它内置了一个 RK3399 CPU，虽然也是 ARM 架构但是性能对于软路由来说很够用了，当时也是给它折腾了 Arch Linux ARM 系统还依次尝试了 systemd-networkd 和 netctl 给它的两个网口配置路由，但折腾归折腾，这种方式并不稳定，在日常使用过程中经常遇到重启路由器后上不去网的情况，还要手动 SSH 到路由器中再重启一次网络服务和防火墙才恢复。虽然手动改网络组件的配置文件的方式配置个路由器更底层些，这个过程也能更好的体会到路由器的一些原理，但是这种方案并不适合长期日常使用，我可不希望动不动家里路由器莫名其妙就断网了还要手动 SSH 到系统里查一堆日志后才能重连网络。\n之后我把手里的 R4S 卖掉了，因为 NanoPi 新发布了性价比更高且功耗更低的，拥有俩 2.5G LAN 网口，还有一个 M2 插槽和内置了 8G 闪存的 R5S。我给它安装了更适合路由器使用的基于 OpenWRT 构建的 FriendlyWRT 系统，这个系统内置了 Docker 和一些常用的应用（网络共享、Aria2、硬盘自动休眠之类的），在把光猫改桥接后，用它来做我的主路由器。然后把手里一块空闲的 2T 移动硬盘连接到路由器上，设置了 OpenWRT 的网络共享 (Samba) 服务后，实验性的当作我的 NAS 来使用。\n之所以是“实验性”的“NAS”，是因为我不确定 USB 连接移动硬盘的方式是否稳定，因为移动硬盘对供电有一定要求，我并不确定路由器的 USB 接口能否稳定的为硬盘供电，就算连接一块硬盘供电够用的话，我不确定连接两块以上的硬盘组磁盘阵列还能不能带得动，尽管这个问题能通过一根 USB 供电线来解决，但是我那半个巴掌大小的路由器上面既要插三根巨粗无比的 7 类网线，又要插硬盘和 USB 供电线，还要再占用一个插座插一个手机充电器给移动硬盘供电，这也太混乱了点，毕竟机械硬盘在读写过程中很怕震动，我在插拔网线或者插座上其他的电器时都避免不了的会对那块移动硬盘产生震动。\n然后路由器毕竟是路由器，你即要它负责整个家庭几十个网络设备的路由功能，又要跑 Samba 服务器，还要往里面装一些“上网插件”的话，对 CPU 的性能还是有一定要求的。因为我的路由器和电脑都有 2.5G 网口，所以我实际测试过当通过 Samba 拷贝文件的速度接近于 200MB/S 时，路由器的 CPU 4个核心就会全跑到 100%，然后拷贝就卡住了，时间久了文件就拷贝失败了（然后我不得不又设置了 QoS 把 2.5G 的网口限速成千兆网口）。\n所以最好的办法还是把 NAS 和路由器分开，路由器就用来做路由器该做的事情，NAS 就做 NAS 该做的事情。\n以上就是我组装 NAS 的整个心路历程，如果觉得上面这一大堆太磨叽的话，直接看下面就好了。\n配置清单 机箱：乔伯思 N1 主板：映泰 B550T-SILVER ITX CPU：AMD R7 5700G 内存：英睿达 8G 2666 固态：闪迪 500G NVME 硬盘：东芝 MG08ACA16TE * 1 电源：Tt SFX钢影 450W 其他：乐扩 4 口 2.5G PCIE 网卡 系统盘是之前折腾软路由时剩下的一块 500G 的 NVME 固态，除此之外双十一的时候还买了一块东芝的 16T 企业盘。\n本来想把除硬盘外的整体预算控制在 2K 以内的，但实际上光主板 + CPU 就两千多了……\n在深水宝上有更便宜的 5600G + B450 ITX 套装，但是这种来路不明的主板和散片 CPU 尽管便宜了几百块钱但是我也不知道它的 CPU 有没有“锻炼”过，主板有没有换过啥零件，反正我是不敢买。所以挑了好久，决定提高了预算，在狗东买的全新的板 U 套装，选的这个带板载 2.5G 网卡的主板，毕竟我可不想贪小便宜吃大亏。\n散热器目前用的是 AMD 盒装 CPU 带的散热，听说这个散热器在拆的时候极有可能会把 CPU 连根拔起，但是我有一个闲置的利民的 itx 散热器放在老家了没拿过来，所以现在只好先用原装的过度一下。\n本来是没打算买机械硬盘的，想着先用移动硬盘连在 NAS 上先用一阵子的，不过双十一硬盘便宜了好多，信用卡分三期还能再减 50，所以就先买了一块，估计够我用很长时间的了。\n装机 映泰的这块板子是不带无线网卡的，但送了一个 WIFI5 的无线网卡，需要手动安装上去，当时废了九牛二虎之力才接上了这两根 SMA 线……。\n然后走线的过程其实还挺顺利的，插上主板 24PIN、CPU 8PIN 和 SATA 供电以及风扇、机箱前面板跳线和 USB、音频线之外就完事了，找一些空隙把这些线绑起来就好了，说实话走线的过程可比之前给先马趣造装机容易多了，毕竟少了两根显卡供电线和一堆风扇的电源线还有 RGB 灯的线……\n装系统 NAS 的系统我采用的是 Arch Linux。首先，选一个 NAS 的系统肯定要优先考虑更适合做服务器的 Linux，其次 FreeNAS 这个系统是基于 FreeBSD/Unix 的，我就是单纯的不想用 BSD 所以就把它排除在方案外了（但是 NAS 里装一个虚拟机跑 FreeNAS 也不是不可以），至于网上总能听到的黑群晖我对这种盗版 + 闭源的系统很反感，所以想都不要想了。提到 Linux 的服务器发行版肯定有人更偏向于 Debian 以及 Debian 衍生的服务器系统以及红帽系列的被经常用在服务器的那些企业常用 Linux 系统，但是我只想用我熟悉的 Arch Linux。Arch Linux 的 Wiki 中有介绍过，Arch Linux 的思维是这个系统并不针对某类应用场景，而是让 Arch 的用户自己配置自己的系统来应用在哪些场景，所以理论上是可以把 Arch Linux 配置成一个适合应用在服务器上的系统，实际上也有 vps2arch 这个“黑魔法”脚本可以一键把 VPS 上已安装的其他 Linux 系统转成 Arch Linux。如果在这里你非要和我较真哪个 Linux 发行版好，哪个 Linux 发行版不好的话，我觉得这并不属于一个技术范围该讨论的问题而是一个哲学问题。\n安装教程在 Wiki 上就能找到，这里不再赘述，安装系统时需要装一些网络相关的软件，我配置网络使用的是 netctl，因为觉得 systemd-networkd 不怎么好用，我对 NetworkManager 不怎么熟悉所以就没装这个。然后配置无线连接时还需要用到 wpa_supplicant。\n配置网络 我的 NAS 上面一共有 5 个网口，其中一个网口为板载的 2.5G 网口，另外四个网口为 2.5G 的 PCIE 网口，我当初买这个 PCIE 网卡的时候想的是给它配置个桥接当交换机来用，这样只买一块网卡肯定比买个 4 口交换机便宜，因此装系统后配置网络这部分是重头戏，Arch Linux Wiki 上对配置桥接这部分只是简单介绍了几句就完事了，所以这部分我足足花了两个晚上才全部搞定。\n首先创建 netctl 的配置文件 /etc/netctl/bridge-br0 (文件名可以随意修改)，新创建一个虚拟的桥接接口 br0，这个虚拟的桥接网口绑定了上述的5个网口。我打算将板载的网口 (enp9s0) 连接路由器，然后那 4 个 PCIE 网卡的接口 (enp3s0 - enp6s0) 用来连接其他网络设备，所以要将 br0 的 MAC 地址设定为 enp9s0 的 MAC 地址。\n$ cat /etc/netctl/bridge-br0 Description=\u0026#34;Example Bridge connection\u0026#34; Interface=br0 # 接口的名称 Connection=bridge # 桥接模式 BindsToInterfaces=(enp9s0 enp6s0 enp5s0 enp4s0 enp3s0) # 将 br0 绑到 5 个物理网口上 MACAddress=enp9s0 # 设定 br0 的 MAC 地址与 enp9s0 接口的 MAC 地址一致 IP=dhcp # 以 DHCP 的方式为 br0 获取 IP 地址 除此之外还要配置 enp9s0 接口的配置文件 /etc/netctl/noip-enp9s0，不要让这个接口自动获取 IP 地址。\n$ cat /etc/netctl/noip-enp9s0 Description=\u0026#39;Example configuration\u0026#39; Interface=enp9s0 Connection=ethernet IP=no 之后执行以下命令使以上两个配置文件生效。\n# netctl enable bridge-br0 # netctl start bridge-br0 # netctl enable noip-enp9s0 # netctl start noip-enp9s0 顺利的话，执行 ip addr 可以看到新增加了一个 br0 网口 （不顺利的话就重启一下，再检查一下除了 netctl 之外是不是有别的配置网络的应用产生了干扰），然后原有的 5 个网口都绑定到了 br0 接口上了（接口的那一行出现了 br0）。\n然后 enp9s0 接口正常来讲是不应该从路由器上获取到 IP 地址的了，取而代之的是 br0 接口从路由器的 DHCP 服务器中获取了一个 IP 地址，然后 br0 接口的 MAC 地址和 enp9s0 接口的 MAC 地址都一致才对。\n以下是一个简单的栗子，在不考虑 IPv6 的情况 ip a 的输出是类似酱紫的：\n$ ip addr 1: enp3s0: \u0026lt;NO-CARRIER,BROADCAST,MULTICAST,PROMISC,UP\u0026gt; mtu 1500 qdisc fq_codel master br0 state DOWN group default qlen 1000 link/ether ab:cd:ef:xx:xx:xx brd ff:ff:ff:ff:ff:ff 2: enp4s0: \u0026lt;NO-CARRIER,BROADCAST,MULTICAST,PROMISC,UP\u0026gt; mtu 1500 qdisc fq_codel master br0 state DOWN group default qlen 1000 link/ether ab:cd:ef:xx:xx:xx brd ff:ff:ff:ff:ff:ff 这里 enp3s0 - enp6s0 这四个接口的情况基本一致所以在此省略 ...... 5: enp9s0: \u0026lt;BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel master br0 state UP group default qlen 1000 link/ether f4:bb:22:xx:xx:xx brd ff:ff:ff:ff:ff:ff ...... 6: br0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether f4:bb:22:xx:xx:xx brd ff:ff:ff:ff:ff:ff inet 10.10.10.233/24 brd 10.10.10.255 scope global dynamic noprefixroute br0 valid_lft 1606601sec preferred_lft 1375801sec ...... 至此，NAS 是可以与路由器下的同一局域网内的其他设备互相访问的，然后检查下 /etc/resolv.conf 如果 DNS 配置正确了的话，也是可以访问到公网的，执行 curl baidu.com 是应该有返回的内容的。\n但是我们目前只配置了 NAS 自身的板载网口 (enp9s0) 与 br0 虚拟网口的桥接这部分，现在其他设备通过网线插到 PCIE 网卡的那4个接口是上不去网的。\n在计网课程中，老师曾反复强调路由器和交换机的区别，路由器是 OSI 七层模型中的网络层的设备，而交换机是第二层的数据链路层的设备，但光是这么讲的话，死记硬背是能记住这两个设备之间的区别，但这种知识实在过于抽象，很难真正的理解，况且这个“网络模型”是按照已有的网络设备给它拆分成不同的层的，而并不是先制定出了分层的标准然后让设备严格按照这个模型去制作的，所以现在市面上卖的网络设备并没有体现出所谓的分层，不同的网络层之间的界限实际上是很模糊的。在网上搜这方面资料的时候看到有人把路由器称作“3 层交换机”，而常说的那种交换机则称为“2 层交换机”。说实话我也没彻底的搞明白数据链路层和网络层以及路由器和交换机之间的具体区别，不过往简单了说，可以把路由器看成是一个根据 IP 地址在不同的网段之间分发数据的设备，而交换机是通过 MAC 地址，只在一个网段内分发数据的设备，市面上常见的售卖的“路由器”商品实际上是一个真正意义上的路由器 + 交换机 + DHCP服务器和其他组件的组合体，知道这些基本就够用了，再往详细了讲的话我也讲不明白了。\n然后修改 PCIE 网卡的 4 个接口 enp3s0 - enp6s0 的 MAC 地址和板载网口 enp9s0 的 MAC 地址一致，这样5个网口和虚拟的 br0 网口都使用同一个 MAC 地址，就能实现交换机的功能了，至于为啥要把 5 个网口的 MAC 地址都设置一致这个别问我，我也不到为啥，如果这里有哪些知识点有误，可以评论告诉我。\n因为 netctl 好像不支持修改接口 MAC 地址的操作，所以这里还是要用到 systemd-networkd 在开机时自动修改网口的 MAC 地址，在 /etc/systemd/network/ 中创建 00-enp3s0.link - 00-enp6s0.link 这 4 个配置文件。\n# cat /etc/systemd/network/00-enp3s0.link [Match] # 这个是网口原有的 MAC 地址 MACAddress=aa:bb:cc:dd:xx:xx [Link] # 这个是修改后的 MAC 地址 MACAddress=f4:bb:22:xx:xx:xx NamePolicy=kernel database onboard slot path 确保 /etc/systemd/network/ 中没有其他的配置文件后，systemctl enable --now systemd-networkd 启动 systemd-networkd，在重启电脑后 5 个接口的 MAC 地址就都一致了。\n至此交换机这部分就配置完了。\n配置 Samba 目前我还没有机械硬盘，只有一个移动硬盘通过 USB 连接到了 NAS 上，目前我使用的是 hd-idle 配置了硬盘的自动启停。\n$ sudo hd-idle -a /dev/sda -i 300 然后安装 samba，在 /etc/samba/ 目录下创建 smb.conf，具体的过程请参照 Wiki。\n我把我的 16T 硬盘格式化成 btrfs 后挂载到了 /samba/hdd_16t_1 目录下面，然后对应的 Samba 配置文件为：\n[HDD16T1] force user = root comment = HDD 16T 1 path = /samba/hdd_16T_1 valid users = samba public = no writable = yes browsable = yes printable = no create mask = 0644 directory mask = 0755 read only = no 我打算只在内网访问我的 NAS，我还不打算把它暴露到公网上，所以目前不用太考虑安全的问题。\n然后我目前不考虑组 RAID，首先是因为没钱再买硬盘了，其次是 RAID 并不适合作为冗余备份使用，它没办法保证数据的绝对安全，所以如果我要存重要的数据的话，还是要往别的移动硬盘里也拷贝一份的，所以目前来看 RAID 我暂时用不上。\n东芝这块盘收货之后，我用 Samba 往里面烤了俩小时文件没遇到失败的情况，速度一直维持在 100MB/s 以上很稳定，至于噪音的话，白天是感觉不出来 NAS 的声音的，晚上因为配置了硬盘自动停转所以只要睡觉时不用它下载东西的话也是听不到声音的。\n其他 之所以买了 8 核 16 线程的 CPU 是因为我除了让它做 Samba 服务器之外还打算在上面跑一些别的服务啥的，目前除了 Samba 之外我在上面跑了 qemu KVM 虚拟机，然后在局域网搞了 Kubernetes 集群，因为公有云价格太贵了我自己租不起长时间的高性能 VPS，所以在本地起几个虚拟机装轻量级的集群用来学习 k8s 还是可以轻松实现的，不过我目前还没想好可以在集群里跑些什么东西。\n后续我打算把我的 MineCraft 单机生存的存档也放到 NAS 上面当服务器跑，这样就可以实现一些只有在服务器才能实现的操作了（比如挂个假人 24 小时挂机刷怪之类的）。\n以后有时间的话再写个 TeleBot 机器人啥的，用来远程监控 NAS 的状态。\nSTARRY-S\n","permalink":"https://blog.starry-s.moe/posts/2022/build-nas/","summary":"\u003cp\u003e差不多去年的这个时候尝试过用树莓派插移动硬盘的方式试探性的组装了一个 NAS，但实际上用了不到两天这个方案就被废弃掉了……\u003c/p\u003e","title":"NAS 装机记录"},{"content":"一直想玩的游戏没有官方汉化，Switch 的游戏文件没破解的话是没办法装汉化插件的，尽管咱有 Switch OLED 港版主机，但是破解有被封的可能而且过程过于麻烦，破解后就不能联网了，所以咱在买了正版游戏但是看不懂日语后无奈之下选择了虚拟机，正好水一篇博客。\n目前有两个虚拟机可选，一个是 由 C# 编写的 Ryujinx，另一个是由 C++ 编写的 yuzu，这俩都是开源软件而且都能在 Linux 上运行，咱选的是后者。\nyuzu 提供的教程需要短接器和一张TF卡以及 switch 本体，从 switch 中获取 prod.keys 和 title.keys （非必须），喜欢折腾的可以买个短接器慢慢鼓捣，教程链接：https://yuzu-emu.org/help/quickstart/。如果懒得折腾的话从网上找个现成的 key 文件也能用。\nArch Linux 可以从 archlinuxcn 源或者 AUR 中获取。\nsudo pacman -S yuzu-git 第一次启动时会提示缺少 keys，可先忽略，选择左上角 File-\u0026gt;Open yuzu Folder，新建一个 keys 文件夹，将 prod.keys 复制进去后重启软件。\nyuzu 可以在不手动安装系统的情况下运行游戏，所以添加了游戏所在的文件夹就能玩了。\n然后就是在设置里面改一下手柄的按键布局，因为用习惯了 Xbox 手柄，所以咱把 A 和 B 位置对调了一下。\n后续：\nYuzu 2023-05-21 之后的版本对宝可梦做了些优化导致玩月姬时文字花屏乱码，玩月姬的话不要下载 2023-05-21 (1440) 之后的版本。\n然后 Arch Linux 最近滚完系统后遇到了 yuzu 的 Qt 启动失败报错：\nWarning: Ignoring XDG_SESSION_TYPE=wayland on Gnome. Use QT_QPA_PLATFORM=wayland to run on Wayland anyway. qt.qpa.plugin: Could not find the Qt platform plugin \u0026#34;wayland\u0026#34; in \u0026#34;\u0026#34; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: xcb. zsh: IOT instruction (core dumped) yuzu 查了一阵子找到的解决办法是设置 QT_PLUGIN_PATH=/usr/lib/qt/plugins 环境变量，覆盖掉 yuzu 安装包自带的 Qt 插件而是改用系统的。\n","permalink":"https://blog.starry-s.moe/posts/2022/switch-emulator/","summary":"\u003cp\u003e一直想玩的游戏没有官方汉化，Switch 的游戏文件没破解的话是没办法装汉化插件的，尽管咱有 Switch OLED 港版主机，但是破解有被封的可能而且过程过于麻烦，破解后就不能联网了，所以咱在买了正版游戏但是看不懂日语后无奈之下选择了虚拟机，正好水一篇博客。\u003c/p\u003e","title":"yuzu - Switch 虚拟机"},{"content":"前一阵子通关了最终幻想7重置版，放几张截图到这里水一期博客。\n严重剧透警告：如不想被剧透请勿阅读本篇内容！\n卖花的大姐姐\nTifa\nAerith 的千层套路\nReunited\n云片好帅\n穿这么少的衣服，干的却是正经生意\n可爱捏\n爱丽丝老套路了\n比我想得还要可爱捏\n","permalink":"https://blog.starry-s.moe/posts/2022/finalfantasy-vii/","summary":"\u003cp\u003e前一阵子通关了最终幻想7重置版，放几张截图到这里水一期博客。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e严重剧透警告\u003c/strong\u003e：如不想被剧透请勿阅读本篇内容！\u003c/p\u003e\n\u003c/blockquote\u003e","title":"FinalFantasy VII Remake 游戏记录"},{"content":"最近搬了新的住处，用的是移动的宽带，因此尝试着把移动的光猫改成桥接，接到我的软路由上面。\n因为我不知道PPPoE拨号的帐号和密码，尽管这个光猫的超级密码网上一搜就能找到，但是我不知道PPPoE帐号的密码就算改了桥接也没办法拨号。 于是先借助网上能搜到的资料尝试把宽带帐号的密码给搞出来。\n一开始尝试着登录光猫的后台页面，在设置拨号上网的页面那里F12大法，把input元素的type=\u0026quot;password\u0026quot;改成type=\u0026quot;text\u0026quot;， 但是发现这里预填写的密码已经是加密过的******，因此这个方法行不通。\n然后看教程有说尝试打开光猫的telnet，把配置文件用ftp传出来，但是试了一下所有的尝试打开telnet的方式在这个光猫上都不好使，于是这个方法也行不通。\n之后在光猫登录管理员帐号之后，在“管理-\u0026gt;设备管理-\u0026gt;USB备份配置\u0026quot;这里找到了可以把配置文件备份到U盘的地方， 于是找了一张空内存卡格式化成FAT32，放读卡器里插在光猫上，把配置文件备份到U盘上。\n备份至USB\n这里备份之后不要立即把U盘拔下来，貌似光猫在备份完配置文件后没有立即把数据sync到U盘中，需要等一阵子再拔U盘。 等多久我也不确定，反复试几次直到U盘上出现了e8_Config_Backup文件夹就可以了。\n然后下载RouterPassView， 用这个工具打开配置文件，就可以找到里面光猫上的所有配置了，包括宽带帐号和密码。\n之后在网络设置里面改桥接，就可以用软路由拨号上网辣。\n使用了一下移动的宽带发现貌似他们把所有的ICMP的ECHO回显请求屏蔽掉了，所以尝试ping任何IP都是不通的。别的貌似没什么问题。\n","permalink":"https://blog.starry-s.moe/posts/2022/gm220-s-bridge-mode/","summary":"\u003cp\u003e最近搬了新的住处，用的是移动的宽带，因此尝试着把移动的光猫改成桥接，接到我的软路由上面。\u003c/p\u003e","title":"移动GM220-S光猫改桥接小记"},{"content":"之前买了个NanoPi R4S，当时给他装了Arch Linux ARM并用systemd-networkd配置了一个简易的软路由。不过systemd-networkd不支持PPPoE，所以当时我是把R4S接在租的房子的主路由下做子路由的，然后再给R4S接了一个小米路由器当作无线AP。最近从北京搬回家了所以想直接使用R4S做家里的主路由，因为R4S上手体验的那篇文章已经写完很久了，所以就不打算在那篇博客上做修改了，而是新开（水）了一篇博客。\n这里偷偷骂一下长城宽带没人反对吧\n准备工作 按照Arch Wiki的Router页面，你的电脑需要符合安装Arch Linux的基础硬件要求，且至少具备俩物理网口。\n个人觉得软路由没必要非得刷*WRT或者其他路由器专用系统，也没必要搞个爱快群辉什么的系统，我只想给他装我喜欢的发行版，然后我自己配置我需要的服务，只要有两个以上的物理网口就可以配置路由功能，给他们配置DHCP和流量转发就完事了，这样搞出来的路由器更符合咱自己的需求，相对来讲也更灵活一些，不用受限于那些路由器/NAS定制的系统，而缺点则是比较折腾，有可能不稳定。\n安装系统的步骤咱跳过不讲了，Wiki上有的东西没必要在这里重复一遍。\n配置IP地址 首先，将你电脑的两个物理网口一个用作WAN口（连接广域网），一个用作LAN口（连接局域网），有需要的可以自行修改网口的名称（通常默认的网卡名字为eth*，或者enp*s*）。 为了和Wiki同步，这里假设WAN口的名字为extern0，用来指连接到广域网的网口，LAN口的名字为intern0，代指连接到局域网的网口。\n本篇使用netctl配置网络，在修改配置文件之前，需要先停掉其他配置网络的服务。\n给LAN口配置一个静态IP地址。\n# /etc/netctl/intern0-profile # Config file for intern0 (LAN) Description=\u0026#39;Private Interface. (LAN)\u0026#39; Interface=intern0 Connection=ethernet IP=\u0026#39;static\u0026#39; Address=(\u0026#39;10.10.10.1/24\u0026#39;) IP6=\u0026#39;static\u0026#39; Address6=(\u0026#39;fdaa:aaaa:bbbb::0001/64\u0026#39;) SkipNoCarrier=yes 以上配置将为LAN口设定IPv4的地址为10.10.10.1，IPv6的地址为fdaa:aaaa:bbbb::0001。 你可以给这个网口设定任意的局域网IP地址，通常为10.*，172.*，192.168.*这些网段的任意一个地址， IPv6的局域网网段为fd00::/8，通俗一点讲就是fd**开头的一般都是局域网的IP地址。\n之后给WAN口配置DHCP或PPPoE协议。\n配置DHCP的方式自行翻Wiki或者看example，这里不重复讲了。\n在配置PPPoE之前需要安装ppp。\n# /etc/netctl/extern0-profile # Config file for public interface (WAN) Description=\u0026#39;Public Interface. (WAN)\u0026#39; Interface=extern0 Connection=pppoe User=\u0026#39;username\u0026#39; Password=\u0026#39;samplepasswd\u0026#39; # IP6=stateless # Always keep a connection established ConnectionMode=\u0026#39;persist\u0026#39; 使用以下命令启动netctl的配置文件。\nnetctl enable intern0-profile netctl enable extern0-profile 重启路由器，将WAN口与光猫的网口连接，使用ip addr查看网络设备的IP地址，顺利的话，可以看到一个名为ppp0的网口，并获取了一个运营商分给你的IP地址。\n1: intern0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether fa:97:da:d8:9d:8a brd ff:ff:ff:ff:ff:ff inet 10.10.10.1/24 brd 10.10.10.255 scope global intern0 valid_lft forever preferred_lft forever inet6 fdaa:aaaa:bbbb::1/64 scope global nodad valid_lft forever preferred_lft forever inet6 fe80::f897:daff:fed8:9d8a/64 scope link valid_lft forever preferred_lft forever 2: extern0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether ca:1f:4a:9b:29:df brd ff:ff:ff:ff:ff:ff inet6 fe80::c81f:4aff:fe9b:29df/64 scope link valid_lft forever preferred_lft forever 3: ppp0: \u0026lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP\u0026gt; mtu 1492 qdisc fq_codel state UNKNOWN group default qlen 3 link/ppp inet 123.123.123.123 peer 123.123.123.1/32 scope global ppp0 valid_lft forever preferred_lft forever inet6 240e:aaaa:bbbb:cccc:::eeee/64 scope global dynamic mngtmpaddr valid_lft 259132sec preferred_lft 172732sec inet6 fe80::aaaa:bbbb:cccc:dddd peer fe80::aaaa:bbbb:cccc:dddd/128 scope link valid_lft forever preferred_lft forever 如果遇到了问题，可以使用systemctl status netctl@extern0\\\\x2dprofile.service查看一下错误信息。 如果是认证失败的话，重启几次这个service说不定就好了。\n配置DNS和DHCP 安装dnsmasq，编辑/etc/dnsmasq.conf。\n# Setup listen address listen-address=10.10.10.1,127.0.0.1 # Do not read /etc/resolv.conf no-resolv # Use following dns servers server=114.114.114.114 server=8.8.8.8 server=8.8.4.4 # Bind interface interface=intern0 # Setup domain expand-hosts domain=foo.bar # Setup IPv4 DHCP dhcp-range=10.10.10.100,10.10.10.255,255.255.255.0,12h # Setup IPv6 DHCP dhcp-range=fdaa:aaaa:bbbb::000a, fdaa:aaaa:bbbb::ffff, 64, 12h 使用systemctl enable --now dnsmasq.service启动dnsmasq， 之后重启路由器，使用网线连接将电脑连接到路由器的LAN口，顺利的话可以自动获取一个IP地址。\n如果没获取到IP地址的话，有可能是DHCP服务器的问题，先尝试在电脑上手动设置一个IP地址，之后尝试ping路由器的IP（10.10.10.1）。 如果还是无法连接到路由器的话，就需要重新检查一下路由器的配置了。\n网络共享 首先参照Wiki，开启数据包转发的功能。\n之后安装iptables，配置ipv4和ipv6的流量伪装。\niptables -A FORWARD -i intern0 -j ACCEPT iptables -A FORWARD -o intern0 -j ACCEPT iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT iptables -A FORWARD -i intern0 -o ppp0 -j ACCEPT iptables -t mangle -A FORWARD -o ppp0 -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu ip6tables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE 之后可使用iptables-save -f /etc/iptables/iptables.rules和 ip6tables-save -f /etc/iptables/ip6tables.rules将ip桌子的规则保存下来。\nDone 以上配置完成后，按理来说路由器就已经配置好了。\n调试的过程为首先在路由器上尝试ping一个广域网的域名或IP地址（8.8.8.8），之后将路由器与电脑用网线连接， 电脑应当通过DHCP自动获取到一个随机的IP地址。 之后在电脑上尝试打开一些理应能打开的网站，应该是能打开的。\n如果能电脑可以ping通一个广域网的IP，但是打不开网站的话，就检查一下路由器DNS配置， 如果路由器上能ping通一个广域网的IP，但电脑连IP地址都ping不通，那就去检查一下ip桌子的流量伪装规则，检查一下网口名字有没有写对之类的。\n之后如果一切都调试成功的话，就可以把家里的无线路由器改成“有线中继”模式了，这样家里的无线路由器将只作为一个无线AP使用，路由的功能将全部由刚刚配置好的软路由实现。\n配置好“有线中继”模式后，电脑连接无线WIFI后获得的IP地址应当是软路由分配的IP地址，网段为刚刚咱们设置的10.10.10.*， 而不再是192.168.*的IP地址了。\n","permalink":"https://blog.starry-s.moe/posts/2022/archlinux-router/","summary":"\u003cp\u003e之前买了个NanoPi R4S，当时给他装了Arch Linux ARM并用\u003ccode\u003esystemd-networkd\u003c/code\u003e配置了一个简易的软路由。不过\u003ccode\u003esystemd-networkd\u003c/code\u003e不支持PPPoE，所以当时我是把R4S接在租的房子的主路由下做子路由的，然后再给R4S接了一个小米路由器当作无线AP。最近从北京搬回家了所以想直接使用R4S做家里的主路由，因为\u003ca href=\"/posts/2022/nanopi-r4s/\"\u003eR4S上手体验\u003c/a\u003e的那篇文章已经写完很久了，所以就不打算在那篇博客上做修改了，而是新开（水）了一篇博客。\u003c/p\u003e","title":"在Arch Linux上配置软路由"},{"content":"前两天下单了个Nano Pi R4S，4G内存的版本。通常情况下这玩意别人都把他当软路由用，但是今天咱收到货后想了一会拍大腿一寻思这玩意不就是个ARM架构的小电脑嘛~\n所以咱暂时先不打算给这玩意装OpenWRT或 *WRT这类的路由器系统了，而是把它当成一个超小号的带俩网口的mini主机折腾。\n开箱 USB 3.0、SD卡插槽以及三脚架接口\n供电接口和网口\n正面\n拆解 咱收到货后第一件事就是找螺丝刀和塑料卡片把这漏油器拆开看看（\n主板正面\n芯片的布局可以在R4S的商品页面查到，官方Wiki上也有更多关于R4S的介绍。\nArch Linux ARM 在Arch Linux ARM (简称alarm) 官网上没找到对R4S的官方的支持，简单搜了一下armbian有对R4S的官方支持。\n因为用惯了滚动更新发行版，所以不想用*bian系统，而*WRT系统的软件包相对其他发行版而言更少一些，系统也相当于被魔改过，所以除了做漏油器之外几乎干不了别的，所以这是我想安装Arch Linux的理由。\n然后咱搜到了一篇给NanoPi R2S安装alarm的教程，评论里有人提到了给R4S安装也是可以的。\n所以咱大致把这个教程翻译一下，再修改一些R2S和R4S在安装时的区别。\n以下内容需结合alarm的 aarch64通用安装教程食用，像更新pacman-key，ssh的密码之类的部分咱就不在这里重复了。\n准备SD卡 下载armbian的镜像，下载链接自行谷歌。\n通常下载好的文件是xz格式的压缩文件，需要使用unxz解压成img镜像。\n将armbian镜像的bootloader和uboot(32-32767区块的部分)用dd写到SD卡中：\n# Clean the sector before 32 dd if=/dev/zero of=/dev/sdX bs=1M count=32 # Write uBoot and bootloader dd if=Armbian_*.img of=/dev/sdX skip=31 seek=31 bs=512 count=32736 其实可以直接用dd把armbian的整个镜像写到内存卡中然后插入R4S开机，第一次开机后他会自动重新给内存卡分区，然后只需把/dev/sdX1格式化成ext4就能安装alarm了。\n使用fdisk给内存卡分区并格式化文件系统\n创建分区时先按o创建个MBR分区表，然后按n添加分区。第一个分区的起始区块(sector)需要设置为32768，通常情况下分一个区就够用了，或者你可以像我这样分俩区，一个给swap，不过实际没啥必要。\nDisk /dev/mmcblk1: 29.72 GiB, 31914983424 bytes, 62333952 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x33fc535e Device Boot Start End Sectors Size Id Type /dev/mmcblk1p1 32768 53944319 53911552 25.7G 83 Linux /dev/mmcblk1p2 53944320 62333951 8389632 4G 82 Linux swap / Solaris 创建完分区后，把root分区mkfs.ext4格式化成ext4，swap分区用mkswap格式化。\n解压alarm系统文件到root分区中\n复制并替换armbian的/boot中的文件到新建分区的/boot文件夹中。\n编辑/boot/armbianEnv.txt，更新rootdev的UUID 使用blkid或者lsblk -o+UUID可以查看UUID，注意是UUID不是PARTUUID。\n插电，开机 (此处不会出现五安大电牛)，网线连接R4S的WAN口到路由器的LAN口，第一次开机需要生成SSH Key所以时间会久一些，然后就可以ssh到R4S上去辣。\n内核 上述的安装步骤使用的armbian的内核，可以正常开机，但是想用Arch Linux stock aarch64内核的话，得替换一下DTB文件。（DTB文件是啥我目前还不清楚，如果后续弄明白了再更新到博客上吧）\nssh到R4S中，安装linux-aarch64。\n修改使用的DTB文件：\ncd /boot rm dtb ln -sf dtbs dtb 编辑armbianEnv.txt，在末尾添加一行fdtfile=rockchip/rk3399-rockpro64.dtb。\n在/boot/dtb/rockchip目录下是可以找到rk3399-nanopi-r4s.dtb文件的，但是目前用这个DTB的话会导致PCIE不能正常工作，导致LAN口无法使用。 dmesg的输出为：\ndmesg | grep pci [ 0.538310] ehci-pci: EHCI PCI platform driver [ 0.559708] ohci-pci: OHCI PCI platform driver [ 2.999933] rockchip-pcie f8000000.pcie: host bridge /pcie@f8000000 ranges: [ 2.999974] rockchip-pcie f8000000.pcie: MEM 0x00fa000000..0x00fbdfffff -\u0026gt; 0x00fa000000 [ 2.999987] rockchip-pcie f8000000.pcie: IO 0x00fbe00000..0x00fbefffff -\u0026gt; 0x00fbe00000 [ 3.000410] rockchip-pcie f8000000.pcie: no vpcie12v regulator found [ 3.500881] rockchip-pcie f8000000.pcie: PCIe link training gen1 timeout! [ 3.500944] rockchip-pcie: probe of f8000000.pcie failed with error -110 于是就先用rockpro64的DTB文件了。\n创建uBoot镜像和initramfs。\npacman -S uboot-tools mkimage -A arm64 -T ramdisk -n uInitrd -d /boot/initramfs-linux.img /boot/uInitrd-initramfs-linux.img ln -sf /boot/uInitrd-initramfs-linux.img /boot/uInitrd 创建个pacman的钩子，在以后更新linux-aarch64的时候自动的重新构建uboot和initramfs。\n在mkdir -p /etc/pacman.d/hooks目录下创建/etc/pacman.d/hooks/initramfs.hook\n[Trigger] Operation = Install Operation = Upgrade Type = Package Target = linux-aarch64 [Action] Description = Generate uInitrd Exec = /usr/bin/mkimage -A arm64 -T ramdisk -n uInitrd -d /boot/initramfs-linux.img /boot/uInitrd-initramfs-linux.img When = PostTransaction Depends = uboot-tools 重启，uname -a输出的应该是新版本的内核了。\n有个细节，用armbian的DTB文件时，开机后SYS LED灯是闪烁的，但是换到rockpro60的DTB文件后只有PWR灯长亮，别的灯都不闪了。\nRouter 虽然装的是Arch Linux ARM系统，但是这并不代表它不能作为一个路由器使用。\n系统默认用的是systemd-networkd管理网络，所以以下内容使用systemd-networkd配置路由器，暂时没遇到问题，如果不行的话我再换别的。\n参考: Router - ArchWiki\n重命名网络接口 这一步并非必须，但是我有遇到重启系统后网口从eth0变成eth1的情况，所以还是给网口重命个名好一些。\n首先移除并备份/etc/systemd/network中原有的配置文件。\ncd /etc/systemd/network # backup config files mv ./* /root/ 获取WAN口的mac地址。\ncat /sys/class/net/eth0/address 12:34:56:78:90:ab 创建10-extern0.link，重命名eth0到extern0。\n[Match] MACAddress=12:34:56:78:90:ab [Link] Description=WAN Name=extern0 另一个网口(LAN)在开机时systemd-networkd会自动给他重命名为enp1s0。\nWAN口配置DHCP客户端 这里我是把R4S的WAN口接到另一台路由器的LAN上，所以配置的是DHCP客户端。如果你打算直接把路由器接光猫，而且你的猫设置了桥接，那么你可能需要配置PPPOE。\n创建20-extern0.network。\n[Match] Name=extern0 [Network] DHCP=yes LAN口配置静态IP和DHCP服务器 给LAN口设置成另一个网络的静态IP地址，并配置DHCP服务器，给连接到LAN口的机器分配同一个网络下的其他IP地址。\n创建20-enp1s0.network。\n[Match] Name=enp1s0 [Network] Address=10.0.0.1/24 DHCPServer=true IPMasquerade=both [DHCPServer] PoolOffset=100 PoolSize=100 EmitDNS=yes # DNS=8.8.8.8 我这个配置是给LAN口设置了静态IP地址10.0.0.1，掩码255.255.255.0，启用了DHCP服务器， 设置了IPv4数据“伪装”(packets forwarded from the network interface will be appear as coming from the local host)。\n有关配置文件的参数可以使用man systemd.network查询。\n暂时还没搞懂怎么折腾IPv6，如果配置好IPv6的话我再补上……\n后续 之后咱装了JDK以及一堆我常用的小组件。为了测试性能，我把我以前备份的Minecraft服务器复制到R4S上跑了一下试试。我的服务器之前是在疼讯云学生主机上跑的(1核2G)，装了好多性能优化插件(lithium，phosphor，carpet\u0026hellip;)，版本是1.16.4，抱着尝试的心态跑了一下这个服务器结果发现很流畅，一开始区块加载的时候CPU的6个核心全跑满，之后就恢复到正常水平了。刚才尝试了一下长时间的生成区块貌似没什么大的问题，只要别一直用鞘翅跑图就行，应该是内存够用了所以运行效果要好一些，不过单核性能来讲的话肯定还是X86吊打R4S的。\n毕竟这就是半个巴掌大小的机器，跑MC的时候CPU温度才不到50度，应该不需要主动散热，功耗才十多瓦……\nMineCraft Server Performance\nArch Linux ARM\n参烤链接 NanoPi R4S NanoPi R4S - FriendlyELEC WiKi Installing Arch Linux AArch64 on the NanoPi R2S Generic AArch64 Installation | Arch Linux ARM Router - ArchWiki systemd-networkd - ArchWiki systemd.network(5) — Arch manual pages 在 NanoPi R2S 上安装 Archlinuxarm - 知乎 ","permalink":"https://blog.starry-s.moe/posts/2022/nanopi-r4s/","summary":"\u003cp\u003e前两天下单了个Nano Pi R4S，4G内存的版本。通常情况下这玩意别人都把他当软路由用，但是今天咱收到货后想了一会拍大腿一寻思这玩意不就是个ARM架构的小电脑嘛~\u003c/p\u003e\n\u003cp\u003e所以咱暂时先不打算给这玩意装OpenWRT或 *WRT这类的路由器系统了，而是把它当成一个超小号的带俩网口的mini主机折腾。\u003c/p\u003e","title":"NanoPi R4S上手 \u0026 安装Arch Linux ARM"},{"content":"之前咱自己搭过一个Miniflux服务器，不过当时用得并不频繁，逐渐的被咱弃用了。\n最近想订阅一些网站，因为使用RSS订阅的话，能收到更新提醒，不用经常的翻收藏夹去看页面内容有没有更新，使用RSS订阅的话也方便集中管理一些， 而且还能绕开推荐算法，只看自己想看的内容，这点还是蛮重要的。\n思考了几天发现我确实需要一个RSS订阅服务器后，于是决定这次把搭建过程记录下来，省得以后又忘了。\n准备 Miniflux官方文档（EN）：https://miniflux.app/docs/index.html\n安装 此部分配合官方文档食用：https://miniflux.app/docs/installation.html\n配置数据库： 首先需要安装postgresql数据库。安装方法因发行版而异，网上一搜就有。\n# Switch to the postgres user $ sudo su - postgres # Create a database user for miniflux $ createuser -P miniflux # Create a database for miniflux that belongs to our user $ createdb -O miniflux miniflux # Create the extension hstore as superuser $ psql miniflux -c \u0026#39;create extension hstore\u0026#39; # Change postgres password $ psql \u0026gt; \\password 安装Miniflux： 不同的发行版使用方法不一样，咱的这台服务器为Ubuntu，所以参照这里的教程配置APT源，安装Miniflux。\ncurl -s https://apt.miniflux.app/KEY.gpg | sudo apt-key add - echo \u0026#34;deb https://apt.miniflux.app/ /\u0026#34; | sudo tee /etc/apt/sources.list.d/miniflux.list \u0026gt; /dev/null apt update apt install miniflux 配置Miniflux 默认配置文件为：/etc/miniflux.conf。\n# See https://miniflux.app/docs/configuration.html LISTEN_ADDR=0.0.0.0:8080 LOG_DATE_TIME=yes DATABASE_URL=user=postgres password=\u0026lt;YOURPASSWORD\u0026gt; dbname=miniflux sslmode=disable # Run SQL migrations automatically # RUN_MIGRATIONS=1 之后线将刚刚创建的数据库用户miniflux设置为超级用户。\n$ sudo su - postgres $ psql \u0026gt; ALTER USER miniflux WITH SUPERUSER; 使用以下指令创建数据库表，并创建用户：\n$ miniflux -c /etc/miniflux.conf -migrate $ miniflux -c /etc/miniflux.conf -create-admin 之后将miniflux切换回普通用户。\n$ sudo su - postgres $ psql \u0026gt; ALTER USER miniflux WITH NOSUPERUSER; 最后重新启动miniflux。\n$ sudo systemctl restart miniflux 配置SSL（可选） 使用nginx转发流量，可以将服务器套在Cloudflare下面。\n编辑nginx的服务器配置文件，创建一个端口为443的服务器，并指定SSL key的位置：\nserver { listen 443 ssl default_server; listen [::]:443 ssl default_server; server_name miniflux; ssl_certificate /path/to/server.crt; ssl_certificate_key /path/to/server.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { proxy_pass http://127.0.0.1:8080; } } 之后执行sudo systemctl restart nginx，访问服务器地址即可。\nOthers Miniflux支持Fever和Google Reader等第三方服务，参考官方文档，可以在服务器的设置-\u0026gt;集成页面中配置，之后在别的设备中安装客户端，可以阅读订阅的文章，比网页版好用一些。\nSTARRY-S\n","permalink":"https://blog.starry-s.moe/posts/2022/miniflux-build/","summary":"\u003cp\u003e之前咱自己搭过一个Miniflux服务器，不过当时用得并不频繁，逐渐的被咱弃用了。\u003c/p\u003e\n\u003cp\u003e最近想订阅一些网站，因为使用RSS订阅的话，能收到更新提醒，不用经常的翻收藏夹去看页面内容有没有更新，使用RSS订阅的话也方便集中管理一些，\n而且还能绕开推荐算法，只看自己想看的内容，这点还是蛮重要的。\u003c/p\u003e\n\u003cp\u003e思考了几天发现我确实需要一个RSS订阅服务器后，于是决定这次把搭建过程记录下来，省得以后又忘了。\u003c/p\u003e","title":"自建RSS服务器：Miniflux"},{"content":"年初的时候买了先马趣造这个机箱，买这个机箱的主要的原因是先马鲁班太大了，之前买先马鲁班的时候没有考虑到机箱便携性的问题，因为台式机压根就没啥便携性可言。\n然额因为咱今年上半年要去北京，觉得台式机留在家里不用有些不忍心，所以某天在网上闲逛的时候看到了这款机箱。看了很多网上的评测视频后才决定入手。\n现在距离刚入手这台机箱已经过去一个多月了，前一阵子一直在忙所以没时间更新博客，于是直到现在咱才把换机箱这件事更新到博客上。\n配置 CPU、主板、显卡、电源、硬盘、CPU散热以及内存这些用的还是上一篇“我们来组装一台电脑吧”里面讲的配置。\n除此之外咱买了一个直径8CM的小风扇(ARCTIC P8)，和一个超薄的1.5CM厚的风扇(ID-COOLING TF9125)。\n配置方面没有太大改动，因为不打算装侧玻璃板，所以咱这次没有装RGB灯条。\n装机 最终的样子\n装机过程还是很顺利的，因为新机箱体积比较小，可供操作的空间有限，所以花了很长时间才装完。一开始还比较担心显卡太长会不会和右侧的ATX电源产生冲突， 不过华硕B550重炮手的主板的PCIE4X16是在第二槽，第一槽是个PCIE1，所以装上显卡后没有影响到右侧全模组电源的电源线， 但是显卡的底部空间很小，没办法塞下一个正常厚度的风扇了。\n机箱底部\n后来咱买了一个1.5cm厚的超薄风扇帮助显卡散热，不过风扇的尺寸咱买小了，本来应该买12cm的风扇咱买了个9cm的，到手后发现把风扇斜过来也能勉强固定住，于是就不打算换了。\n顶部\n正面\n机箱顶部用的是之前买的先马冰洞静音风扇，虽然不支持PWM调速但是很静音。然后因为右侧的空间被ATX电源占用了所以顶部只能装一个风扇。\n发热量大户实际上是显卡，CPU产生的热量很容易就能散开。所以所有风扇低速运行时，CPU和显卡的待机温度才比室温高十几度，只有玩游戏时CPU和显卡温度会高一些。\n把所有零件全部装上之后，就没有空间装机械硬盘了，不过还好我只有一块2.5寸固态硬盘，勉强塞在了前面板背面的硬盘位中。\n因为机箱空间有限，所以理线是个大难题，机箱几乎没有可理线的空间，所以我只好把一大团电线捆在一起。\n最终效果 最终效果\n白色机箱的确比黑色机箱好看很多，而且我反而觉得白色机箱更不容易脏一些，因为之前的黑色机箱手一摸就是油乎乎的大手印，但是这个白色机箱就没有。\n在网上看到有人在机箱前面贴苹果贴纸的，不过咱找了一下高中时买的Arch Linux贴纸，贴到了机箱顶部。\n趣造的机箱四面八方全是散热孔，所以就算咱把一个M-ATX机箱里面的所有东西全都塞到了这个小盒子里面，温度也并没有上升。要说影响的话，就是没有可以塞机械硬盘和摆手办的地方了（\n如果想塞机械硬盘的话，我得把我的ATX电源换成SFX电源。然后把CPU散热换成水冷或者下压式散热之类的，才能倒出空间装机械硬盘。不过咱买这个机箱目的就是为了能放到行李箱里面拉走，所以装机械硬盘的话容易在路上颠坏了。而固态就没这个担心。\n然后就是个人感觉先马趣造这机箱设计得还蛮不错的，机箱的所有地方都能拆，装机的时候可以先把机箱拆得只剩下一个铁架子，所以实际上装机没有增添太多难度。就是理线费劲了一些。全模组电源自带的模组线是真的硬。\n因为机箱小，去北京实习的时候咱买了个28寸的超大行李箱，于是这个行李箱在塞下这个机箱之后还能塞很多衣服。总之肯定是不会出现像上次那样坐高铁我一个人把机箱和显示器从北京扛回老家的情况了。\nSTARRY-S\n","permalink":"https://blog.starry-s.moe/posts/2022/sama-quzao/","summary":"\u003cp\u003e年初的时候买了先马趣造这个机箱，买这个机箱的主要的原因是先马鲁班太大了，之前买先马鲁班的时候没有考虑到机箱便携性的问题，因为台式机压根就没啥便携性可言。\u003c/p\u003e\n\u003cp\u003e然额因为咱今年上半年要去北京，觉得台式机留在家里不用有些不忍心，所以某天在网上闲逛的时候看到了这款机箱。看了很多网上的评测视频后才决定入手。\u003c/p\u003e\n\u003cp\u003e现在距离刚入手这台机箱已经过去一个多月了，前一阵子一直在忙所以没时间更新博客，于是直到现在咱才把换机箱这件事更新到博客上。\u003c/p\u003e","title":"电脑换壳——先马趣造"},{"content":"把吃灰了好久的树莓派带了过来，打算搞个NAS玩一下，简短的记录一下整个过程。\n这歌太魔性了哈哈哈哈哈……\n准备工作 树莓派以及所需的电源（废话） 16G以上的高速内存卡用来写系统镜像 硬盘（可以选择买移动硬盘或者直接买硬盘盒和机械硬盘自己组装） 网络设备：路由器、网线 （非必须）键盘、显示器、连接线等 树莓派我使用的是高一时买的树莓派3B（满满的回忆），硬盘是上半年为了存照片而买的西数2T移动硬盘，因为暂时闲置所以拿来一起组个云盘玩。\n内存卡需要质量好的不容易坏而且读写比较快的卡。\n装系统 系统咱安装的是ArchLinux ARM，安装教程直接看官方文档即可。\n一开始咱为了发挥树莓派3B的64位CPU的性能，我下载了64位的系统镜像，但是在配置无线连接的时候（可能是）驱动问题卡死，因为急着睡觉所以重新格式化内存卡后被迫安装32位的系统。\n安装教程咱就不重复写到博客里了，直接翻Wiki，尽管是纯英文的但是不难，都能看懂。咱就不打算在这翻译了。\n在格式化root分区时一开始想尝试一下树莓派上跑btrfs，但是开机时进了linux的救援(rescue)模式，懒得折腾还是老老实实换回了ext4，不然我一晚上不用睡觉了。\n在分区时除了boot和root之外，我额外分了2G的swap分区，树莓派1G内存有些小不过只是搭个人用的NAS的话实际上是不影响使用的。（这话咋读着这么别扭呢）\n因为咱要做NAS肯定得往树莓派上外接个硬盘之类的，树莓派3B只有USB 2.0 + 百兆网口，尽管速度很慢但是作为个人网盘来说不到10MB/S的速度还是比某些恶心网盘快很多的，在线看个1080P视频还是蛮轻松的，BD蓝光想想还是算了。\n把移动硬盘接到树莓派后lsblk查看一下分区表。因为咱这是块几乎全新的硬盘所以需要重新分区并格式化一下。\n如果你不熟悉在命令行上进行分区格式化的话，建议自行翻阅Wiki (fdisk)，因为往博客上写的话太难理解了别人肯定看不懂。\n最后咱把2T移动硬盘格式化成这个样子：\n# fdisk -l /dev/sda Device Start End Sectors Size Type /dev/sda1 2048 2147485695 2147483648 1T Linux filesystem /dev/sda2 2147485696 3907029133 1759543438 839G Microsoft basic data 其中的1T打算格式化为btrfs给Samba用，其余的800G打算格式化为NTFS留着给Windows当个移动硬盘。\n创建分区时别忘了更改分区类型，给Linux用的就是Linux filesystem，给Windows用的就是Microsoft basic data， 不然机械硬盘连接到Windows系统中将不显示分区，或者就是一直提醒你：该分区不可用，然后让你格式化，到时候一不小心点错了可是会丢数据的。\n安装btrfs-progs和ntfs-3g，之后格式化硬盘（NTFS还是建议到Windows系统中格式化）。\n格式化btrfs的时候加个-L参数设置分区的标签，这样方便在fstab中设置开机自动挂载。\n$ lsblk # 一定要看清楚自己格式化的分区名字 $ sudo mkfs.btrfs /dev/sdaX -L samba # -L 参数设置分区的标签 最后改一下/etc/fstab让设备在开机时自动挂载交换分区和移动硬盘。\n# \u0026lt;file system\u0026gt; \u0026lt;dir\u0026gt; \u0026lt;type\u0026gt; \u0026lt;options\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;pass\u0026gt; /dev/mmcblk0p1 /boot vfat defaults 0 0 LABEL=swap none swap defaults 0 0 LABEL=samba /samba btrfs defaults 0 0 重启系统后如果正常的话，分区会被自动挂载。\n配置网络 配置网络部分不适合在SSH中操作，建议使用显示器和键盘连接到树莓派上操作。\n除非你能保证你执行的每个命令都肥肠正确。\n无线网络 因为我电脑离路由器肥肠远，所以为了方便我还要给树莓派配置无线网络。首先照着Wiki上的netctl页面安装了wifi-menu所需要用的dialog，然后就用wifi-menu连接wifi了。不过为了方便以后连接，我需要给他设置静态IP：\n首先使用你比较喜欢的文本编辑器打开wifi-menu自动生成的配置文件，并修改成以下的样子\n# /etc/netctl.d/wlan0-YourWifiName Description=\u0026#39;Automatically generated profile by wifi-menu\u0026#39; Interface=wlan0 Connection=wireless Security=wpa ESSID=Your Wifi Name IP=static Address=(\u0026#39;192.168.xxx.xxx/24\u0026#39;) Gateway=\u0026#39;192.168.xxx.1\u0026#39; DNS=\u0026#39;8.8.8.8\u0026#39; Key=YOUR WIFI PASSWORD 其中修改Address为你想设置的CIDR地址、Gateway为默认网关、以及DNS。\n最后修改Key为Wifi密码（明文），如果需要加密的话可以去wiki上找相应方法。\n之后sudo netctl enable wlan0-YourWifiName设置好开机自动连接即可。\n这时候聪明的小伙伴会想到：我想使用网线联网并配置静态IP，该怎么办呢？\n配置有线网络 默认情况下，有线接口eth0使用systemd-network配置了DHCP，所以我们不需要改netctl的配置文件，只编辑/etc/systemd/network/eth0.network这个配置文件改成静态IP地址就好了。\n[Match] Name=eth0 [Network] Address=192.168.xxx.xxx/24 Gateway=192.168.xxx.1 DNS=8.8.8.8 重启系统后，使用ip addr检查设备的IP地址是否正确。\n配置防火墙 首先安装ufw。（因为对iptables不是十分熟悉，ufw比ip桌子好用一些，毕竟他叫Uncomplicated Filewall，所以咱先用ufw配置防火墙）\n食用方法请参见Wiki页面。\n因为咱打算搭一个Samba服务器，所以别忘了配置防火墙允许Samba的端口，按照Arch Linux Wiki：\n# Create or Edit /etc/ufw/applications.d/samba, add following content: [Samba] title=LanManager-like file and printer server for Unix description=Samba ports=137,138/udp|139,445/tcp 之后root账户执行ufw app update Samba加载配置文件，然后ufw allow Samba允许Samba的端口。\n如果你的树莓派上还装有其他服务（比如http，https等），别忘了ufw allow PORT开放端口，尤其是别忘了开SSH端口。\n最后ufw status查看防火墙状态信息，ufw enable开启防火墙。\nSamba 配合Arch Wiki食用。\n首先我们需要新建一个分组，然后在挂载的分区中新建一个文件夹作为Samba服务器的共享目录：\n$ sudo groupadd -r sambausers # 新建用户组 $ sudo usermod -aG sambausers username # 添加当前用户至分组中 $ sudo smbpasswd -a sambausers # 设置Samba用户的密码 $ sudo mkdir /samba/sharefolder # 新建文件夹用来存储共享的文件 $ sudo chown :username /samba/sharefolder # 修改文件夹的所属分组 $ sudo chmod 0770 /samba/sharefolder # 修改权限 （咱写的很详细了吧\n配置服务器 安装好samba安装包后，需要手动去/etc/samba/创建smb.conf配置文件，可以到Samba git repository中获取样例配置文件，咱只需要把它复制粘贴再简单修改一下就好了。\n# /etc/samba/smb.conf [global] # 修改工作组的名字 workgroup = MYGROUP # 服务器描述 server string = Raspberry pi Samba Server # 在文件末尾添加共享文件夹目录及相关配置 [sambashare] comment = Sample share file. path = /path/to/your/samba/folder writable = yes browsable = yes create mask = 0755 directory mask = 0755 read only = no guest ok = no # 允许访客随意登录 配置好文件后，启动smb.service和nmb.service\n$ sudo systemctl enable --now smb.service $ sudo systemctl enable --now nmb.service 访问服务器 咱GNOME用户直接打开文件管理器，选择左边的“+ Other Locations”，在底部输入服务器连接smb://192.168.xxx.xxx， 输入用户组、用户名和密码登录就可以访问共享文件夹。\nWindows系统中，首先需要到 控制面板-\u0026gt;程序-\u0026gt;启用或关闭Windows功能 里面，选中 SMB1.0/CIFS文件共享直通，保存后等一会安装完， 打开文件资源管理器输入地址\\\\192.168.xxx.xxx\\，登录后就能访问共享文件夹了。\nFrp内网穿透 配合frp文档食用更佳\n首先在frp的GitHub Release页面下载安装包。\n如果是树莓派用的话就下载arm版本的安装包即可。Arch Linux可以在ArchLinux CN源或AUR中安装frpc和frps作为客户端和服务端。\n# 树莓派上下载编译好的文件 $ wget https://github.com/fatedier/frp/releases/download/v0.37.1/frp_0.37.1_linux_arm.tar.gz # 解压 $ tar -zxvf ./frp_0.37.1_linux_arm.tar.gz $ cd frp_0.37.1_linux_arm/ # 编辑配置文件 $ vim ./frpc.ini $ ./frpc -c ./frpc.ini 客户端配置文件的格式可参考如下：\n[common] server_addr = server ip server_port = 6000 [samba] type = tcp local_ip = 127.0.0.1 local_port = 445 remote_port = 6003 其中端口号和token按需要自行更改，Samba服务的tcp端口号为445。\n服务端配置文件格式如下：\n[common] bind_port = 6000 为了安全，别忘了配置权限验证，同时别忘了修改服务器的防火墙设置。\nOthers 所以到此为止，咱的Samba服务器就搭建好了。\n随便传了个大文件试了一下，内网上传速度在6MB/S左右，有些慢但是还没搞清楚到底是什么原因导致的。\n","permalink":"https://blog.starry-s.moe/posts/2021/raspberry_pi_nas/","summary":"\u003cp\u003e把吃灰了好久的树莓派带了过来，打算搞个NAS玩一下，简短的记录一下整个过程。\u003c/p\u003e","title":"使用树莓派搭建一个NAS"},{"content":"很久很久以前就想自己组装电脑了，看到别人能有台高性能的电脑别提有多羡慕了。不过考虑到在校期间实在不适合把自己组装的电脑放到寝室中去，要是把电脑放家里的话只能假期玩短短的几星期，其余的时间闲置下来的话又觉得有些浪费，于是组装电脑的计划一直推延至今。最终在大四校外实习自己租房子之后才有了一个短暂而勉强稳定的环境可以让我组装台式机，所以在安置好自己的住处和一系列其他事情之后，我终于可以实现自己这个埋藏心底多年的愿望之一了。\n因包含插图，为了浏览体验我只对图片进行了适量压缩，\n网络不好的用户可能需要多花一些时间加载。\n配置清单 一边翻着某东的购物车一边写\nCPU + 主板: AMD Ryzen 5 5600X、华硕TFU GAMING B550M-PLUS (WI-FI) 共2477元 显卡: 撼讯 RX6600XT 红魔 3599元（之前的是实际买了技嘉 GeForce GT 730D3 529元) 内存: 英睿达 美光 DDR4 3200MHz 8Gx4 864元 固态硬盘: 西部数据 SN750 SE 1TB 929元 + 英睿达 美光 MX500 2TB 1299元 机箱: 先马 鲁班1 199元 电源: 长城 金牌电源 V7-700W 475元 CPU散热: 利民AK120 PLUS 169元 机箱散热: 利民 TL-R12 三个12CM风扇 119元 + 先马冰洞 风扇套装 3个12cm风扇49元 显示器：优派 VX2480-HD-PRO-3 165HZ 1143元 其他: 扎带5.5元 理线带 9.9元 追风者CMBO灯带 400mm两条 90元 因为我之前用笔记本时已经有一个 ikbc c87 红轴机械键盘和 罗技 G304 无线鼠标 以及之前弄拓展屏时买了 戴尔 U2419HS 显示器，所以这些配件我就不再列入装机清单里面了。\n排除显卡的话，整体配置全下来大概花了6.6K左右，有些配件是买完以后京东又降价了于是申请了价格保护退了一些回来。显卡打算以后等价格恢复正常后再买。所以现在买的是英伟达730D，尽管是亮机卡但是我还是决定多花一点预算去自营店买一张靠谱的全新卡，这样就算以后我换显卡了，这张旧的730还可以拿去给亲朋好友的上古时代老电脑“升级”一下。\n后续在旗舰店买了RX6600XT红魔，这卡可以说是AMD入门级显卡的旗舰款了。除此之外还买了一个高刷1080P显示器，然后买了3个不带灯光的纯白静音风扇和两条ARGB灯带用来装饰。所以整体算下来整机开销大约在12K左右。\n主板觉得华硕重炮手B550M就已经蛮符合我自己的需求了，在B站上看了一下B550的评测发现华硕的重炮手要比微星和技嘉的迫击炮强一些（也贵了好几百元），所以决定多花些预算上一张性能强一点的主板，为后续的升级留一些空间（不过我觉得就这配置已经很够用了没啥好升级的了\n因为AMD R7 5800X太贵了有点超预算，所以决定买的R5 5600X，除了核心数少了一些（跑编译少几个线程）之外，性能对于现在的日常使用来说已经很足够了。肯定比我笔记本上的R7 4800H强许多。\n因为自己打算在电脑装Linux + Windows双系统，所以实际上我给电脑装了2条NVME固态（SN750 SE 1T + 降速的SN550 1T），然后还配了2T的英睿达MX500，以后可能根据需要还会买几个机械硬盘存数据用。\n因为CPU散热不带灯光，尽管我不喜欢RGB那种太花里胡哨的效果，但是还是得买几个有光亮的机箱风扇，因为预算有限而且不装显卡暂时对散热要求不高，所以我只买了比较便宜的风扇，不然机箱黑咕隆咚的太不好看了，以后有需要的话再修改。\n后来咱又买了两条ARGB的灯带，然后花了一段时间把它安装到机箱里面，咱并不喜欢RGB，不过我还是希望机箱能有些观赏性的灯光。\n在B站找了几个电源测评介绍的视频看了一下，就买了长城的700W金牌电源，价格比较便宜不是一元一瓦，目前来讲我不装显卡就日常待机的话整体功率都不会超100W，主要是电费太贵了。 不过现在来看RX6600XT的功耗最高也就150W，（应该给这显卡贴个一级能效标识），所以电脑就算满载使用最高也就不到500W的功耗，日常使用的话显卡功耗只有20-30W，超级节能！\n从网上挑了很久的机箱发现实在没有比较便宜又顺眼的，一开始想买白色机箱来着，后来发现白色机箱要么就是奇葩风道要么就是超预算，所以最终决定买先马鲁班1黑色机箱，尺寸够大对散热和主板显卡长度几乎没有限制，不用买配件时总计算空间大小了。\n配置是周五定下来就从京东上买的，因为基本上都是自营，周六当天就全收到货了。所以周六+周日两天一顿折腾就把电脑装好。一开始还比较担心会不会安错，哪里出问题需要返工这类的情况，实际上装机十分顺利。除了理线花了一些时间以外其他都基本上是一次装齐直接点亮装系统，其实第一次装好机插电源后按开机键怎么也点不亮，当时吓够呛然后拔掉开机跳线检查是不是接线有问题。后来才发现是自己脑残电源开关开反了主板没通电肯定点不亮。\n防呆不防傻， 那么你能帮帮我吗？（逃\n装机 我装机时为了防止装错顺序返工，于是去B站搜了一个教程：【BV1jE411e7hw】，照着这个顺序安装基本不会出错，而且比较常见的问题视频上都有提到，比如萌新不是十分熟悉的内存插槽优先级以及比较难弄的前面板跳线。\n以下图片除了背部理线的那张图是用手机(iPhone XS)在弱光环境拍摄的，其余都是用相机(佳能EOS 800D + 适马17-50)拍摄，设备不是很好，技术有限，使用RawTherapee进行适量的裁剪调色\n主板\nAMD R5 5600X\n内存\n散热模具\n涂抹硅脂\n因为散热器赠的利民TF7硅脂比较干，所以我直接点9个点然后就扣散热器了。觉得没必要像网上有人那样戴手套把硅质抹匀抹平，也不用特别在意硅脂会不会留气泡，总觉得这些不会对散热有太大影响。\n毕竟用一年左右就得拆下来换新硅脂，到时候只要硅脂别太干粘住直接把CPU连根拔起就行。\n散热器底部\n特地拍了一张照片以确认我把散热器底下的膜撕掉了。\n安装散热器\n固态硬盘\n亮机卡\n装好的效果\n理线后的效果\n背面理线花了好几个小时把不同种类形状的线绑了起来，最顶上的风扇RGB灯光线实在没有空间收纳于是只好捆成一坨放在那。\n最终成果展示 最终成果演示\n装好Windows，安装华硕主板的软件，把风扇的灯调成了橙色长亮的模式。一开始调成浅蓝色觉得色温太低了有点冷，所以改成了暖色调。\n暖色\n给机箱内部拍一张特写，现在正在考虑要不要买一个手办放进去。\n少女梦幻粉\n后来买了新显卡和ARGB灯条后，把4根内存插满，设置好显卡的神光同步，把机箱颜色调成了“少女梦幻粉”。\n（相机的夜景效果不太好，所以看起来有些晃眼而且丑，实际上这颜色还是很好看的）\nArch Linux\n装好Arch Linux后的最终效果。\n最终我决定还是把机箱放在桌子上好一些，这样不但能透过玻璃“欣赏”内部构造，还不用担心底部电源的风扇“吸尘器”吸进去很多灰尘。\n机箱内部风道我也是采用的网上最推荐的风道方式，底部和右边为进风口，顶部和左边为出风口。因为现在没有显卡发热量并不大所以我只安装了左边的一个风扇和顶部的两个风扇。\n以后可能再买个手办和灯放到电源仓的上边，再搞点装饰。\n为什么买了RX6600XT 其实咱一开始是想买RTX3060Ti的，但是因为老黄溢价实在太高（NVIDIA f**k you），狗东双十一耍猴，所以去ytb看了一下评测发现这A卡可以通吃1080P全部的游戏（实际上2K很多游戏也全都能玩），而且价格比3060便宜许多，然后一想3060Ti的确有些性能过剩，而且N卡的Linux驱动真的很拉跨（尽管最近一阵子更新了很多东西但是真的就是不想再折腾N卡驱动了）。\n然后就是，如果真的玩fps游戏的话，有谁会真的开极高画质上2K144呢。咱玩守望除了把材质调最高之外其他都是最低，3A大作的话咱也就玩过尼尔和底特律，而且咱不玩赛博朋克2077，而且咱主要还是Linux用户。所以真的没必要花首发价2倍的钱去买一个所谓的能在2K分辨率下全高画质流畅运行游戏的显卡。更值得吐槽的是，现在网上一搜显卡评测，给人的感觉就是游戏不开极高画质就好像不能玩了一样，还有很多人还拿A卡开光追后的帧数和N卡作比较，说实话我本人对光追真没什么好感，我玩的这些游戏里没有支持光追的，而且就算玩支持光追的游戏，开光追也看不出多大差距来。\n网上有很多评测视频说这显卡显存位宽只有128比特，只支持PCIE4.0x8，核心面积小啊，丐中丐不值三千块钱这个价之类的一大堆缺点，不过这卡实际体验并没有网上传的那么不堪。它实际的游戏效果还是很好的，所以真没必要非拿硬件参数说事，缺点有是有，但影响并不大。\n实际上手体验后，这显卡日常待机时风扇转都不转，温度只有40-50度，功耗在20-30W之间肥肠节能。Linux里面卸载掉NVIDIA一大堆驱动后，安装amdgpu驱动直接就能用，没遇到过任何问题。\n（要不是因为刚需，谁会在这个时间点上买显卡\u0026hellip;\n游戏体验 守望先锋高画质（我不开极高画质），训练靶场或者进比赛帧数400fps直接跑满，打团时帧数大约下降到320-350之间。（正常人是不会在打团时盯着屏幕左上角看帧数变化的）\nMinecraft Java Edition 1.16.4 + Optifine（咱加了这么多定语是因为Minecraft有很多版本，而且还有很多用来改善画质或性能的Mod）：\n不知是MC的优化不好还是遇到了CPU瓶颈还是显卡驱动的问题，玩MC时帧数平时会有250帧，但是一到红石机器多的地方或者全物品分类机这类的地方，帧数就掉到了140帧以内，虽然帧数并不高（实际上也不低了），但是已经很流畅了，只不过对生电玩家不太友好。\n值得一提的是，这显卡在玩MC时功耗也只有30瓦左右，而且大多数时间风扇都不转，真的太环保了（\nArch Linux 整个安装Linux的过程十分顺利，不像笔记本那样经常遇到许多奇奇怪怪的问题。加上走的独显直连没有麻烦的双显卡混合交火，基本上是装好自己需要的软件后开机就直接用了。\n之前联想R7000P那个笔记本还经常无法调节屏幕亮度，TTY下面的警报“滴”声大得吓人，以前还遇到过nvidia+amdgpu+gnome进wayland就黑屏的问题（现在nvidia升470已经修复了）。\n曾经用的那个惠普更是因为英伟达显卡驱动和惠普奇葩的硬件在linux5.0内核之前经常出现黑屏死机这些问题，而且不开启独显的话就没办法连双显示器。\n所以还是台式机最香，觉得硬盘不够用了我就可以买块新硬盘扯根线扩容，主板上有4个内存插槽够我插很多根内存。CPU也都是可拆卸的只要主板支持我还可以继续升级，而且我可以选择没有集成显卡的CPU，显示器直连独显不用被那些驱动问题弄得头疼。\nOthers 其实最初我是想把装机的过程录下来拍成VLOG的，但是租的房子空间有限加上不想露脸，我一说话还会紧张不会组织语言，而且我没带三脚架，所以为了节省体力我只是拍几张照片放到博客上。\n尽管现在这个电脑显卡很差不能打大型游戏，但是他的强悍的CPU性能已经足够我干很多事情了。 一开始想测试一下CPU性能于是下载了Linux内核，用默认生成的config，make -j12编译。然后找个工具(lm_sensors)查看一下CPU温度。当我还没配好配置文件时突然发现内核他编译好了。\n然而除了写代码之外我暂时还没想好什么其他的使用这个电脑的方法。因为有点舍不得电费加上没有公网IP所以我也不打算把它当服务器用。\n可能有人会更关心我在北京实习的相关事情，其实我并不是不想写在博客里面，而是想等过几个月有了一个比较完整的实习体验后再写，因为最近每天都很忙而且心情变化很复杂，毕竟自己一个人离开学校到北京。所以我不想把某一刻的心情写在博客上当作我这一阵子的整体体验，现在还不是做总结的时候（心情好的话，也许我会写在今年年终总结上吧）。\n后续 2022-02-26补充:\n咱给这个电脑换了新的机箱，考虑了一下如果把换新机箱的内容添加到这里的话，会对原有的我组装电脑的内容产生影响，所以我新开了一篇博客，感兴趣的可以去看：电脑换壳——先马趣造。\n以后组装电脑相关的博客，都会在标签 台式机 里面找到。\nSTARRY-S\n","permalink":"https://blog.starry-s.moe/posts/2021/build-desktop/","summary":"\u003cp\u003e很久很久以前就想自己组装电脑了，看到别人能有台高性能的电脑别提有多羡慕了。不过考虑到在校期间实在不适合把自己组装的电脑放到寝室中去，要是把电脑放家里的话只能假期玩短短的几星期，其余的时间闲置下来的话又觉得有些浪费，于是组装电脑的计划一直推延至今。最终在大四校外实习自己租房子之后才有了一个短暂而勉强稳定的环境可以让我组装台式机，所以在安置好自己的住处和一系列其他事情之后，我终于可以实现自己这个埋藏心底多年的愿望之一了。\u003c/p\u003e","title":"我们来组装一台电脑吧"},{"content":"这是我入手的第一款RPG游戏，也是我迄今为止买的最贵的游戏，在大一的那个寒假狠下心来用压岁钱花了四百多在Steam上买的正版，后来在今年年初买PS4 Slim时又买了一张二手光碟以及DLC。\n尽管游戏玩了3遍，但是不敢保证说我把尼尔前前后后的每个细节都弄清楚，不过还是打算把我遇到的一些有意思的地方记录到博客中。\n遊樂園廢墟\n其实我今年4月份就把游戏就打完了，但是我硬是拖了这么久才把游玩记录写到博客上。\n记忆\n八音盒\n游乐园的月之泪\n充满“干劲”的机器人\n游乐园\n机器人版 罗密欧与朱丽叶\n描述人类残暴性的作品\n摸头\nNieR:AutoFishing\nLunar Tear\n4s\nA2\n艾米尔的家\n森林国王\n沉没都市\n艾米尔的决意\n9s 陪寝\n任务\n创造不是那么简单的事了\n记好啦\n最轻松的！\n第6次格式化\n女人真恐怖\nMorning!\nMeow\n4s\nHacking A2\nEmil\u0026#39;s Memory\nShare Happiness!\nEmil\u0026#39;s Home\n《没中》\n孩子们的核心\n晚安，好梦！\nBrother\n利落地杀掉我\n柏拉图\n柏拉图的回忆\n谢谢你愿意听我说话\ndeb[U]nked\n好一个逃离现场\n[E]nd\nNieR:Automata\n","permalink":"https://blog.starry-s.moe/posts/2021/nier_automata/","summary":"\u003cp\u003e这是我入手的第一款RPG游戏，也是我迄今为止买的最贵的游戏，在大一的那个寒假狠下心来用压岁钱花了四百多在Steam上买的正版，后来在今年年初买PS4 Slim时又买了一张二手光碟以及DLC。\u003c/p\u003e\n\u003cp\u003e尽管游戏玩了3遍，但是不敢保证说我把尼尔前前后后的每个细节都弄清楚，不过还是打算把我遇到的一些有意思的地方记录到博客中。\u003c/p\u003e","title":"NieR:Automata 游戏记录"},{"content":"很久以前就打算二刷空境原著了，由于种种原因进展一直比较缓慢。\n最终在 Kindle (泡面盖) 上阅读时标记了一些不错的菌言菌语，整理到博客上。\n俯瞰风景 飞行这个名词，与坠落这个名词是相连结的。但越是迷恋天空的人，越会欠缺这样的认知，结果死了之后也只能持续朝云端飞行，不会往地面坠落下来，等于是朝着天空坠落。\n视野并不是眼球看到的景象，而是大脑处理过的景象。我们的视野受到我们的常识保护着，不认为自身的高度叫高，甚至觉得是种常识，没有高这个概念存在。反过来说，凡是人类，都活在俯瞰的视野中。\n人是活在箱中的生物，也只能在箱中生活。\n在这短暂存在的密室里，现在无论外界发生什么事都与式没有关联，也无法产生关联。这份实际感受，微微沁入她本应空虚的心。\n——如果自身的视野就是世界的一切，此刻世界的确正在沉睡。\n如果城市是深海，夜空就是纯粹的黑暗。在那片黑暗上，星辰就像散落的宝石那般闪闪发光。月亮是洞穴，一个凿穿夜空这张黑色图画纸的巨大洞穴。\n月亮其实不是反射太阳的镜子，只是在窥视这一侧的景色——在两仪家，式曾听人这么说过。\n一头宛如以一根根丝线梳就的黑发顺滑无比，只要风势一大，黑发迎风飞舞的模样就散发出无比幽玄之美。\n刀刃有六寸长，与其说是刀更像是一柄只由白刃构成的凶器。\n因为天空没有尽头。我认为如果能无拘无束的漫游、能自由飞往任何地方，就可以找到我不讨厌的世界。\n所谓的 ‘逃’ 有两种，漫无目的的逃以及带有目的的逃。一般将前者称为 ‘漂浮’，后者称为 ‘飞行’。\n我们并不是根据背负的罪来选择道路，而是先选择道路再背负起自己的罪孽。\n虽然根本不值得一提，我终究认为自己最后还是应该死于从俯瞰坠落。\n无论当事人下了什么决定，自杀还是会被视为自杀来处理。\n杀人考察（前） 人要无知一点比较好，黑桐。人在小时候只看得到自己，根本不会察觉别人的恶意。就算是污秽也好，当被爱的感觉转化成经验，人才能够以善意去对待他人——因为人只能展现本身已具有的情感。\n你要当心点，黑桐同学。不详的预感，会招来不详的现实\n痛觉残留 无法适应社会的人非常多，他们的存在本身却从一开始就无法适应这个社会。他们不应该存在，不，是无法存在。\n这让她很高兴。因为活下去，就等于痛苦下去。\n被排除在境界之外的人，也会被彻底剥夺其存在意义。所以，那只不过是肉块罢了。\n对于想不通的事，不要强迫自己接受比较好。\n因为缺乏感觉的人一样拥有身体，也能够移动自如，我们就认为他们除了没有感觉之外没什么不同。但这是错误的。没有感觉，就代表什么都接收不到喔，黑桐。\n黑桐没能赶上是吗？接下来，就看暴风雨是先抵达，还是先被制造出来。式一个人去，有可能反被打败啊，两仪。\n痛觉可是种好东西，有错的终究是伤口，不可以搞错先后顺序。我们需要痛觉，无论多么痛苦都一样。\n“没有什么伤是无法痊愈的。不会痊愈的伤口不叫伤口，叫作死亡。”\n伽蓝之洞 如果眼睛看得见，我大概正看着他应付的笑容。\n“你的嗜好还真奇怪。”\n“我好高兴。真让人惊讶，没想到橙子小姐也有跟普通人一样的温情和道义精神！”\n“没错，你无法过着正常生活。要烦恼也该有个限度，两仪式，你该认清现实了。你原本就是属于我们这边的人吧？ 所以——别再梦想什么普通（幸福）的生活了。”\n这女的——真是专挑我逃避的问题刺人痛楚。\n正因为失去的事物永不复返，我决定不再后悔。\n矛盾螺旋 所谓的变成大人，就是明智地将幻想取代。\n自以为早熟的愚昧，让我骄傲地接受了这个事实。\n追求社会上理所当然的生活就得遭受打击。只要接受我的人生注定如此，就不会觉得自己不幸。这和小时候一样。我以聪明代替幻想，决定一个人活下去。\n我明明热爱奔跑，奔跑明明曾是我的救赎，到头来我却发现那不过是发生了一些不幸后便可以抛弃的东西，不仅愕然。\n只要一堕落，人是否就会变得这么婆婆妈妈的？我不禁傻眼。\n这家伙以前曾说心是看不见的。因此，她绝不会对别人吐露肉眼看不见的烦恼。\n所以——为了不再做梦，我只不过是在被杀前抢先宰了对方。\n忍耐明明是你的优点，结果你却选择了痛苦的那条路。第一次见面的时候，胭条巴正要抹杀胭条巴。失去未来，变成空壳的你，也跟现在一样想死是吗？\n“重点明明在于学到什么，这个国家却本末倒置。只要有真材实料根本不需要什么证据，大家却为了得到资格去学习，而不是透过学习的成果取得资格。一个只剩下用来证明‘我学到这么多！’的资格，不就像契约书一样。”\n或许，她就是将如暗处鲜花般优美的日本幽灵，与外国童话中的妖精融合而成的结晶。\n“和他们结识，算是我在伦敦时唯一的疏忽吧。”\n灵长已经变得太复杂，是过度追求万能，替生命附加种种能力导致的结果。\n朦胧不定的东西会召唤朦胧不定的言语。事情明明这么简单，方才的平稳气息却已散去，让人难以呼吸。\n那是因为无论拥有怎样优秀的肉体、素质，对于一个人来说只能把一件事情做到极致。去到高处的话可以，然而除此以外的山便无法去攀登了。\n“你这是什么表情。让那系统崩坏掉的人就是你吧。所谓的精神异常者呢，由于自以为自己的异常是梦境所以才没有破绽。式过去也是这样的。但是却不由得注意到了名为黑桐干也的人。于是对两仪式的存在方式察觉到了异常。”\n“哦，离题了。说着与两仪有关的话就没有注意到，似乎是被什么逼迫着一般。不知不觉就说多了。说不定黑桐你明天就死掉了呢。”\n“\u0026hellip;\u0026hellip;不敢当。我会小心车子的。”\n也就是指男性之中的女性部分和女性之中的男性部分。从男性的语气来推断出是阳性，这结论未免下得太早了。无论是谁都会拥有偏向异性的思考模式。男扮女装的怪癖是最为典型的。现在的式毫无疑问是阴性的式。男性的语气，是她为了死掉的织而在无意识下进行的代偿行为。至少，是希望你还能够记得织的事情也说不定。呼呼呼，这不是很可爱吗？\n“\u0026hellip;”\n由于没有任何一点小的异常，所以也就注意不到大的异常。\n“要打开了。这可是阔别半年的自己的家呦，胭条。”\n两仪很开心似的说着。\n若不在人们身上使用相同的仪式死亡，给你的献祭便不完全。如果死亡之后再次复活的螺旋不完全。没有达到相互交缠且相克的条件，便无法将其联系起来。于是我便准备了他们的尸体作为阴，他们平常的生活作为阳。\n死者与生者无法兼容。在满是矛盾的这个世界中，个体是没有共通这层意义的。\n第一次脱离了死的困境，但那只不过是为了迎接第二次、第三次的死所注定的方法。这种有限的死的方式。\n“\u0026hellip;\u0026hellip;推了煞车坏掉的人一把，这种做法是不对的。”\n为了消除现象而引起的现象，最终会变成将自己向绝境逼迫的行为。但是果然，即使留下最初的现象不管，也会演变成被逼迫至绝境的情形。无论怎样努力，现象这个词的含义是不会消失的。\n由于事物总是连带有许多阻碍，所以并不存在完美的事物。\n橙子小姐的言辞一针见血。\n不过到了近代这种称呼就不再使用了。文明发达了，人们变得很容易就能够将自身灭绝。\n“学问和年龄无关，柯尼勒斯，虽然你外表看起来很年轻，但你总是只注意外表，所以内在才会追不上啊。”\n人类的个体若是完成，生存的意义就会消失。但各种人类却只为了生存下去的欲望而无意识地拒绝它，所有的人类在以人类身份思考时，变成比动物还要不如。明明为了完成而生存，却为了生存而拒绝完成。\n让一个人了解事物，与其教他，不如让他自己体验来得快。\n生命的证据不是如何去追求快乐，因为生命的意义，就是要去体会痛苦。\n——风停了，信号也已响起。\n来吧 ——该开始认真地奔跑了——\n我虽然讨厌别人的同情，但我知道拒绝别人同情的代价，最后报应会发生在自己身上。\n然后，男人的手伸了过来。\n“一个人站不起来的话，我就助你一臂之力吧。”\n男人“嗯”的一声，毫不做作地笑了。\n“我也认为你应该会这么说的。”\n那是一股不可思议、连我也想回报的笑容。\n“你就拿着吧，因为这以后得由你来守护才行。”\n我努力露出灿烂的笑容，但不知道是不是顺利笑了出来。\n“\u0026hellip;\u0026hellip;我也一样，希望有人来帮我，一直希望有人来帮我，但是，我却不知道该把自己从哪里解放出来\u0026hellip;\u0026hellip;而结果也不该知道的，因为根本没有可以帮助我的方法。不管意义如何替换，只有一开始的现象无法消除。”\n他回头看了一眼，那个被蒸汽和水声包围的地下室非常安静。那是连自己死了都不知道，到今天也还继续梦见日常之轮的脑髓灵魂安置所。\n但那也是不可能的，扭曲的轮回不会在同一个地方转动，若死者不能亲自结束身为死者的存在，日常生活永远不会到来。\n\u0026hellip;\u0026hellip;我失败了。不该和这些怪物扯上关系啊！\n\u0026hellip;\u0026hellip;那就是，红大衣魔术师最后的思考。\n从走廊看出去的夜景很安静、很寂寞，公寓周围只存有旁边那栋形状相同的公寓，公寓之间铺着柏油道路，还有绿色的庭院。那光景，与其说是夜景，还不如说是被绿意包围的墓碑。\n“为什么回来。”\n魔术师用沉重的声音问着。\n巴无力回答，只是一直看着荒耶。他没有回答的余力，若不是全力集中精神，他连正面看着魔术师也作不到。\n你的意志只不过是由幻想产生，由幻想所活化的东西而已。在这个世界死亡的胭条巴，已经只能在这里生活了。\n事情就是因为有尽头，所以才能观测到无限这件事。\n忘却录音 在确认自己的记忆时，不可以依靠他人的记忆。毕竟只有名为回忆的自我天平，才能决定过去\u0026hellip;\u0026hellip;\n所谓的忘记，其实是记忆劣化。回忆是一种不会消失、只会逐渐褪色的废弃物。你不觉得很可惜吗？人们竟然让属于永恒的事物生锈。亲手让身为永恒的事物化为烟尘。\n污秽由污秽自己解决是最好的作法，因为不管是什么人，想要清除污秽，就一定会受到污秽沾染，这是一个不详的循环，我们称之为 ‘诅咒’。\n所谓的天才，到最后只是把自己当成对手。\n妖精很难控制，操纵者常常在不知不觉间，从实现他们自己的愿望变成实现妖精的愿望。鲜花你听清楚了，要注意——使用自己以外的东西所制造出来的使魔，别走到操纵者反被操纵的下场\n我的能力只能从别人已经走过的道路来获得信息，但你却可以看到接下来的路通往哪里呢\u0026hellip;\u0026hellip;\n人之所以选择忘却记忆，绝不是因为那些记忆没有必要，而是因为记住那些事很危险。\n我们刻意忘却过去犯下的种种过错。忘却那些如果记得就会让自己崩溃的记忆。我们靠着这么做——才能守护自己现在是健康而无辜的幻象。\n“物质是用来消费及磨耗的事物，这个名为地球的世界逐渐走向崩坏也是自然的道理，因为在最后走向死亡是最正确的存在方式，所以谁也不会去解决这个问题。对我们来说，真正的世界只存在于各自的脑髓中而已。”\n杀人考察（后） 本能在表层意识具现化成人格时，将会驱逐所有理性，会凌驾我这个名为白纯里绪的人格。\n向对方抱有的情感，超出自己的容许量的时候吧，自己能承受的感情量是一定的，有些人容量很大，也有人容量很小，不论是爱情或者是憎恨，当那种感情超过自己所能容纳的量，那么超出的部分会转变为痛苦，如此一来，便不能忍受对方的存在。\n为了到最后让自己死去，所以我们只有杀一次人的权利。\n人一辈子只能承受一人份的人生价值，为了原谅无法走到尽头的人生，所以大家才会用尊重的态度看待死亡，因为生命等价，即使是自己的生命，也不是自己所拥有的东西。\n光是孕育意识的大脑，无法产生人格。虽然只有脑部也可以活下去，但我们必须先拥有肉体才能产生自我意识。有了肉体之后，和肉体一起培养，就有了现在的人格。喜爱自己肉体的人，应该属于社交型人格，而厌恶自己肉体的人，则属于内向型人格。虽然光有意识也可以培养出人格，但那样的人格是无法认识自己的，一般来说，心灵就会长成特别的东西。那样的话，已经不能称之为人格，和计算机没有什么不同。如果有谁只是一个大脑，那个人就必须创造出一个 ‘只有脑的自己’ 的人格。必须舍弃肉体这个大我，而保存意识这个小我。\n“不是有了知性才有肉体。”\n“而是，有了肉体之后，知性才得以诞生。”\n说到底，人类只不过是在自己这个空壳中做着梦而已。明明是那么地显而易见的。\n大部分的人并不是出于自己的愿望要过那样的生活。想要成为特别的存在却无法实现，这种形式才是真正的平凡人生。\n未来福音 她擅长的并非预测未来，而是教人如何避免遭遇到不幸。\n那是一种希望，希望对方相信她说的话。也是一种绝望，绝望于对方不可能相信。\n所谓的现实，即为数值尚未确定的公式。公式的数值会不断变动，不用说是求出答案，人们连要求出什么都不知道。然而——一旦这个数值确定下来，答案便再也不会改变。\n这一切都是醒着的，但没有什么活着的样子。没有任何例外。\n“就是因为知道得太清楚，才会看不见吗——橙子说得对极了。炸弹魔，你有没有听到？既然你的眼睛什么都没看见，不如废了算了。”\n“未来并没有不同。‘未来’这种东西，一开始便不存在。不存在的东西，当然没有办法控制。”\n她依然是老样子，即使自己遇到不幸，也没有显露出来，仍旧表现得潇洒又懒惰，完全就是时下高中女生会有的样子。\n“没错。那顶多算是憧憬。你就像个看到偶像，拼命叫个不停的幸福小粉丝。所谓的恋爱啊，应该要更轰轰烈烈、更不堪回首、更捉摸不定，如同不是抵达终点，便是发生意外的云霄飞车。总之啊，谈恋爱不可能留下什么美好回忆\u0026hellip;\u0026hellip;”\n“我漂亮地踩到地雷。”\n既然我可以用未来视取巧，相对地当然要承担一些代价。\n不论谁看见她，都会期待她未来的发展，另一方面，又暗暗希望她永远维持现在的样子\n在这个时代，幸福的未来相当罕见。\n既然看得见未来，当然也会了解过去。\n这十年——不，说得更正确，是十二年来，我始终像故事中模仿人类的机器人，融入这个城市的生活罢了。\n我遇见难得的朋友，之后又失去他。尽管试着承续他的衣钵，却每天被唯一的读者批评。\n尽管我也为此付出代价，往后的人生满是失败。但我至少还留有什么。\n“你很快会从这个世界上消失。你的前途一片漆黑，未来完全没有任何希望。你不会留下任何东西，也没有获救的可能\u0026hellip;\u0026hellip;但是，太不可思议了，尽管如此，你的梦想将继续活下去。”\n","permalink":"https://blog.starry-s.moe/posts/2021/karanokyokai/","summary":"\u003cp\u003e很久以前就打算二刷空境原著了，由于种种原因进展一直比较缓慢。\u003c/p\u003e\n\u003cp\u003e最终在 Kindle (\u003cdel\u003e泡面盖\u003c/del\u003e) 上阅读时标记了一些不错的菌言菌语，整理到博客上。\u003c/p\u003e","title":"《空之境界》摘抄"},{"content":"其实咱很久很久以前就开始看LearnOpenGL CN这个网站了\u0026hellip;\u0026hellip;\n前言 首先需要明白什么是核心模式，什么是立即渲染模式，立即渲染模式的代码中都包含glBegin()和glEnd()，绘图的部分都是在这两个函数之间，比如画一个点就是glVertex2f(x, y)，这种方式画图确实很简单，用户只要提供坐标和颜色就好了，不用知道GPU干了什么，而缺点是性能低，有很多限制，所以新版本的OpenGL为了给开发者提供更多的可操作空间而逐渐废弃了立即渲染改用核心模式。\n核心模式提供了很多强大的功能，可以管线编程，代码量增加了很多，所以对初学者不太友好。\nLearnOpenGL CN上面的代码基于C++，而OpenGL是用C编写的，教程上的代码除了矩阵运算部分可以使用C++的运算符重载而使代码编写起来变得更简单一些外，其他部分基本没啥区别，而且教程为了便于教学使用的也是面向过程式编程，没有将各个功能封装到一个类里面，所以咱这篇教程用C编写。\n要记住C就是C，C++就是C++，C不是C++的子集，只能说C++兼容部分C的代码，不要把C和C++混用，不要因为C++支持面向对象使得一些功能看起来简单很易于使用就轻易迈入C++的坑。\n准备工作 有关OpenGL的介绍以及安装GLFW、GLAD以及编译所需的CMake的部分可以直接看教程，咱尽可能把教程上没有提到的或者是刚开始学OpenGL很难理解的部分记录下来。\n大体上就是安装glfw，Arch Linux使用包管理器sudo pacman -S glfw-x11 (如果你使用的是wayland，那么安装glfw-wayland)，然后把下载的glad/glad.h复制到/usr/include下，把glad.c复制到工程文件夹的代码目录下。\n为使用CMake生成Makefile，编写CMakeLists.txt:\ncmake_minimum_required(VERSION 3.0) project( \u0026#34;Learn OpenGL\u0026#34; LANGUAGES C VERSION 0.1.0 ) set(C_FLAGS \u0026#34;-Wall -lm -ldl -std=c11\u0026#34;) set(CMAKE_C_FLAGS ${C_FLAGS}) set(OpenGL_GL_PREFERENCE LEGACY) find_package(glfw3 REQUIRED) find_package(OpenGL REQUIRED) include_directories(${OPENGL_INCLUDE_DIR} src) aux_source_directory(\u0026#34;src\u0026#34; GLSRC) add_executable(main ${GLSRC}) target_link_libraries(main ${OPENGL_gl_LIBRARY} glfw) 完成上述步骤后，确保工程文件夹的结构如下：\n├── build/ ├── CMakeLists.txt └── src/ ├── glad.c └── main.c 创建窗口 编辑main.c，加入所需的头文件\n// glad.h要加在glfw3.h之前 #include \u0026lt;glad/glad.h\u0026gt; #include \u0026lt;GLFW/glfw3.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; 在main函数中初始化OpenGL并创建窗口\nint main(int argc, char **argv) { glfwInit(); /* 使用OpenGL版本为3.3 */ glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); /* 使用核心模式 */ glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); #ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); #endif /* 创建窗口 */ GLFWwindow *window = glfwCreateWindow(800, 600, \u0026#34;Hello World\u0026#34;, NULL, NULL); if (window == NULL) { fprintf(stderr, \u0026#34;Failed to create window.\\n\u0026#34;); glfwTerminate(); return -1; } glfwMakeContextCurrent(window); /* 初始化glad */ if (!gladLoadGLLoader((GLADloadproc) glfwGetProcAddress)) { fprintf(stderr, \u0026#34;Failed to initialize GLAD\\n\u0026#34;); glfwTerminate(); return -1; } /* prepare render */ /* main loop */ glfwTerminate(); return 0; } 创建窗口的代码比较容易理解，到这里可以尝试编译一下代码检查有没有遇到什么问题，如果编译失败了可以尝试检查GLFW是否安装正确，代码哪里出现了什么问题。\n编译代码并运行生成的程序：\ncd build cmake .. \u0026amp;\u0026amp; make -j8 ./main 如果一切正常的话，可以看到窗口一闪而过就消失了，因为到目前为止我们只创建了一个窗口，创建完成后就结束了程序，所以窗口会瞬间消失。\n准备绘图 在绘制形状之前，我们需要一些准备工作比如设定视口、回调函数，创建顶点缓冲区等操作，然后在大循环中进行渲染绘制。\n视口 首先要告诉OpenGL咱的窗口尺寸是多少，以便OpenGL根据窗口大小显示数据和坐标。\n在/* prepare render */处添加代码：\nglViewport(0, 0, 800, 600); 首先需要知道你传给OpenGL的坐标都是-1.0到1.0之间的数，OpenGL再将其转换成屏幕上的像素点坐标，这个过程由GPU运算所得，所以你得告诉OpenGL你的屏幕尺寸，glViewport的前两个参数为0, 0指的是窗口左下角的位置，这个值咱目前不需要修改。\n回调函数 我们需要一个窗口被更改的回调函数，这样当窗口尺寸发生变化时，程序可以调用这个函数调整视口。\n我们还需要一个按键回调函数，当用户按下键盘上的某个按键后会调用这个回调函数处理按键操作。\n编写函数framebuffer_size_callback用来处理窗口尺寸更改:\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height) { glViewport(0, 0, width, height); } 这样当你拖拽窗口进行缩放时，窗口里的图像也会跟着窗口尺寸改变而进行缩放。\n编写key_callback函数处理用户按键操作：\nvoid key_callback(GLFWwindow *window, int key, int s, int action, int m) { if (key == GLFW_KEY_ESCAPE \u0026amp;\u0026amp; action == GLFW_PRESS) { glfwSetWindowShouldClose(window, GL_TRUE); } if (key == GLFW_KEY_Q \u0026amp;\u0026amp; action == GLFW_PRESS) { glfwSetWindowShouldClose(window, GL_TRUE); } } 当用户按下ESC或Q键时，可以结束OpenGL窗口的运行。\n然后我们需要注册这两个回调函数，在/* prepare render */处添加下面的代码:\nglfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetKeyCallback(window, key_callback); 大循环 在大循环中，每循环一次代表绘制一帧画面。这里利用了双缓冲将绘制的图形放到缓存中，然后将缓存中的图形刷新到显示器上。(因为OpenGL绘图操作是逐行绘制的，如果不先将图形存到缓存中而直接显示在显示器上的话，在画面快速变动时你很可能会遇到画面撕裂，垂直不同步)\n大循环部分的代码长这个样子:\nwhile(!glfwWindowShouldClose(window)) { /* 清空背景色为深灰色 */ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); /* draw something */ /* swap buffer */ glfwSwapBuffers(window); glfwPollEvents(); } 每次循环的开始需要使用glClear清空屏幕，这样就不会看到上一次渲染的结果。\n这里我们使用glClearColor设定清空屏幕的颜色为接近纯黑色的灰色。\n大循环每循环一次，OpenGL就渲染了一帧画面并显示在显示器上，所以你可以计算一秒钟循环的次数而估算游戏的帧率。\n因为我们使用了双缓冲，所以这时游戏的帧数被限制为等于显示的刷新帧数， 比如显示器刷新率为144帧，游戏的帧率就被锁为144，如果想解除这个限制需要改为单缓冲。\n到此为止，我们已经创建了一个游戏引擎，但是这个引擎还什么都没有做。\n尝试编译代码，可以看到一个黑色（深灰）的窗口，按ESC或Q即可结束运行。\n创建窗口\n如果你遇到什么问题，可以对照一下代码是否有问题。\n三角形 画三角形的过程很简单，首先要确定三角形的三个顶点坐标，然后告诉GPU这三个点坐标就可以了 :)\n如果你看不懂顶点着色器、几何着色器、片段着色器、光栅化这些难懂的知识点，那么你不必急于弄懂这个过程，等把图形绘制出来后再回来看这部分的内容。\n标准化设备坐标 因为OpenGL的坐标为都是-1.0f到1.0f之间的数（我们先不考虑视口变换这些复杂的情形）\nx, y, z的坐标为-1.0f到1.0f的坐标称作标准化设备坐标，坐标原点在窗口的正中央且在窗口的表面上，往右为x正方向，往上为y正方向，往屏幕里面为z正方向（这里是左手系）。\n有关标准化设备坐标的介绍请看这里。\n所以我们先声明三角形的顶点和颜色值到一个一维数组里面（用一维数组是因为顶点坐标值在内存的分布都是连续的，这样方便给GPU传坐标）。\nfloat vertices[] = { -0.5f, -0.5f, 0.0f, // 左下角 1.0f, 0.0f, 0.0f, // red 0.5f, -0.5f, 0.0f, // 右下角 0.0f, 1.0f, 0.0f, // green 0.0f, 0.5f, 0.0f, // y轴正上方 0.0f, 0.0f, 1.0f // blue }; 顶点缓冲 首先我们需要创建一个顶点缓冲对象，用来存我们的顶点信息，这个对象叫“Vertex Buffer Object”（VBO），之后创建一个顶点数组对象“Vertex Array Object”（VAO），用来存我们创建的VBO。\n为便于理解，你可以把VBO当作为开辟了一块GPU上的显存(Buffer)，用来存顶点和颜色信息，然后VAO是一个包含多个VBO的数组(Array)。\n绘图时可以把VBO中存的大量顶点信息发送给GPU，因为用CPU给显卡发顶点坐标的速度慢而且没办法一次发送大量的顶点坐标，所以我们把顶点坐标存到显存中，绘图时直接访问显存即可。\n生成一个VBO和一个VAO的代码为：\n// VAO和VBO的ID都是非负整型 GLuint VBO, VAO; // 生成一个VAO和一个VBO glGenVertexArrays(1, \u0026amp;VAO); glGenBuffers(1, \u0026amp;VBO); 我们刚刚创建好了一个缓存对象，我们现在需要告诉这个缓存的数据空间大小以及数据（顶点坐标）。\n首先我们绑定刚创建的VAO，然后绑定VBO\nglBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); 之后给VBO传递数组信息\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 第一个参数是目标缓冲的类型，我们刚刚把VBO绑定到GL_ARRAY_BUFFER上了\n第二个参数是顶点信息所占的空间大小，单位是字节。三角形一共3个顶点，每个顶点有3个坐标值和3个颜色值，\n所以大小是6 * 3 * sizeof(float)，不过我们可以直接用sizeof(vertices)知道整个数组的大小。\n第三个参数是数组的地址\n第四个参数告诉GL我们的顶点数据几乎不会改变，所以是GL_STATIC_DRAW。\n如果数据会被改变很多次，则为GL_DYNAMIC_DRAW\n如果数据每次绘制都会更改，则改为GL_STREAM_DRAW\n然后我们告诉CPU我们给VBO传递的数组都是什么：\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*) 0); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*) (3 * sizeof(float))); glEnableVertexAttribArray(0); glEnableVertexAttribArray(1); 第一个参数为位置，告诉这个数据传递到顶点着色器的哪个位置上\n第二个参数为大小，我们定义的那个数组一个顶点有3个坐标，所以是3\n第三个参数为数据类型，这里是float。\n第四个参数为false，暂时不用管他\n第五个参数为步长，一个顶点有三个坐标和三个颜色值，所以每传一个顶点，就走6 * sizeof(float)的长度。\n第六个参数为偏移量，因为我们定义的数组中前三个数字代表顶点坐标，后三个数字代表颜色，所以传递顶点坐标时，偏移量为0，传递颜色时偏移量为3 * sizeof(float)。\nVBO中内存数据\n之后使用glEnableVertexAttribArray告诉OpenGL启用顶点着色器上这个位置的数据。\n最后使用完VAO后要记得将其解绑：\nglBindVertexArray(0); 着色器 我们需要写两个着色器程序，分别为顶点着色器和片段着色器。\n开头说的核心模式可编程管线就是指我们可以写着色器程序，手动指定管线都进行什么操作。\n顶点着色器 因为OpenGL使用的是标准化设备坐标而不是屏幕上的像素点为坐标，所以GPU需要把标准化设备坐标转换为屏幕上的像素点，这个过程由顶点着色器实现。\n而顶点着色器不知道咱们三角形的每个顶点的坐标是多少，所以咱们得往着色器中传我们刚才创建的VBO里面存储的坐标。\n着色器程序使用GLSL编写，其代码和C很像\n在代码文件夹中新建一个vertex.glsl，编写以下代码：\n#version 330 core layout (location = 0) in vec3 aPos; // 传入坐标 layout (location = 1) in vec3 aColor; // 传入颜色 out vec3 color; // 向片段着色器发送颜色 void main() { gl_Position = vec4(aPos, 1.0); color = aColor; } 第一行代表我们使用OpenGL 3.3 核心模式\n第二行声明了一个类型为vec3（三维坐标）的变量，该变量的位置为0，需要人为的通过这个位置给他传值，这个变量代表顶点的坐标\n第三行声明的aColor用来代表颜色，顶点着色器不需要处理颜色，所以我们接收到颜色值后不需要处理，直接传出去即可。\nmain函数中gl_Position代表这个顶点的位置坐标，我们把CPU传给顶点着色器的vec3转换为vec4。\n片段着色器 顶点着色器处理完顶点后，由片段着色器计算每个像素点的颜色，所以如果我们想给三角形上色的话，也是在这个环节进行。\n在代码文件夹中新建一个fragment.glsl\n#version 330 core in vec3 color; // 接收顶点着色器发送的颜色 out vec4 FragColor; void main() { FragColor = vec4(color, 1.0f); } 第一行同顶点着色器，代表OpenGL版本为3.3 核心模式\n第二行表示接收顶点着色器发送的颜色数据到变量color\n第三行声明了一个类型为vec4(4维坐标)的变量，表示向外传递变量FragColor（该像素点的颜色值）\nmain函数中设定变量FragColor的值等于color，用来指颜色。\n最后一个值恒为1.0f，我们暂时不需要修改它。\n编译着色器 因为我们只是写了着色器程序的代码，需要让GPU将其编译。\n编译着色器的部分对应的LearnOpenGL CN教程在这里，本篇不打算重复讲编译着色器部分的代码。\n我们可以把编译着色器的代码封装到几个函数里面，这样可以减少main函数中重复代码的数量。\n有关这部分的代码我推荐使用这篇文章中讲述的方式从文件中读取glsl代码并将其编译。\n最后在main函数的准备阶段处的最下面，插入以下代码，编译你的着色器程序：\nGLuint shaderProgram = load_program(\u0026#34;vertex.glsl\u0026#34;, \u0026#34;fragment.glsl\u0026#34;); 我们期待的三角形 经过了前面的一番准备，我们创建了缓冲对象存顶点的坐标和颜色信息，之后编写了着色器程序处理顶点坐标和颜色。\n现在我们终于可以在大循环中画三角形了。\n在大循环的/* draw something */下面添加如下代码：\nglUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES, 0, 3); glBindVertexArray(0); 这串代码表示我们首先使用刚编译好的着色器程序，之后绑定VAO，绘制一个三角形，最后解绑。\n至此我们的工程文件夹结构修改如下：\n├── build/ ├── CMakeLists.txt └── src/ ├── fragment.glsl ├── glad.c ├── main.c ├── shader.c ├── shader.h └── vertex.glsl 因为我们编写了vertex.glsl和fragment.glsl，需要修改CMakeLists.txt，使得编译时将代码文件夹下的着色器文件复制到build文件夹下。\n在CMakeLists.txt的find_package下面添加如下代码：\nconfigure_file(src/vertex.glsl vertex.glsl COPYONLY) configure_file(src/fragment.glsl fragment.glsl COPYONLY) 编译后运行程序，可以看到一个五颜六色的三角形，它的左下角为红色，右下角为绿色，顶点为蓝色。\n三角形\n如果你遇到了问题，或者哪里不太明白，可以看咱写好的代码：\nmain.c\nshader.h\nshader.c\nvertex.glsl\nfragment.glsl\nCMakeLists.txt\n","permalink":"https://blog.starry-s.moe/posts/2021/learn_opengl/","summary":"\u003cp\u003e其实咱很久很久以前就开始看\u003ca href=\"https://learnopengl-cn.github.io/\"\u003eLearnOpenGL CN\u003c/a\u003e这个网站了\u0026hellip;\u0026hellip;\u003c/p\u003e","title":"Learn OpenGL"},{"content":"旧电脑坏掉了，因为坏的有些复杂而且不忍心拿到学校的修理店去修于是打算等到暑假有时间自己买零部件修。（就不吐槽惠普的产品设计问题了\u0026hellip;\n于是在网上逛了一会下决心再也不碰惠普了之后买了联想R7000P 2020，满血RTX 2060(这里指的是最大功耗为115W的笔记本显卡) + R7 4800H还是很香的，打守望屁股终于能稳定200+fps了。\n所以隔了这么久我终于更新博客了。\n本篇原标题为「联想R7000P上手体验」，因为内容大多在讲安装Linux时遇到的问题及解决方法，所以把标题更改为「联想R7000P安装Arch Linux的常见问题」。\n安装Arch Linux 到手后就把之前买的西数SN750 1T固态换到了新电脑上，顺便格式化重装了个系统。\n双M2插槽配上1T + 500G NVME，美汁汁。\n于是直接给Linux分了150G root，16G SWAP，500G HOME（有点奢侈）， 然后还分了100G用来存steam游戏，剩下的全扔给Windows。\n装Linux过程中只遇到了终端的警报声有些大这个问题（插耳机时声音依旧从扬声器输出），别的问题都没遇到。\n之前的电脑总是遇到奇葩问题，用旧版本Linux内核关机或者lspci时会卡死，显卡驱动装不好会导致开机死机，声卡驱动一直有问题听歌时音量大一点就爆音，HDMI接口直连的NVIDIA显卡所以显卡驱动没配置好独显不工作时没办法外接显示器(后来才知道type c接口有DP视频输出)。\n新电脑买来装完系统后就遇到了一点小问题网上搜一下就解决了。\n屏幕亮度不能调节 开个浏览器能把眼睛晃瞎\n网上查了一下只有在bios设置为独显直连时解决亮度不能调节的方法，在混合显卡模式下，存在AMD显卡亮度用16位值表示而不是8位值表示的这个BUG (Feature?)所以没办法调节亮度。\n所以cat /sys/class/backlight/amdgpu_bl0/actual_brightness得到的是一个大于255的数。\n确保内核和显卡驱动都是最新的情况下，编辑内核参数amdgpu.backlight=0和acpi_backlight=vendor，可以解决混合模式下AMD显卡不能调节亮度这个问题。\n如果你经常切换混合模式和显卡直连模式的话：\n安装显卡驱动xf86-video-amdgpu和nvidia以及按需要安装nvidia的其他组件。\n复制/usr/share/X11/xorg.conf.d/10-nvidia-drm-outputclass.conf到/etc/X11/xorg.conf.d/\n编辑/etc/X11/xorg.conf.d/10-nvidia-drm-outputclass.conf在EndSection前添加一行参数允许nvidia驱动调节亮度。\nOption \u0026#34;RegistryDwords\u0026#34; \u0026#34;EnableBrightnessControl=1\u0026#34; 之后编辑/etc/modprobe.d/blacklist.conf禁用闭源驱动nouveau和ideapad_laptop，让显卡驱动调节亮度。\n# /etc/modprobe.d/blacklist.conf blacklist nouveau blacklist ideapad_laptop 编辑内核参数添加acpi_backlight=vendor和amdgpu.backlight=0。\n以systemd-boot为例:\n# /boot/loader/entries/arch.conf options acpi_backlight=vendor options amdgpu.backlight=0 最后重启电脑就能调亮度了。\nGDM不自启动 开机时GDM不会自动显示出来而是得手动切TTY2再切回TTY1才能显示。\n查Wiki得知是因为GDM在显卡驱动被加载之前就启动了。\n参照Wiki，设置KMS早启动。\n编辑/etc/mkinitcpio.conf\n# /etc/mkinitcpio.conf MODULES=(nvidia nvidia_modeset nvidia_uvm nvidia_drm amdgpu radeon) 如果你只使用独显直连模式的话可以去掉amdgpu和radeon。\n然后sudo mkinitcpio -p linux重新生成内核镜像，之后重启。\n这么做会使Wayland在开机时被禁用，所以在混合模式使用AMD显卡开机时无法使用Wayland，参见Wiki。\n将/usr/lib/udev/rules.d/61-gdm.rules复制到/etc/udev/rules.d/，并编辑61-gdm.rules将下面这一行注释掉：\nDRIVER==\u0026#34;nvidia\u0026#34;, RUN+=\u0026#34;/usr/lib/gdm-disable-wayland\u0026#34; 之后重启电脑再开机echo $XDG_SESSION_TYPE就可以检查现在使用的是wayland了。\nOptimus Manager 因为独显功耗太高了，使用独显直连模式在浏览网页写文档这类的轻度工作时电池待机只能2小时，用混合模式的话能待机4.5小时，外加上我也不打那些对性能要求很高的游戏， 所以日常使用时就在Bios里设置显卡为混合模式。\n然后在Linux系统里安装optimus-manager，修改配置为：使用电池开机时关掉NVIDIA显卡，只让AMD集显工作；有外接电源时则使用“hybrid”混合模式，如果需要玩游戏的话用nvidia-prime让独显运行游戏。\nOptimus Manager的配置方法和之前我之前配置旧电脑时讲的基本一样，唯一区别就是这电脑是AMD，旧电脑是Intel。\n所以编辑配置文件修改了这些地方：\n# /etc/optimus-manager/optimus-manager.conf # 设置开机自动切换显卡模式 startup_mode=auto # 使用电池时关掉独立显卡降低功耗 startup_auto_battery_mode=integrated # 使用外接电源时为混合模式 startup_auto_extpower_mode=hybrid [amd] # 因为安装的xf86-video-amdgpu, 所以修改驱动改为amdgpu driver=amdgpu 安装好nvidia-prime后在混合显卡模式（hybrid）下，使用prime-run让独显运行游戏。\n如果想让Steam以独显运行游戏，修改启动参数为prime-run %command%。\nWindows 在Windows系统下显卡独连时字体渲染有些蹦，设置了ClearType之后还是没啥改善。\n主要是Visual Studio 2019的字体渲染真的瞎眼，最后装了Text Sharp插件换了Jet Brains字体才看起来正常了一些。\n最后在NVIDIA控制面板全局设置里把平滑处理全关了，字体的锯齿才消失。\n貌似是因为NVIDIA把文本编辑器当游戏渲染了。\nOthers 在Linux系统里会遇到按Fn+Esc键时FnLock的灯没有亮这个问题，不过不影响FnLock的正常使用，所以就忽视了。\n如果要用诱骗线充电的话，用optimus-manager把独显关掉（用nvidia-smi得知独显在不使用的情况下仍有5W的功耗），然后装一个CPU功率调节的软件，例如cpupower-guiAUR，设置为节电模式，实测用小米65W GaN充电器给电脑充电，轻度使用没有卡顿掉电的情况。\n因为之前趁着狗东打折加上买显示器送的100E卡，只花了两百多买了一个紫米20移动电源（板砖），25000毫安且支持100WPD充电。按照上面讲的方法在电池满电的情况下一边轻度使用电脑一边充电，充电宝能用4小时左右，然后笔记本的电池还能续航4至5小时。（实在是因为原装充电器它太沉了）\n目前来看觉得这电脑还是蛮香的，AMD的CPU性能很强而且比intel版的Y7000P便宜一千块钱。尽管现在已经有二线厂商做AMD 5800系的笔记本了但是4800H的性能依旧够用，RTX3060显卡就当它是空气吧就算发售也是残血而且抢不到。\n然后就是电脑没有雷电3接口，只有一个支持USB3.2 Gen1的type c接口且支持DP1.2视频输出，不过USB接口倒是挺多的，电脑用到现在没有遇到啥AMD CPU引起的兼容性问题。\nGNOME 40\n","permalink":"https://blog.starry-s.moe/posts/2021/lenovo-r7000p/","summary":"\u003cp\u003e旧电脑坏掉了，因为坏的有些复杂而且不忍心拿到学校的修理店去修于是打算等到暑假有时间自己买零部件修。（就不吐槽惠普的产品设计问题了\u0026hellip;\u003c/p\u003e\n\u003cp\u003e于是在网上逛了一会下决心再也不碰惠普了之后买了联想R7000P 2020，满血RTX 2060(这里指的是最大功耗为115W的笔记本显卡) + R7 4800H还是很香的，打守望屁股终于能稳定200+fps了。\u003c/p\u003e\n\u003cp\u003e所以隔了这么久我终于更新博客了。\u003c/p\u003e","title":"联想R7000P安装Arch Linux的常见问题"},{"content":"本来路由器闲置了一年了都没咋用了，前两天想把OpenWrt系统刷回原厂系统。\n然鹅刷原厂固件时忘记改环境变量了，因为第三方Boot Loader也被我顺带刷回了原厂的所以现在开机无限重启。\n之前买单片机套件时赠了一条usb转ttl线的，但是被我放学校了。只好再从万能的某宝再买一条线，尝试着救砖了。\n(在某宝发现了一家店啥元件都有，还特别便宜。于是我还顺带买了很多杜邦线、电阻、LED灯、面包板等小玩意\u0026hellip;)\n砖了 拆机 Are You OK?\n北方冬季气候干燥，拆机时记得放静电，找根铁丝把自己连地线上 (找个金属外壳是接地的电器和自己连上也行)。\n拆开路由器外壳，卸下主板，顺手拆掉了散热片（屏蔽罩）。\n串口在图片上主板的左侧，旁边有标记，从上到下依次是TX、GND、RX、1。需要注意的是主板上的TX要接到usb串口的RX，主板上的RX要接到usb串口的TX，GND连GND，VCC不用连。为了防止接错线，小米还十分贴心的标注了每个接口对应的连接线的颜色。\nI\u0026#39;m very OK!\n找出家里吃灰好几年差点被我扔掉的电烙铁，刮刀头刮了半天电烙铁才上锡，把新买的杜邦线母线焊到主板上，和ttl串口线相连。\n(电烙铁太破了根本焊不上锡，焊得很丑，emmm)\n实际上可以买个4PIN单排针焊上去，把串口接到排针上就可以，我直接把电线焊到上面以后用起来会很麻烦。\n刷机 以下部分基于Arch Linux，其他系统的操作方式可能不一样（例如Windows可能需要超级终端访问串口，再想办法开一个tftp服务器） 刷机的原理: 通过ttl串口线连接路由器的主板，让路由器访问电脑上的tftp服务器，刷第三方Boot Loader。\n首先电脑上装一个tftp服务器。 $ sudo pacman -S tftp-hpa $ sudo systemctl start tftpd.service tftp的默认目录为/srv/tftp。\n这里使用HackPascal制作的Breed（第三方Boot Loader），下载链接，把下载好的Breed重命名为breed.bin，复制到tftp的默认目录。\n$ cd /srv/tftp $ sudo cp ~/Downloads/breed-mt7620-xiaomi-r3g.bin breed.bin 路由器插网线连电脑，设置静态ip地址192.168.1.3/24，将串口和电脑连接，先不给路由器通电，通常情况下usb串口的设备名称为/dev/ttyUSB0，如果不确定的话可以dmesg查一下。\n使用screen连接串口，波特率为115200。\n$ sudo pacman -S screen $ sudo screen /dev/ttyUSB0 115200 路由器通电，终端上会显示路由器启动的信息，等几秒后在选择启动项的时候按9，通过TFTP加载Boot Loader。\n如果串口在连接到电脑的情况下主板通电时没有响应，那就断开usb串口先给主板通电后再连接串口。 (我语文不好别骂我) 如果路由器没有变砖可以正常启动（蓝灯长亮），在正常开机过程中不能选择启动项。此时可以尝试在路由器开机后长按reset按钮7s以上直到主板重启，便可以选择启动项。\nPlease choose the operation: 1: Load system code to SDRAM via TFTP. 2: Load system code then write to Flash via TFTP. 3: Boot system code via Flash (default). 4: Entr boot command line interface. 7: Load Boot Loader code then write to Flash via Serial. 9: Load Boot Loader code then write to Flash via TFTP. You choosed 9 9: System Load Boot Loader then write to Flash via TFTP. Warning!! Erase Boot Loader in Flash then burn new one. Are you sure?(Y/N)y 之后设置路由器主机地址（192.168.1.1）和TFTP服务器地址(192.168.1.3)以及文件名称(breed.bin)。\nPlease Input new ones /or Ctrl-C to discard Input device IP (192.168.31.1) ==:192.168.1.1 Input server IP (192.168.31.3) ==:192.168.1.3 Input Uboot filename (uboot.bin) ==:breed.bin 按回车后开始刷机，过几秒钟后路由器会自动重启，第三方Boot Loader刷写完成。\n路由器断电，长按reset键的同时通电开机，灯闪烁后打开浏览器输入网址http://192.168.1.1便可访问breed后台。\nDone 第三方Breed刷完后，先用Breed刷小米官方的开发版固件，开启ssh，之后按照小米路由器3G折腾之刷OpenWrt记录这篇文章刷OpenWrt。\nBusyBox v1.19.4 (2018-10-29 07:52:03 UTC) built-in shell (ash) Enter \u0026#39;help\u0026#39; for a list of built-in commands. ----------------------------------------------------- Welcome to XiaoQiang! ----------------------------------------------------- $$$$$$\\ $$$$$$$\\ $$$$$$$$\\ $$\\ $$\\ $$$$$$\\ $$\\ $$\\ $$ __$$\\ $$ __$$\\ $$ _____| $$ | $$ | $$ __$$\\ $$ | $$ | $$ / $$ |$$ | $$ |$$ | $$ | $$ | $$ / $$ |$$ |$$ / $$$$$$$$ |$$$$$$$ |$$$$$\\ $$ | $$ | $$ | $$ |$$$$$ / $$ __$$ |$$ __$$\u0026lt; $$ __| $$ | $$ | $$ | $$ |$$ $$\u0026lt; $$ | $$ |$$ | $$ |$$ | $$ | $$ | $$ | $$ |$$ |\\$$\\ $$ | $$ |$$ | $$ |$$$$$$$$\\ $$$$$$$$$ | $$$$$$ |$$ | \\$$\\ \\__| \\__|\\__| \\__|\\________| \\_________/ \\______/ \\__| \\__| root@XiaoQiang:~# ","permalink":"https://blog.starry-s.moe/posts/2021/xiaomi-r3g-ttl-flash/","summary":"\u003cp\u003e本来路由器闲置了一年了都没咋用了，前两天想把OpenWrt系统刷回原厂系统。\u003c/p\u003e\n\u003cp\u003e然鹅刷原厂固件时忘记改环境变量了，因为第三方Boot Loader也被我顺带刷回了原厂的所以现在开机无限重启。\u003c/p\u003e\n\u003cp\u003e之前买单片机套件时赠了一条usb转ttl线的，但是被我放学校了。只好再从万能的某宝再买一条线，尝试着救砖了。\u003c/p\u003e\n\u003cp\u003e(在某宝发现了一家店啥元件都有，还特别便宜。于是我还顺带买了很多杜邦线、电阻、LED灯、面包板等小玩意\u0026hellip;)\u003c/p\u003e","title":"小米路由器3G之使用TTL串口刷机救砖"},{"content":"前天在狗东买了台27寸4K显示器，型号为优派VX2771-4K-HD，分辨率3840x2160，支持HDR 10bit色深（然而电脑只支持DP1.2），因为之前已经配置好了optimus-manager，所以电脑接上显示器就能亮，很幸运没有遇到物理问题。\n然后一看4K屏上的字小得瞎眼。\n如果设置分辨率为1080P，显示文字时会特别糊，根本没法看，效果还没有1080P显示器好。\n解决方法 首先按照Wiki设置GNOME的HIDPI:\n$ gsettings set org.gnome.settings-daemon.plugins.xsettings overrides \u0026#34;[{\u0026#39;Gdk/WindowScalingFactor\u0026#39;, \u0026lt;2\u0026gt;}]\u0026#34; $ gsettings set org.gnome.desktop.interface scaling-factor 2 在显示设置里将缩放调到200%后，界面被放大了2倍，在4K屏上的字倒是不瞎眼了。\n但是因为笔记本是15寸1080P，所以笔记本上显示的字大得离谱。\n解决方法是使用xrandr调整笔记本电脑的屏幕缩放，笔记本的分辨率为1920x1080，使用xrandr将画面的分辨率放大2倍，也就是调整为3840x2160，然后显示在分辨率为1920x1080的显示器上。\n首先使用xrandr查看每个显示器所对应的设备名称和分辨率。\n$ xrandr | grep \u0026#34;$extern connected\u0026#34; HDMI-0 connected primary 3840x2160+0+0 (normal left inverted right x axis y axis) 597mm x 336mm eDP-1-1 connected 1920x1080+0+2160 (normal left inverted right x axis y axis) 344mm x 193mm 这里HDMI-0是外接的4K显示器，分辨率为3840x2160，位置为(0, 0)。\neDP-1-1是笔记本的显示器，分辨率1920x1080，位置为(0, 2160)，在4K显示器的左下方。\n参见Wiki设置双显示器部分，用xrandr将笔记本的显示器缩放2倍，分辨率变为 [1920 * 2]x[1080 * 2]=3840x2160，位置还是在4K显示器的正下方。\n$ xrandr --output eDP-1-1 --scale 2.0x2.0 --panning 3840x2160+0+2160 --output HDMI-0 --auto 因为不需要修改4K显示器的分辨率，所以HDMI-0设置为auto。\n这样笔记本上的画面也显示正常了。\n但是用过一阵子会发现笔记本显示器上的字比4K显示器上的字小很多，看起来不方便，所以把缩放倍数改为1.6（我是从1.5-2.0之间一点点试的，才找到最适合自己的缩放倍数），这样解决了字体大小的问题，不过笔记本画面还是会有模糊（能接受）。\n[1920 * 1.6]x[1080 * 1.6]=3072x1728\n$ xrandr --output eDP-1-1 --scale 1.6x1.6 --panning 3072x1728+0+2160 --output HDMI-0 --auto 用到现在GNOME的缩放还算是完美，除了玩Minecraft用的HMCL启动器（Java程序）没有被放大之外~~（貌似缺配置，要是配置好了我再补充）~~，Steam界面缩放正常，饥荒、Dota2也都没问题。\nJava8不支持Hidpi缩放，如果想让HMCL支持缩放需要需要安装Java9以上的版本，所以还是算了，又不是不能用。 网易云音乐缩放方法参考这篇博客。 qt5设置环境变量QT_SCREEN_SCALE_FACTORS=2。\nOthers 仅限GNOME，因为我只用GNOME所以不知道其他DE开HIDPI的效果是什么样。\n听说Wayland支持不同显示器设置不同的缩放倍数，但是我笔记本的HDMI是独显输出，自带屏幕为集显输出，想启用独显输出画面除了用大黄蜂之外只能Nvidia Optimus，然而Optimus不支持Wayland（F**K NVIDIA）， 于是我现在都不知道用Wayland上双显示器的效果是什么样子，只好改用xorg和optimus-manager切换显卡，再用xrandr调显示器的缩放倍数。\n或者买一根type-c转DP的线连显示器，我电脑的type-c支持DP1.2，可以输出4K60fps，而且走集显输出。\nxrandr的指令是我自己试了很多遍试出来的，在我电脑上能用，期间遇到一堆问题(BadMatch)，没想好什么解决方法，所以在别的电脑上可能需要一些修改。\n如果你正考虑为你的笔记本购买一台新显示器而且你是Linux用户，你的笔记本又是双显卡，不知道HDMI是独显输出还是集显输出的话，建议你买一台和笔记本电脑的分辨率相同的显示器(或者2K)，这样能省去很多麻烦。\n用了几个月后经常遇到显示器通过HDMI连接到电脑但是没有视频输出的情况，所以现在改用的是type-c转DP的连接线，走集成显卡输出，就没有遇到过这个问题。\n","permalink":"https://blog.starry-s.moe/posts/2021/laptop-dualscreen-hidpi-scale/","summary":"\u003cp\u003e前天在狗东买了台27寸4K显示器，型号为优派VX2771-4K-HD，分辨率3840x2160，支持HDR 10bit色深（然而电脑只支持DP1.2），因为之前已经\u003ca href=\"/posts/2021/archlinux-pavilion-gaming-laptop/\"\u003e配置好了optimus-manager\u003c/a\u003e，所以电脑接上显示器就能亮，很幸运没有遇到物理问题。\u003c/p\u003e\n\u003cp\u003e然后一看4K屏上的字小得瞎眼。\u003c/p\u003e\n\u003cp\u003e如果设置分辨率为1080P，显示文字时会特别糊，根本没法看，效果还没有1080P显示器好。\u003c/p\u003e","title":"解决笔记本外接HIDPI显示器的缩放问题"},{"content":"赶在期中考试(骑磨烤柿)前把单片机的课后习题整理出来\u0026hellip;\n(实在是没什么可拿来更新博客的了, 就干脆写点复习资料吧\u0026hellip;)\n本篇内容为作者整理资料所得, 仅供学习使用。如需转载请务必遵循CC BY-NC-ND 4.0协议。 请勿将本篇内容作为权威的教学辅导资料使用, 因无法保证100%准确, 仅供参考。\n如果发现了本篇存在的错误, 欢迎在页面下方提issue指正。\n本篇文章使用MathJax显示数学公式，在使用RSS阅读器时会出现无法正确显示的情况。\n硬件结构\u0026amp;指令系统 8051复位后从地址0000H开始执行程序, SP的值为07H。\nPC: 两字节(16位)寄存器, 也称程序计数器。\nSP: 堆栈指针, 指示出堆栈顶部在内部RAM块中的位置。\n单片机的堆栈设在了内部RAM区, 单片机复位后, SP中的内容为07H(指向第0组工作寄存器的R7), 堆栈实际上从08H开始。\n若SP被初始化为39H, 则堆栈实际上是从3AH开始的。\n执行LCALL addr16指令时，单片机先将PC的低字节压栈，再将PC的高字节压栈，最后把转移地址送入PC中。\n与之类似的LJMP类无条件转移指令，单片机只修改PC的值，并不堆栈保存跳转前的PC中保存的地址。\n执行RET指令后, SP值减2 (因为PC为2字节寄存器), 进行两次出栈操作，第一次出栈送PC的高位，第二次出栈送PC的低位。\n中断服务程序结束指令RETI不仅将堆栈中保存的2字节地址分别送入PC的高位和低位中，而且复位中断系统。因此RET和RETI不同。\nRET和RETI对堆栈的操作是相同的。\nPSW中的RS1 RS0=10B时, R2的RAM地址为12H。\nPSW： 程序状态字寄存器, 从PSW.7至PSW.0分别为Cy(进位标志位), Ac(辅助进位标志位), F0(标志位), RS1和RS0(寄存器区选择控制位), OV(溢出位), 保留位, P(奇偶标志位, 奇数为1, 偶数为0)。\nD7 D6 D5 D4 D3 D2 D1 D0 PSW Cy Ac F0 RS1 RS0 OV P RS1 RS0 = 10B时, 使用第二组工作寄存器区, 第0组工作寄存器区R0-R7的地址为00H-07H, 第1组为08H-0FH, 第2组为10H-17H, 第3组为18H-1FH(每组长度为8个字节, 每个寄存器占1个字节)。\n因此, 当A为01110010B时, PSW中P为0(偶数个1)。\nINC A指令不改变PSW中的Cy，只有可能改变奇偶标志位P。\n假设PSW为18H, 即00011000B, 此时使用第3组工作寄存器, R0地址为18H, R7地址为1FH。\n复位后, 默认选择的寄存器区是0区。\n8051片外数据存储器的寻址空间为0000H~0FFFFH\n位地址07H位于字节地址20H, 位地址7FH位于字节地址2FH。\n片内RAM中20H~2FH这16个单元即可进行共128位的位寻址, 也可进行字节寻址。\n字节地址及其位地址见下表所示：\n字节地址 D7 D6 D5 D4 D3 D2 D1 D0 2FH 7FH 7EH 7DH 7CH 7BH 7AH 79H 78H 2EH 77H 76H 75H 74H 73H 72H 71H 70H 2DH 6FH 6EH 6DH 6CH 6BH 6AH 69H 68H \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; 21H 0FH 0EH 0DH 0CH 0BH 0AH 09H 08H 20H 07H 06H 05H 04H 03H 02H 01H 00H 因此00H~07H位于字节地址20H, 78H-7FH位于字节地址2FH。\n除此之外，一些特殊功能寄存器（SFR）可进行位寻址（字节地址能够被8整除），SFR中位地址有83个（共有88个，5个未用），能够位寻址的SFR的字节地址末位均为0H或8H。\n访问外部存储器时, P0口用来传输低8位地址和数据, P2口用来传送高8位地址。\n访问外部存储器时, ALE的输出用于锁存低8位地址。\n一个机器周期为12个震荡周期\n为保证读入数据正确, 在读一个端口引脚之前应先向相应的端口锁存器写1。\n如果在读一个端口引脚之前向对应的输出锁存器写了0, 将总是读到0。\n8051访问片外存储器时, 利用ALE信号锁存来自P0的低8位地址信号。\n只能用直接寻址方式访问特殊功能寄存器。\n如果为8052单片机, 在访问高128字节的RAM时, 只能用间接寻址方式寻址。\n访问片外数据存储器64Kbyte时, 使用DPTR做间接寻址寄存器。\n使用MOVX @DPTR类指令访问外部扩展存储器时, P2口输出高8位地址, P0口传送低8位地址和数据。\n8051中, PC和DPTR都用于提供地址时, PC是用户程序不可访问的, DPTR可以分为两个8位寄存器DPH和DPL使用。\n累加器A的值为30H, 指令MOVC A, @A+PC位于地址3000H。执行该指令时, 程序存储器地址3031H的内容被传送至累加器A。\n指令MOVC A, @A+PC长度为1字节, 位于地址3000H, 因此PC值为3001H, 故A+PC为3031H。\n设SP的值为5FH, 指令LCALL DELAY所在地址为2030H, 子程序DELAY所在地址为20A0H, 则该指令完成的操作是将地址2033H压入堆栈保存, 将地址20A0H送入PC, SP的值应在该指令执行结束后变成61H。 单片机执行子程序或中断服务程序时, 需要保护现场, 即将PC当前的值压栈保存, 当子程序或中断服务程序运行结束后再进行出栈。(所以如果子程序修改了栈的内容, 在子程序运行结束后程序有可能会运行错误)。\nPC是16字节寄存器, 所以SP需要加2, 以此分别保存PC的高、低8位的数据。\nLCALL addr16这条指令占3字节, 其中addr16占两字节, 因此程序可跳转64KB范围内的地址。\n(ACALL指令只能跳转当前所在的2K范围内的地址, 如果不涉及到片外数据存储器的话, 通常只用SJMP和AJMP)\n在网上搜到的答案「将3500H送入PC」是错误的, 实际是将20A0H送入PC, 因为DELAY所在的地址为20A0H, 和3500H一点关系都没有。\nMOVC访问 程序(ROM) 存储器, MOVX指令访问 外部数据 存储器。 MOVC为查表指令, 只有MOVC @A+PC和MOVC @A+DPTR这两条, 均为单字节指令。\nMOVX用于累加器A与外部数据存储器进行传送。\n可以是MOVX A, @DPTR, MOVX A, @Ri, MOVX @DPTR, A, MOVX @Ri, A，其中i为0或1.\n当使用MOVX @Ri类指令时，只有P0口用来传送地址和数据，P2口的状态不会发生改变，因此可使用MOV P2, #12H指令设定高8位的地址。\n当采用Ri作间接寻址时, 只能寻找片外256个单元的数据存储器, 此时8位地址和数据均由P0口传送，P2口的状态不发生改变。\n假设指令DJNZ R7, rel位于005FH, 如果在执行该指令前寄存器R7值为00H, 偏移量rel为02H, 则该指令执行后下一条要执行的指令所在的地址是005FH。 DJNZ R7, rel位于005FH, 该指令长度为2字节 (书上写的3字节是错的), 所以在执行这条指令开始时PC值在原来的基础上 + 2 变为0061H。又因为rel为02H, 所以执行这条指令后, PC值变为0063H。\n分析下面子程序的功能, 假设8051单片机的震荡频率为6MHz。 DL: MOV R7, #0AH L0: MOV R6, #250 L1: NOP NOP DJNZ R6, L1 DJNZ R7, L0 RET R7为10, R6为250, 因此两个NOP加上一个DJNZ一共循环了250次, 该250次的循环一共执行了10次。\nNOP为1周期指令, DJNZ为2周期指令, 两个NOP加一个DJNZ共4周期。\n6MHz下一个机器周期为\\(12 \\div (6 \\times 10^6)= 2{\\mu}s\\), 12MHz下一个机器周期为1微秒。\n故程序该子程序延时了\\((4 \\times 250 \\times 10 \\times 12) \\div (6 \\times 10^6) = 20(ms)\\)\n(实际上有10次MOV R6, #250和10次DJNZ R7, L0造成的30个机器周期的约0.6ms的误差)\n以下部分写于2020年11月25日\n汇编语言程序 编写一个子程序, 将内部RAM 40H~4FH的内容复制到50H~5FH。\nCOPY: MOV R0, #40H MOV R1, #50H MOV R2, #10H ; 40H~4FH一共复制了16次 LOOP: MOV A, @R0 MOV @R1, A INC R0 INC R1 DJNZ R2, LOOP RET 因为没有MOV @RX, @RX这条指令, 所以用A做数据的中转站。\n将任何无符号8位二进制数转换为BCD码的子程序, 入口参数为内部RAM单元20H, 出口参数为内部RAM单元30H和31H, 30H存放百位数, 31H存放十位数和个位数。\nCV: MOV R0, #20H MOV A, @R0 MOV B, #100 DIV AB; A除以100, 得到的百位数存在A中 MOV 30H, A MOV A, B MOV B, #10 DIV AB SWAP A ADD A, B; 也可以用ORL MOV 31H, A RET DIV AB和MUL AB的A和B之间没有逗号。\n内部RAM 30H单元存放两位十进制数 (压缩BCD码), 编写将该十进制数转换为对应ASCII码的子程序, 转换结果存放到内部RAM 40H (十位数) 和41H (个位数) 单元。\nASCII码： 30H为0, 41H为A, 61H为a\nCV: MOV A, 30H ANL A, #0FH MOV DPTR, #DATA; 或者直接用ADD A, #30H即可 MOVC A, @A+DPTR MOV 41H, A MOV A, 30H SWAP A ANL A, #0FH MOVC A, @A+DPTR MOV 40H, A RET DATA: DB 30H, 31H, 32H, 33H, 34H, 35H, 36H, 37H, 38H, 39H 8个8位数相加, 求平均值, 入口地址为30H~37H, 结果存到40H。\n把8位数相加存在溢出, 所以把相加结果以16进制存到R2、R3中, 再除以8( 右移3次), 即可求得不四舍五入的平均值。\nMOV R0, #30H MOV R1, #08H MOV R2, #00H MOV R3, #00H ; 初始化 LOOP: CLR C MOV A, @R0 ADD A, R3 MOV R3, A JNC SKIP INC R2 SKIP: INC R0 DJNZ R1, LOOP 这样结果被保存到R2、R3中, 然后需要写一个循环右移3位的程序。\nMOV R4, #03H LOOP2: RRC R2 RRC R3 DJNZ R4, LOOP2 MOV 40H, R3 ; 右移3次后R2的低4位为0, 结果保存在R3中 这样R3中求得的是不带四舍五入的结果。\n如果需要带四舍五入的话第一种方法是判断最后一次右移时最低位是否为\\(1\\)，\\((1 / 2 = 0.5)\\)。\nMOV R4, #03H LOOP2: RRC R2 RRC R3 DJNZ R4, LOOP2 JNC SKIP2 INC R3 SKIP2: MOV 40H, R3 ; 右移3次后R2肯定为0 这样是带四舍五入的结果。\n第二种方法，8个8位数相加求平均值，要求四舍五入的话，只需要在这8个数求和后再加4（0100B），之后右移3次。\nADD A, #04H MOV R3, A JNC SKIP2 INC R2 SKIP2: MOV R4, #03H LOOP2: RRC R2 RRC R3 DJNZ R4, LOOP2 结果保存在R3中。\n中断系统 8051的外部中断有低电平触发和下降沿触发两种触发方式。外部中断1的中断向量地址是0013H。\n在响应中断时, 单片机自动生成一条长调用指令LCALL addr16, 其地址为中断入口地址。\n中断源 入口地址 INT0 0003H T0 000BH INT1 0013H T1 001BH 串行口 0023H 通常在中断入口地址处放一条无条件转移指令*JMP。\n内部查询顺序同入口地址的顺序，由高到低。\n执行指令MOV IP, #0BH( #00001011B)后, 中断优先级最高者为PX0, 最低为PS。\nIP: 中断优先级寄存器, 其前3为无意义, 后5位( IP.4至IP.0)为：PS, PT1, PX1, PT0, PX0, 分别对应串行口、定时器T1、外部中断1、定时器0、外部中断0。\nD7 D6 D5 D4 D3 D2 D1 D0 IP PS PT1 PX1 PT0 PX0 单片机复位以后, IP的内容为0, 各个中断源均为低优先级中断。\n在同时收到几个同一优先级的中断请求时, 中断响应取决于内部查询顺序, 其顺序由高到低为：INT0、T0、INT1、T1、串行口。\n当中断源均为同一优先级时, 当它们同时申请中断时CPU首先响应外部中断0\n8051的晶振频率为12MHz, 则最短的外部中断响应时间为3\\(\\mu\\)s, 最长的外部中断响应时间为12\\(\\mu\\)。\n中断标记位于单片机寄存器的TCON和SCON中。\nD7 D6 D5 D4 D3 D2 D1 D0 TCON TF1 TR1 TF0 TR0 IE1 IT1 IE0 IT0 SCON SM0 SM1 SM2 REN TB8 RB8 TI RI TCON中TF1和TF0为定时器/计数器中断标志位, TR1和TR0为定时/计数启动位, IE1和IE0为外部中断标志位, IT1和IT0为选择外部中断为边沿触发(1)还是电平触发(0)方式。\nSCON中前几位与串行口有关，第1位和第2位的TI和RI(是大写字母I不是数字1)分别为串行口中断发送中断请求标志位(发送成功后置1)和接受中断请求标志位( 接受成功后置1)。串口中断无法硬件清零, 只能软件清零。\n当IE中EA为1、ES为1时，TI或RI为1时，CPU执行无条件转移指令LJMP 0023H, 执行串行口中断服务程序。\n要使8051能够响应定时器T1的中断和串行口中断, 不响应其他中断, 则中断允许寄存器IE的内容为98H(10011000B)。\n中断允许寄存器IE：\nD7 D6 D5 D4 D3 D2 D1 D0 IE EA ES ET1 EX1 ET0 EX0 EA为总控制位, 当EA为1时, CPU才可以响应中断请求。\nES为串行口中断允许位, ET1和ET0为定时器中断允许位, EX1和EX0为外部中断允许位。\n定时器和计数器 使T0工作方式1的溢出周期最长的初值是0000H。\n定时器/计数器工作在方式0为13位计数器, 由TLX的低5位和THX的高8位组成13位计数器, 最大值为\\(2^{13}-1 = 8191\\), 晶振频率12MHz下计时周期最长为8.192ms。工作在方式1时由均为8位的TLX和THX组成16位计数器, 最大值为65535, 晶振频率为12M下最长为65.536ms。\n当定时器/计数器工作在方式2时, 可以循环定时/计数。当计数溢出后, 自动将8位的THX装入8位的TLX中, 可省去重装初值的时间, 最大值为255, 晶振频率12M下计时周期最长为0.256ms。\nT1配置为方式3时, 停止计数, 方式3只适用于定时器0。\n定时器T0的方式3将其分为两个8位定时器, 其中TH0只能做定时器使用。\n设8051单片机的晶振频率为12MHz, 定时器作计数器使用时, 其计数输入信号的最高频率为500KHz。\n当定时器用作计数器时, 当检测到引脚上的负跳变时计数器的值增一。检测下降沿需要2个机器周期, 即24个震荡周期, 所以输入信号最高频率为 \\(12M \\div 24 = 500KHz\\)。\n用定时器方式2扩展一个下降沿触发的外部中断, 计数初值应为FFH。\n此处定时器2以计数器方式运行, 当检测到一个下降沿后, 计数器加一后溢出, 因此会执行定时器中断的中断子程序。\n2020年12月3日： 前两天感冒, 休息了几天(打了两天的游戏)后继续。\n串行口 串行口TXD为高电平, 表示这是数据位或停止位或空闲状态。\n串行口工作在方式1时, TXD用来发送数据、RXD用来接受数据。方式1的一帧数据为10位, 起始为为0, 停止位为1, 数据位和空闲状态均可能为0或1。\n串行口工作在方式3时, 发送的第9位数据要事先写入寄存器SCON的TB8, 接收的第9位数据被写入同一寄存器的RB8。\n串行口控制寄存器SCON：\nD7 D6 D5 D4 D3 D2 D1 D0 SCON SM0 SM1 SM2 REN TB8 RB8 TI RI 其中SM0、SM1为串口的工作方式选择位, 方式0为同步移位寄存器方式, 方式1为8位异步收发, 方式2和方式3为9位异步收发。\n波特率：串行口每秒钟传送的比特位数，单位bits/s。\n方式0的波特率固定为 \\(f_{osc}/12\\), 方式2的波特率为 \\(f_{osc}/64\\) 或 \\(f_{osc}/32\\) (由SMOD控制)。\n方式1的波特率和方式3的波特率可变, 公式为 \\((2^{SMOD} / 32) \\times 定时器T1的溢出率\\)。\nT1的溢出率为定时器T1的周期的倒数，定时器的周期为\n$$T = \\frac{12\\times (2^n - X )}{f\\_{osc}}$$ 当T1工作在方式2时，n为8，波特率为：\n$$波特率=\\frac{(2^{SMOD} \\div 32) \\times f_{osc}}{12 \\times (256 - X)}$$ \\(X\\)为定时器T1的初值。\n串口工作在方式1，波特率为2400，则每秒钟最大能发送/接收 \\(2400 \\div 10 = 240Byte\\) 的数据。\n单片机工作在方式1时, 1帧数据为1个起始位、8个数据位、1个停止位共10位。\n8051的UART工作在方式3，要求每秒钟能传送不少于900个字节的数据，则波特率应当大于 \\(900 \\times 8 = 7200bits/s\\)。\n比特率2400Kbits/s，时钟频率12M，PC机发送8个字节的数据存到单片机的30H-37H中，随后单片机发送2个确认字节55H和AAH给PC机，使用查询方式。\nORG 0000H MAIN: MOV SCON, #50H ; 串口使用方式1，且允许接收 MOV PCON, #00H ; 波特率不加倍 MOV TMOD, #20H ; 定时器1使用方式2 MOV TL1, #0F3H MOV TH1, #0F3H SETB TR1 LOOP: MOV R0, #30H MOV R1, #08H REC: JNB RI, $ MOV @R0, SBUF CLR RI ; 软件清零RI INC R0 DJNZ R1, REC MOV SBUF, #55H JNB TI, $ CLR TI MOV SBUF, #0AAH JNB TI, $ CLR TI AJMP LOOP END 单片机接收到数据后，RI被置1，代表SBUF中的数据有效，取走SBUF中的数据后需要软件清零RI（串口中断不会自动清零RI）。\n当单片机执行写SBUF操作时，串口发送开始，TI被自动置1，在发送完成后TI被自动清0。\n2020年12月7日：\nI/O口 \u0026amp; 外部存储器拓展 8051使用指令MOVX A, @R0读外部数据存储器时，不起作用的信号是WR。\n8051在使用MOVX @DPTR类指令读外部数据存储器时，P0和P2先输出外部数据的地址，单片机发出的ALE信号的负跳沿将P0口输出的地址锁存在地址锁存器(74HC573)里，之后单片机发出RD信号，读取外部数据存储器（RAM）的数据到总线再传送到P0口上。最后单片机从P0口读取数据保存到A中。\n如果是写外部数据存储器时，单片机将不发出RD信号而是WR信号，将A中的数据写入外部数据存储器中。\n存储器芯片6264需要13根地址线。\n62256的容量为 \\(256Kbit \\div 8 = 32KB = 2^{15}\\), 需要15根地址线。\n6264的容量为 \\(64Kbit \\div 8 = 8KB = 2^{13}\\)，所以需要13根地址线。\n6116容量为 \\(16Kbit \\div 8 = 2KB = 2^{11}\\), 需要11根地址线。\n计算方法是62 \\(X\\) 的 \\(容量=X \\div 8(K)\\)。\n使用16位地址模式时，8051的外部数据存储器寻址空间为64KB。\n基于8051的单片机系统能拓展的外部数据存储器容量无限制。\n有的书上说最大只能拓展64KB，实际是最大寻址空间为64KB，拓展的外部数据存储器容量无限制。\n8051的程序存储器可用来存放用户程序和数据。 例如使用DW或DB指令用来定义数据。\n所以应用程序也可以使用MOVC A, @A+DPTR访问程序存储器中的数据。\n除此之外LED数码管和外部存储器拓展、外部I/O设备拓展部分有很多需要根据线路图计算地址和DA转换的题，因为线路图源自老师提供的PDF，而老师为PDF加了密码，意味着不允许外传，所以我就不放到博客上面了，除非我自己用Porteus画一个类似的\nLED段码入口地址8004H，位选入口地址8002H，将30H-32H保存的6个压缩BCD码发送到6位共阴极数码管上显示， 要求编写延时1ms的子程序。\nMAIN: MOV R0, #30H ; R2用来计数 MOV R2, #03H ; R3用来位选 MOV R3, #01H LOOP: MOV A, @R0 SWAP A ANL A, #0FH MOV DPTR, #TAB MOVC A, @A+DPTR ; 取高4位BCD码对应的段码 MOV DPTR, #8004H MOVX A, @A+DPTR ; 先送段码 MOV A, R3 MOV DPTR, #8002H MOVX @DPTR, A RL A MOV R3, A ; 再送位选 LCALL DELAY MOV A, @R0 ANL A, #0FH MOV DPTR, #TAB MOVC A, @A+DPTR ; 取低4位BCD码对应的段码 MOV DPTR, #8004H MOVX A, @A+DPTR ; 送段码 MOV A, R3 MOV DPTR, #8002H MOVX @DPTR, A RL A MOV R3, A ; 送位选 LCALL DELAY INC R0 DJNZ R2, LOOP DELAY: MOV R7, #250 DL: NOP NOP DJNZ R7, DL RET TAB: DB 3FH, 06H, 5BH, 4FH, 66H, 6DH, 7DH, 07H, 7FH, 6FH END 打印机数据输入接口和P1直接相连，STB接口和P3.4相连，BUSY接口和P3.3相连，不使用ACK应答信号，编写将外部存储器1000H-100FH的数据发送到打印机打印的子程序。\nPRINT: MOV DPTR, #1000H MOV R2, #10H LOOP: JB P3.3, $ ; 确保打印机处于空闲状态 MOVX A, @DPTR MOV P1, A CLR P3.4 SETB P3.4 INC DPTR DJNZ R2, LOOP RET 如果打印机没有和P1直接相连，而是连接到数据锁存器上（74HC374），锁存器的时钟信号的入口地址为A000H。\n使用堆栈保护间接寻址寄存器的值。\nPRINT: MOV R2, #10H MOV DPTR, #1000H LOOP: JB P3.3, $ ; 确保打印机处于空闲状态 MOVX A, @DPTR PUSH DPL PUSH DPH MOV DPTR, #0A000H MOVX @DPTR, A POP DPH POP DPL CLR P3.4 SETB P3.4 INC DPTR DJNZ R2, LOOP RET SFR列表 87H D7 D6 D5 D4 D3 D2 D1 D0 PCON SMOD - - - - - PD IDL 88H D7 D6 D5 D4 D3 D2 D1 D0 TCON TF1 TR1 TF0 TR0 IE1 IT1 IE0 IT0 89H D7 D6 D5 D4 D3 D2 D1 D0 TMOD GATE C/T M1 M0 GATE C/T M1 M0 98H D7 D6 D5 D4 D3 D2 D1 D0 SCON SM0 SM1 SM2 REN TB8 RB8 TI RI A8H D7 D6 D5 D4 D3 D2 D1 D0 IE EA - - ES ET1 EX1 ET0 EX0 B8H D7 D6 D5 D4 D3 D2 D1 D0 IP - - - PS PT1 PX1 PT0 PX0 D0H D7 D6 D5 D4 D3 D2 D1 D0 PSW Cy Ac F0 RS1 RS0 OV - P ","permalink":"https://blog.starry-s.moe/posts/2020/learn-mcs8051/","summary":"\u003cp\u003e赶在\u003cdel\u003e期中考试\u003c/del\u003e(骑磨烤柿)前把单片机的课后习题整理出来\u0026hellip;\u003c/p\u003e\n\u003cp\u003e(实在是没什么可拿来更新博客的了, 就干脆写点复习资料吧\u0026hellip;)\u003c/p\u003e","title":"51单片机习题整理"},{"content":"自从高中毕业至今这台笔记本用了将近两年, 已经记不清当初为什么买了这台笔记本, 刚买来电脑第一次装Arch Linux时遇到了一些坑, 不过大多数的问题Google折腾一会或随着后续的软件更新基本上就都解决了, 唯独配置双显卡这个问题在用了两年后才算是找到了比较满意的解决方法（大概是）, 尽管现在这电脑已经停产了, 就算有人买了这台电脑也不一定会拿他装Arch Linux, 不过我还是打算把这个问题的解决过程记录一下（本篇讲的方法应该是适用于大多数N卡+i卡的笔记本电脑的, 只是有些细节不一样）, 以备我后续重装系统时有个参考。\n先描述一下踩坑经过 本段略微有些废话, 可以跳过\n记得在刚买来这台笔记本（2018年夏）, Linux内核还没升到5.0的时候, 使用live CD装系统时会遇到lspci卡死, 关机的时候会卡死的问题, 查系统日记都是一堆ACPI的报错。当时网上查了一下大概是内核和驱动一些bug, 没找到解决办法, Google到论坛的帖子说是在关机/重启发生卡死时只能直接长按电源关机就（找不到搜的回答了）\n装完系统后安装显卡驱动时想通过Bumblebee + bbswitch切换双显卡, 于是装了Gnome然后照着wiki配置完Bumblebee和bbswitch后重启电脑直接死机。\n经过多次重装系统的折磨后, 发现只装Bumblebee不装bbswitch不systemctl enable bumblebeed.service时, 能正常开机, 然后之前遇到的两个问题也莫名其妙就好了, 即系统重启关机不会卡死, lspci也正常了（迷）\n之后, 在不装bbswitch的情况下, 启动bumblebeed.service再用optirun和primusrun这种方式用独显运行程序都没有问题。\n当时因为电脑不装Bumblebee的话就没法正常关机, 于是就一直用着Bumblebee切换双显卡, 玩游戏性能比Windows下差一点, 别的都没啥问题。\n今年年初买了一块拓展屏想搞双显示器, 本来显示器应该插上HDMI直接就能用的, 但是因为这电脑的HDMI走的独显输出, Bumblebee不能直接用, wiki上教的创建个intel的虚拟输出啥的方法有试过但是没成功, 于是又Google了一下后卸了Bumblebee改用NVIDIA Optimus 只使用独显的方式, 这样双显示器倒是能用了, 但是如果笔记本只用电池没连着拓展屏的时候还跑着独显这也太费电了。\n所以最后找到了能切换显卡的Optimus Manager。\n查了一下这款电脑的type-c接口支持DP1.2视频输出，和HDMI 2.0一样支持4K 60fps，走的是intel集成显卡，可以在独显不通电的时候输出画面到第三方显示器。所以买一根type-c转DP线就可以点亮第三方显示器（前提是你的显示器有DP接口），但是切换显卡还是得依靠Bunblebee或Optimus Manager这类的软件。\n安装过程 照着Wiki和Optimus Manager的README。首先安装好显卡驱动相关的软件, 如果有Bumblebee的话使用systemctl disable bumblebeed停用。\n首先清除（记得备份）/etc/X11/xorg.conf.d/下的配置文件, 并删掉（记得备份）/etc/X11/xorg.conf（如果有的话）, 因为Optimus Manager会自动生成配置文件存放到/etc/X11/xorg.conf.d/里面, 所以建议安装前把显示配置相关的文件都清除掉。\n使用Arch Linux CN源或者通过AUR Helper安装optimus-manager。\n# Arch Linux CN $ sudo pacman -S optimus-manager # AUR $ yay -S optimus-manager 因为我用的Gnome, 参照README中说的卸载掉gdm并安装gdm-primeAUR。（国内下载源代码的速度极慢建议挂梯子, 或者挂梯子克隆GDM的代码到~/.cache/yay/gdm-prime/gdm下。）\n修改/etc/gdm/custom.conf, 移除WaylandEnable=false一行前面的#禁用Wayland而使用X。\n修改配置文件 $ sudo cp /usr/share/optimus-manager.conf /etc/optimus-manager/optimus-manager.conf 不要编辑/usr/share/下的文件, 编辑/etc/optimus-manager/optimus-manager.conf, 将切换方式设为switching=none, 不推荐使用bbswitch（见后续第一条）, 设置pci_power_control=yes让PCI Power Management切换显卡。\n之后根据需求来修改开机自动选择显卡：\nstartup_mode=auto startup_auto_battery_mode=intel startup_auto_extpower_mode=nvidia 这里我设置的是用电池时使用集成显卡, 用电源时使用独显。\n最后贴一下全部的配置文件, 除了上述的几处修改以外其他均为默认值, 仅供参考。\n[optimus] # This parameter defines the method used to power switch the Nvidia card. See the documentation # for a complete description of what each value does. Possible values : # # - nouveau : load the nouveau module on the Nvidia card. # - bbswitch : power off the card using the bbswitch module (requires the bbswitch dependency). # - acpi_call : try various ACPI method calls to power the card on and off (requires the acpi_call dependency) # - custom: use custom scripts at /etc/optimus-manager/nvidia-enable.sh and /etc/optimus-manager/nvidia-disable.sh # - none : do not use an external module for power management. For some laptop models it\u0026#39;s preferable to # use this option in combination with pci_power_control (see below). switching=none # Enable PCI power management in Intel mode. # This option is incompatible with acpi_call and bbswitch, so it will be ignored in those cases. pci_power_control=yes # Remove the Nvidia card from the PCI bus. # May prevent crashes caused by power switching. # Ignored if switching=nouveau or switching=bbswitch. pci_remove=yes # Reset the Nvidia card at the PCI level before reloading the nvidia module. # Ensures the card is in a fresh state before reloading the nvidia module. # May fix some switching issues. Possible values : # # - no : does not perform any reset # - function_level : perform a light \u0026#34;function-level\u0026#34; reset # - hot_reset : perform a \u0026#34;hot reset\u0026#34; of the PCI bridge. ATTENTION : this method messes with the hardware # directly, please read the online documentation of optimus-manager before using it. # Also, it will perform a PCI remove even if pci_remove=no. # pci_reset=no # Automatically log out the current desktop session when switching GPUs. # This feature is currently supported for the following DE/WM : # KDE Plasma, GNOME, XFCE, LXDE, Deepin, i3, Openbox, AwesomeWM, bspwm # If this option is disabled or you use a different desktop environment, # GPU switching only becomes effective at the next graphical session login. auto_logout=yes # GPU mode to use at computer startup. Possible values: nvidia, intel, hybrid, auto # \u0026#34;auto\u0026#34; is a special mode that auto-detects if the computer is running on battery # and selects a proper GPU mode. See the other options below. startup_mode=auto # GPU mode to select when startup_mode=auto and the computer is running on battery. # Possible values: nvidia, intel, hybrid startup_auto_battery_mode=intel # GPU mode to select when startup_mode=auto and the computer is running on external power. # Possible values: nvidia, intel, hybrid startup_auto_extpower_mode=nvidia [intel] # Driver to use for the Intel GPU. Possible values : modesetting, intel # To use the intel driver, you need to install the package \u0026#34;xf86-video-intel\u0026#34;. driver=modesetting # Acceleration method (corresponds to AccelMethod in the Xorg configuration). # Only applies to the intel driver. # Possible values : sna, xna, uxa # Leave blank for the default (no option specified) accel= # Enable TearFree option in the Xorg configuration. # Only applies to the intel driver. # Possible values : yes, no # Leave blank for the default (no option specified) tearfree= # DRI version. Possible values : 2, 3 DRI=3 # Whether or not to enable modesetting for the nouveau driver. # Does not affect modesetting for the Intel GPU driver ! # This option only matters if you use nouveau as the switching backend. modeset=yes [nvidia] # Whether or not to enable modesetting. Required for PRIME Synchronization (which prevents tearing). modeset=yes # Whether or not to enable the NVreg_UsePageAttributeTable option in the Nvidia driver. # Recommended, can cause poor CPU performance otherwise. PAT=yes # DPI value. This will be set using the Xsetup script passed to your login manager. # It will run the command # xrandr --dpi \u0026lt;DPI\u0026gt; # Leave blank for the default (the above command will not be run). DPI=96 # If you\u0026#39;re running an updated version of xorg-server (let\u0026#39;s say to get PRIME Render offload enabled), # the nvidia driver may not load because of an ABI version mismatch. Setting this flag to \u0026#34;yes\u0026#34; # will allow the loading of the nvidia driver. ignore_abi=no # Set to yes if you want to use optimus-manager with external Nvidia GPUs (experimental) allow_external_gpus=no # Comma-separated list of Nvidia-specific options to apply. # Available options : # - overclocking : enable CoolBits in the Xorg configuration, which unlocks clocking options # in the Nvidia control panel. Note: does not work in hybrid mode. # - triple_buffer : enable triple buffering. options=overclocking 食用方法 optimus-manager --switch nvidia切换到独显（nvidia）\noptimus-manager --switch intel切换到集显（intel）\n安装mesa-demos后, 使用glxinfo | grep \u0026quot;OpenGL renderer\u0026quot;查看当前正使用的显卡\n其他用法参见Usage。\n注意：\n切换显卡的过程中会自动注销登录, 所以记得保存并关掉电脑正在运行的程序。\n你可以在配置文件中修改auto_logout=false禁止自动注销以手动注销切换显卡。\nOthers 之所以不推荐使用bbswitch是因为容易遇到ACPI锁死的问题, 参考Wiki, 需要添加内核参数acpi_osi=! acpi_osi=\u0026quot;Windows 2009\u0026quot;或acpi_osi=\u0026quot;!Windows 2015\u0026quot;启动, 如果你遇到了锁死可以通过开机时在启动加载器界面编辑添加内核参数来正常进入系统, 如果你用的是efistub或者没办法编辑内核参数的话就只能用live CD救你的电脑了。\n如果用不了lspci, 电脑没法正常关机的话, 是nouveau的问题, 可添加内核参数modprobe.blacklist=nouveau禁用。\n因为前几天改配置文件时又踩了一遍锁死的坑, 于是用最新的(2020.07.01)live CD救砖时, 惊喜的发现在live环境下lspci和关机都不会卡死了, 貌似是新版内核修复了这个bug\n在切换显卡自动注销后, gdm界面有时不会自动加载出来而是一直黑屏, 这时需要手动切换到tty2再切回tty1才能加载出来。\n如果显示器支持DDC/DI，可以参考Wiki使用命令调节显示器亮度。\n(本条与配置显卡无关) 因为电脑用的intel网卡, 如果遇到蓝牙耳机无法连接的情况, 安装pulseaudio和pulseaudio-modues-bt等耳机需要的蓝牙组件, 照着Wiki上的禁用Bluetooth coexistence解决此问题。\nneofetch\n","permalink":"https://blog.starry-s.moe/posts/2021/archlinux-pavilion-gaming-laptop/","summary":"\u003cp\u003e自从高中毕业至今这台笔记本用了将近两年, 已经记不清当初为什么买了这台笔记本, 刚买来电脑第一次装Arch Linux时遇到了一些坑, 不过大多数的问题Google折腾一会或随着后续的软件更新基本上就都解决了, 唯独配置双显卡这个问题在用了两年后才算是找到了比较满意的解决方法（大概是）, \u003cdel\u003e尽管现在这电脑已经停产了, 就算有人买了这台电脑也不一定会拿他装Arch Linux, 不过我还是打算把这个问题的解决过程记录一下\u003c/del\u003e（本篇讲的方法应该是适用于大多数N卡+i卡的笔记本电脑的, 只是有些细节不一样）, 以备我后续重装系统时有个参考。\u003c/p\u003e","title":"惠普光影精灵4在Arch Linux下使用Optimus Manager配置双显卡"},{"content":"刚买树莓派3B时就想弄一个我的世界服务器，但是那时不懂Linux，服务器也就没建成。这一阵子打算把这个计划再捡起来，和同学一起联机的话树莓派还是能做到的。ARM系列的CPU性能肯定比X86_64电脑的CPU弱许多，外加上树莓派1G的运行内存，让它跑大型服务器肯定是不可能的，所以只能弄一个几个人联机的小服务器了。\n本篇由于创作时间过于久远，部分下载链接可能失效，因长期未更新，教程仅供参考。\n终于可以继续更新博客了！原计划是11月之前更新博客的。不巧电脑出了问题，重装了一遍Arch Linux,后来又发生了一些事一直没能用电脑。由于开学到现在能放假供我写博客的时间少之又少，这篇原本在11月初就能发表的文章就这样被硬生生推迟到了11月末了。\n材料以及工具 树莓派一只 （包括所需要的C10的内存卡以及刷好的固件以及5v，2.5A充电器） 一个支持DDNS的路由器（非必须） 如果不想用树莓派建服务器的话也可以按照本教程在电脑上搭建服务器。\n配置树莓派 调整GPU可使用的内存： 毕竟用树莓派开服务器不需要占用GPU，直接调低。\nRaspbian: raspi-config中将GPU内存分为16M。\nArch Linux ARM: /boot/config.txt中更改GPU显存为16\n安装JAVA Archlinux ARM:\n$ sudo pacman -S jre8-openjdk 通用方法： 前往 JAVA下载页 下载树莓派（ARM架构，32位系统）所支持的JDK。\n$ mkdir ./java $ tar -zxvf 你所下载的JDK.jar.gz -C ./java/ 在终端输入./java/jdk1.8.0/bin/java -version显示java的版本号。\n部署服务器 本篇使用Paper MC部署服务器。 除了Paper之外还有Bukkit和Spigot以及原版可选。\n使用以下命令启动服务器。\n$ echo eula=True \u0026gt; eula.txt $ ./java/jdk*/bin/java -Xms512M -Xmx1024M -jar ./spigot.jar 第一次运行会下载一些文件需要一定的时间。\n网上有很多服务器插件和Mod什么的。本章中不做过多介绍.\n用screen 保持服务器一直运行而不被关掉。 首先安装好screen。\n$ screen $ ./java/jdk1.8.0/bin/java -Xms512M -Xmx1024M -jar./paperclip.jar 在配置好你的服务器后就可以和小伙伴一起联机了。经过测试几个人简单的联机运行蛮正常的。\n","permalink":"https://blog.starry-s.moe/posts/2016/raspberrypi-mc-server/","summary":"\u003cp\u003e刚买树莓派3B时就想弄一个我的世界服务器，但是那时不懂Linux，服务器也就没建成。这一阵子打算把这个计划再捡起来，和同学一起联机的话树莓派还是能做到的。ARM系列的CPU性能肯定比X86_64电脑的CPU弱许多，外加上树莓派1G的运行内存，让它跑大型服务器肯定是不可能的，所以只能弄一个几个人联机的小服务器了。\u003c/p\u003e","title":"树莓派之我的世界服务器"},{"content":"你好，世界！\nHello World\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } ","permalink":"https://blog.starry-s.moe/posts/2016/hello-world/","summary":"\u003cp\u003e你好，世界！\u003c/p\u003e","title":"Everything is based on “Hello World”"},{"content":" West Lake\n关于本站 博客最初建于 2016 年夏，目前使用 Hugo 生成静态页托管在 GitHub Pages。\n时间久远曾弄丢过好几个域名，现用域名为 starry-s.moe。\n关于咱 是一个野生的 Arch Linux 用户，喜欢 Linux，经常写代码，研究些有意思抽象难以用语言描述的东西。 空闲时间偶尔搞点摄影，照片可以在本站的 相册 页找到。\nPGP 密钥：E8F9 2E5A C1AE 0B0F 4421 4012 9190 2000 F0C2 9BC2 Email: starry@starry-s.moe GitHub: https://github.com/STARRY-S ","permalink":"https://blog.starry-s.moe/about/","summary":"West Lake 关于本站 博客最初建于 2016 年夏，目前使用 Hugo 生成静态页托管在 GitHub Pages。 时间久远曾弄丢过好几个域名，现用域名为 starry-s.moe。 关于","title":"About"},{"content":" Powered by hugo-shortcode-gallery.\n","permalink":"https://blog.starry-s.moe/gallery/","summary":"Powered by hugo-shortcode-gallery.","title":"相册"}]