[{"content":"稍微折腾一下容器网络相关的东西……\nLinux 网络命名空间 在熟悉容器网络之前，首先来看一下 Linux 网络命名空间 (Network Namespace) 这个东西。Linux 提供了多个不同种类的 Namespace，可以用 lsns 命令查看。\n$ lsns NS TYPE NPROCS PID USER COMMAND 4026531834 time 2 2251 starry-s -zsh 4026531835 cgroup 2 2251 starry-s -zsh 4026531836 pid 2 2251 starry-s -zsh 4026531837 user 2 2251 starry-s -zsh 4026531838 uts 2 2251 starry-s -zsh 4026531839 ipc 2 2251 starry-s -zsh 4026531840 net 2 2251 starry-s -zsh 4026531841 mnt 2 2251 starry-s -zsh ... 参考 network_namespace manpage，Network Namespace 是 Linux 实现网络资源隔离的功能，不同的 Network Namespace 拥有不同的网卡、ARP、路由表等数据。可以使用 iproute2 工具的 ip 命令对 Linux Network Namespace 执行一系列的操作。\n本篇介绍的指令不会系统产生损坏，但建议在虚拟机或一个用于测试的系统上执行 Network Namespace 相关操作，以便于执行重启等暴力操作。\n开始之前，先安装 net-tools 网络工具包。\n$ sudo pacman -S net-tools 查看设备中已有的 Network Namespace。\n$ ip netns list $ ip netns ls ip netns 命令会列出 /var/run/netns/ 目录下存在的 Network Namespace，如果之前没有使用 ip 命令创建过 netns，以上命令基本不会有输出（除非有别的工具也修改了这个目录）。首先创建两个 Network Namespace。\n$ sudo ip netns add ns0 $ sudo ip netns add ns1 $ sudo ip netns ls ns0 ns1 $ ls /var/run/netns/ ns0 ns1 每个 Network Namespace 拥有不同的网卡、路由表、ARP 表等信息，可以使用 ip -n [NAMESPACE] 对某个 netns 进行操作，或通过 ip netns exec 在不同的 netns 下执行命令。\n$ sudo ip -n ns0 link 1: lo: \u0026lt;LOOPBACK\u0026gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 $ sudo ip netns exec ns0 ip link 1: lo: \u0026lt;LOOPBACK\u0026gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 $ sudo ip netns exec ns0 route Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface $ sudo ip netns exec ns0 arp veth pair 连接 Network Namespace 新建的 netns 只有一个 DOWN 状态的回环接口，没有 ARP 和路由表信息，如果想在不同的 netns 之间通信，需要建立 veth pair（Virtual Cabel），把 netns 连接起来。\n可以使用 ip link add type veth 创建一对 veth pair，注意 veth pair 是成对出现的，可以在创建 veth pair 时指定这对 veth pair 名称。\n首先看一下系统自带的接口信息，默认情况下系统有一个 lo 回环接口和一个 eth0 (被重命名为 enp*s* 的接口)，如果运行了 Docker，还会有一个 docker0 接口。\n$ sudo ip link 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2: enp1s0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000 link/ether ab:cd:ef:89:8f:f5 brd ff:ff:ff:ff:ff:ff 3: docker0: \u0026lt;NO-CARRIER,BROADCAST,MULTICAST,UP\u0026gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default link/ether 02:42:b7:a9:6a:55 brd ff:ff:ff:ff:ff:ff 创建一对 veth pair 名为 veth0 和 veth1。\n$ sudo ip link add veth0 type veth peer name veth1 $ sudo ip link ...... 4: veth1@veth0: \u0026lt;BROADCAST,MULTICAST,M-DOWN\u0026gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether 5e:7a:4e:96:b1:df brd ff:ff:ff:ff:ff:ff 5: veth0@veth1: \u0026lt;BROADCAST,MULTICAST,M-DOWN\u0026gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether 5e:5b:51:12:d0:b6 brd ff:ff:ff:ff:ff:ff 之后使用 ip link set 将这对 veth pair 分配到不同的 netns 中。\n$ sudo ip link set veth0 netns ns0 $ sudo ip link set veth1 netns ns1 $ sudo ip -n ns0 link 1: lo: \u0026lt;LOOPBACK\u0026gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 5: veth0@if4: \u0026lt;BROADCAST,MULTICAST\u0026gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether 5e:5b:51:12:d0:b6 brd ff:ff:ff:ff:ff:ff link-netns ns1 $ sudo ip -n ns1 link 1: lo: \u0026lt;LOOPBACK\u0026gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 4: veth1@if5: \u0026lt;BROADCAST,MULTICAST\u0026gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether 5e:7a:4e:96:b1:df brd ff:ff:ff:ff:ff:ff link-netns ns0 使用 ip addr add 为 veth pair 接口创建 IP 地址，并使用 ip link set [INTERFACE] up 启动网卡接口。\n$ sudo ip -n ns0 addr add 10.0.0.100/24 dev veth0 $ sudo ip -n ns1 addr add 10.0.0.101/24 dev veth1 $ sudo ip -n ns0 link set veth0 up $ sudo ip -n ns1 link set veth1 up $ sudo ip -n ns0 addr 1: lo: \u0026lt;LOOPBACK\u0026gt; mtu 65536 qdisc noop state DOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 5: veth0@if4: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether 5e:5b:51:12:d0:b6 brd ff:ff:ff:ff:ff:ff link-netns ns1 inet 10.0.0.100/24 scope global veth0 valid_lft forever preferred_lft forever inet6 fe80::5c5b:51ff:fe12:d0b6/64 scope link proto kernel_ll valid_lft forever preferred_lft forever $ sudo ip -n ns1 addr 1: lo: \u0026lt;LOOPBACK\u0026gt; mtu 65536 qdisc noop state DOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 4: veth1@if5: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether 5e:7a:4e:96:b1:df brd ff:ff:ff:ff:ff:ff link-netns ns0 inet 10.0.0.101/24 scope global veth1 valid_lft forever preferred_lft forever inet6 fe80::5c7a:4eff:fe96:b1df/64 scope link proto kernel_ll valid_lft forever preferred_lft forever ip addr add 命令在添加 IP 地址时会自动创建路由表信息。现在两个 netns 之间可通过 veth pair 互相通信。\n$ sudo ip -n ns0 route 10.0.0.0/24 dev veth0 proto kernel scope link src 10.0.0.100 $ sudo ip -n ns1 route 10.0.0.0/24 dev veth1 proto kernel scope link src 10.0.0.101 $ sudo ip netns exec ns0 ping -c 1 10.0.0.101 PING 10.0.0.101 (10.0.0.101) 56(84) bytes of data. 64 bytes from 10.0.0.101: icmp_seq=1 ttl=64 time=0.051 ms --- 10.0.0.101 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.051/0.051/0.051/0.000 ms $ sudo ip netns exec ns1 ping -c 1 10.0.0.100 PING 10.0.0.100 (10.0.0.100) 56(84) bytes of data. 64 bytes from 10.0.0.100: icmp_seq=1 ttl=64 time=0.040 ms --- 10.0.0.100 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.040/0.040/0.040/0.000 ms 到这里，ns0 和 ns1 两个 Network Namespace 之间的拓扑图如下。\n使用 bridge 连接多个 Network Namespace veth pair 只能用于两个 netns 之间的通信，如果需要多个 netns 访问到同一个网络中，需要配置桥接网络。\n重启系统（清理掉之前创建的 netns 和 veth pair），之后重新建立 ns0, ns1 和 ns2 三个 Network Namespace。\n$ sudo ip netns add ns0 $ sudo ip netns add ns1 $ sudo ip netns add ns2 使用 ip link add 创建一个桥接接口，并建立三对 veth pair，用于连接 br0 和上述三个 netns。\n$ sudo ip link add br0 type bridge $ sudo ip link add veth0-br type veth peer name veth0 $ sudo ip link add veth1-br type veth peer name veth1 $ sudo ip link add veth2-br type veth peer name veth2 $ ip link ... 4: br0: \u0026lt;BROADCAST,MULTICAST\u0026gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether be:60:00:25:c5:37 brd ff:ff:ff:ff:ff:ff 5: veth0@veth0-br: \u0026lt;BROADCAST,MULTICAST,M-DOWN\u0026gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether 5e:5b:51:12:d0:b6 brd ff:ff:ff:ff:ff:ff 6: veth0-br@veth0: \u0026lt;BROADCAST,MULTICAST,M-DOWN\u0026gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether 72:01:3d:42:16:8c brd ff:ff:ff:ff:ff:ff 7: veth1@veth1-br: \u0026lt;BROADCAST,MULTICAST,M-DOWN\u0026gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether 5e:7a:4e:96:b1:df brd ff:ff:ff:ff:ff:ff 8: veth1-br@veth1: \u0026lt;BROADCAST,MULTICAST,M-DOWN\u0026gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether 1e:13:96:f1:b6:9d brd ff:ff:ff:ff:ff:ff 9: veth2@veth2-br: \u0026lt;BROADCAST,MULTICAST,M-DOWN\u0026gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether 62:13:73:b6:5d:f9 brd ff:ff:ff:ff:ff:ff 10: veth2-br@veth2: \u0026lt;BROADCAST,MULTICAST,M-DOWN\u0026gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether f2:e6:df:92:de:71 brd ff:ff:ff:ff:ff:ff 把 veth0, veth1, veth2 分别放到 ns0, ns1 和 ns2 三个 Network Namespace 中，并将他们重命名为 eth0。\n$ sudo ip link set dev veth0 netns ns0 $ sudo ip link set dev veth1 netns ns1 $ sudo ip link set dev veth2 netns ns2 $ sudo ip -n ns0 link set dev veth0 name eth0 $ sudo ip -n ns1 link set dev veth1 name eth0 $ sudo ip -n ns2 link set dev veth2 name eth0 并把 veth0-br, veth1-br, veth2-br 分别连接到 br0 桥接网卡中。\n$ sudo ip link set dev veth0-br master br0 $ sudo ip link set dev veth1-br master br0 $ sudo ip link set dev veth2-br master br0 启用所有的网卡接口（为了能 ping 通每个 netns 的 127.0.0.1，将每个 ns 的 lo 回环接口也启动）。\n$ sudo ip link set dev br0 up $ sudo ip link set veth0-br up $ sudo ip link set veth1-br up $ sudo ip link set veth2-br up $ sudo ip -n ns0 link set eth0 up $ sudo ip -n ns1 link set eth0 up $ sudo ip -n ns2 link set eth0 up $ sudo ip -n ns0 link set lo up $ sudo ip -n ns1 link set lo up $ sudo ip -n ns2 link set lo up 为 br0 和 netns 中的 veth 接口 （eth0）添加 IP 地址。\n$ sudo ip addr add 10.1.1.1/24 dev br0 $ sudo ip -n ns0 addr add 10.1.1.10/24 dev eth0 $ sudo ip -n ns1 addr add 10.1.1.11/24 dev eth0 $ sudo ip -n ns2 addr add 10.1.1.12/24 dev eth0 查看一下 br0 和 netns 中的 eth0 接口的 IP 地址。\n$ ip a ... 4: br0: \u0026lt;BROADCAST,MULTICAST\u0026gt; mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether be:60:00:25:c5:37 brd ff:ff:ff:ff:ff:ff inet 10.0.0.1/24 scope global br0 valid_lft forever preferred_lft forever 6: veth0-br@if5: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue master br0 state UP group default qlen 1000 link/ether 72:01:3d:42:16:8c brd ff:ff:ff:ff:ff:ff link-netns ns0 inet6 fe80::7001:3dff:fe42:168c/64 scope link proto kernel_ll valid_lft forever preferred_lft forever 8: veth1-br@if7: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue master br0 state UP group default qlen 1000 link/ether 1e:13:96:f1:b6:9d brd ff:ff:ff:ff:ff:ff link-netns ns1 inet6 fe80::1c13:96ff:fef1:b69d/64 scope link proto kernel_ll valid_lft forever preferred_lft forever 10: veth2-br@if9: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue master br0 state UP group default qlen 1000 link/ether f2:e6:df:92:de:71 brd ff:ff:ff:ff:ff:ff link-netns ns2 inet6 fe80::f0e6:dfff:fe92:de71/64 scope link proto kernel_ll valid_lft forever preferred_lft forever $ sudo ip -n ns0 a 5: eth0@if6: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether 5e:5b:51:12:d0:b6 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 10.1.1.10/24 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::5c5b:51ff:fe12:d0b6/64 scope link proto kernel_ll valid_lft forever preferred_lft forever $ sudo ip -n ns1 a 7: eth0@if8: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether 5e:7a:4e:96:b1:df brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 10.1.1.11/24 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::5c7a:4eff:fe96:b1df/64 scope link proto kernel_ll valid_lft forever preferred_lft forever $ sudo ip -n ns2 a 9: eth0@if10: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether 62:13:73:b6:5d:f9 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 10.1.1.12/24 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::6013:73ff:feb6:5df9/64 scope link proto kernel_ll valid_lft forever preferred_lft forever 此时在主机上可以 ping 通三个 netns 的 IP 地址。\n$ ping -c 1 10.1.1.10 PING 10.1.1.10 (10.1.1.10) 56(84) bytes of data. 64 bytes from 10.1.1.10: icmp_seq=1 ttl=64 time=0.130 ms $ ping -c 1 10.1.1.11 PING 10.1.1.11 (10.1.1.11) 56(84) bytes of data. 64 bytes from 10.1.1.11: icmp_seq=1 ttl=64 time=0.117 ms $ ping -c 1 10.1.1.12 PING 10.1.1.12 (10.1.1.12) 56(84) bytes of data. 64 bytes from 10.1.1.12: icmp_seq=1 ttl=64 time=0.119 ms 三个 netns 也可以访问主机的 IP 地址 10.1.1.1。\n$ sudo ip netns exec ns0 ping -c 1 10.1.1.1 PING 10.1.1.1 (10.1.1.1) 56(84) bytes of data. 64 bytes from 10.1.1.1: icmp_seq=1 ttl=64 time=0.076 ms $ sudo ip netns exec ns1 ping -c 1 10.1.1.1 PING 10.1.1.1 (10.1.1.1) 56(84) bytes of data. 64 bytes from 10.1.1.1: icmp_seq=1 ttl=64 time=0.071 ms $ sudo ip netns exec ns2 ping -c 1 10.1.1.1 PING 10.1.1.1 (10.1.1.1) 56(84) bytes of data. 64 bytes from 10.1.1.1: icmp_seq=1 ttl=64 time=0.072 ms 默认情况下 Linux 会把 bridge 的二层转发（交换机）功能禁用掉，因此不同的 netns 之间仍无法互相访问。\n$ sudo ip netns exec ns0 ping -c 1 -W 5 10.1.1.11 PING 10.1.1.11 (10.1.1.11) 56(84) bytes of data. --- 10.1.1.11 ping statistics --- 1 packets transmitted, 0 received, 100% packet loss, time 0ms 使用 IP 桌子，激活桥接接口的转发功能。\n$ sudo iptables -A FORWARD -i br0 -j ACCEPT 此时不同的 netns 之间可以互相 ping 通了。\n$ sudo ip netns exec ns0 ping 10.1.1.12 PING 10.1.1.12 (10.1.1.12) 56(84) bytes of data. 64 bytes from 10.1.1.12: icmp_seq=1 ttl=64 time=0.148 ms 到这里有关 Linux Network Namespace 的配置就可以完美的告一段落了，咱创建了三个 netns，它们之间可以通过 10.1.1.0/24 这一个网段通过 bridge 桥接网卡和 veth pair 实现互相二层（交换机）访问，此时的网络拓扑图变成了下面这样子。\n如果想要更进一步，要实现 netns 内访问其他网段的 IP 地址，还需要再做一些配置，让主机实现网关功能，并配置 NAT，让主机实现 3 层地址转发（路由器）。\n$ sudo ip netns exec ns0 ping -c 1 8.8.8.8 ping: connect: Network is unreachable 首先需要将主机的网卡（咱这里为 enp1s0，不同系统可能不一样）也添加到将桥接网卡 br0 中，这里要注意把主机的网卡 enp1s0 添加到桥接网卡 br0 后，要把 enp1s0 网卡上的 IP 地址（咱这里为 192.168.122.101/24）改到桥接网卡 br0 上，不然过一段时间后会网络中断。\n这里不要 ssh 远程操作。\n$ sudo ip link set enp1s0 master br0 $ sudo ip addr del 192.168.122.101/24 dev enp1s0 $ sudo ip addr add 192.168.122.101/24 dev br0 手动为 netns 设定默认网关 10.1.1.1/24。\n$ sudo ip -n ns0 route add default via 10.1.1.1 $ sudo ip -n ns1 route add default via 10.1.1.1 $ sudo ip -n ns2 route add default via 10.1.1.1 接下来使用 IP 桌子配置 IP 地址转发，这里的指令和之前配置 Linux 主机做路由器是一样的。\n$ sudo iptables --table nat -A POSTROUTING -s 10.1.1.0/24 -j MASQUERADE 查看一下 netns 中的路由表，这时的默认流量会走 10.1.1.1 网关。\n$ sudo ip -n ns0 route default via 10.1.1.1 dev eth0 10.1.1.0/24 dev eth0 proto kernel scope link src 10.1.1.10 到这里如果不出意外的话，三个 netns 已经具备访问公网的能力了。\n$ sudo ip netns exec ns0 ping -c 1 8.8.8.8 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=112 time=66.0 ms --- 8.8.8.8 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 65.964/65.964/65.964/0.000 ms 容器网络 其实上面咱演示的使用 bridge 桥接网卡 + veth pair 配置多个 Network Namespace 互相访问的这个网络模型基本上就和 Docker 默认的 bridge 网络模型没啥区别了。\n只是 Docker 使用 runc/libcontainer 没有把容器对应的 Network Namespace 文件放到 /var/run/netns/ 目录，使用 ip netns 命令发现不到它。不过带胶布，可以把 Docker 容器中应用的 Network Namespace 对应文件软链接到 /var/run/netns/ 目录中，再使用 ip 命令执行一些操作。\n首先跑一个 nginx 容器，使用 docker inspect 获取进程的 PID。\n$ docker run -dit --name nginx -p 80:80 nginx $ docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx 993 创建软链接，将进程的 netns 文件链接到 /var/run/netns 目录。\n$ sudo mkdir -p /var/run/netns $ sudo ln -s /proc/993/ns/net /var/run/netns/ns-993 $ ip netns ns-993 $ sudo ip netns exec ns-993 ip addr 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 4: eth0@if5: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever 之后可以像上面那样，再建立一对 veth pair，为容器创建 “第二个网卡” eth1，实现主机和容器之间的访问。\n$ sudo ip link add eth0-ns-993 type veth peer name veth-ns-993 $ sudo ip link set eth0-ns-993 netns ns-993 $ sudo ip -n ns-993 link set dev eth0-ns-993 name eth1 $ sudo ip -n ns-993 addr 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 4: eth0@if5: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever 9: eth1@if8: \u0026lt;BROADCAST,MULTICAST\u0026gt; mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 36:57:fa:63:3b:f0 brd ff:ff:ff:ff:ff:ff link-netnsid 0 $ sudo ip addr add 10.1.0.1/24 dev veth-ns-993 $ sudo ip -n ns-993 addr add 10.1.0.2/24 dev eth1 $ sudo ip link set dev veth-ns-993 up $ sudo ip -n ns-993 link set dev eth1 up $ ping 10.1.0.2 PING 10.1.0.2 (10.1.0.2) 56(84) bytes of data. 64 bytes from 10.1.0.2: icmp_seq=1 ttl=64 time=0.040 ms ... $ curl 10.1.0.2 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; ... 看吧，就是这么的简单（确信）。\n所以在运行了 Docker 的主机上执行 ip 命令有时能看到一大堆 veth 开头的网卡设备名，到这里我们就能明白这些实际上是 veth pair，一端连接到了 docker0 桥接网卡上，另一端则连接在 Docker 容器的 Network Namespace 中。\n$ ip l 3: docker0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default link/ether 02:42:48:1b:aa:e0 brd ff:ff:ff:ff:ff:ff 5: veth077b91e@if4: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default link/ether 6e:29:0d:fb:d2:43 brd ff:ff:ff:ff:ff:ff link-netnsid 0 Kubernetes Pod 众所周知，Kubernetes 的一个 Pod 中可以包含多个容器，这些容器共用一个网络命名空间，不同容器运行的程序可以直接通过 127.0.0.1 回环地址互相访问。这里需要补充一个萌新容易混淆的概念就是，Linux 的 Namespace 和 Kubernetes 的 Namespace 不是一个东西，前者是 Linux 内核 Level 的特性，后者是 Kubernetes API Server Level 的功能，虽然都叫 Namespace 但他俩不是一个东西。\n那么 Kubernetes 的 Pod 是如何实现多个容器共用一个 Network Namespace 的呢？之前用过 Kubernetes 的小朋友可能会注意到他们的 Container Runtime 中总能看到名叫 pause 的容器，这又是干什么的呢？\nDocker 的网络模型除了默认的 bridge 之外，还有 host, none 和 container 这几种。其中 host 是指和主机共用同一个网络命名空间，none 是容器的 Network Namespace 不配置任何额外的网络。而 container 网络模型则是用来指定一个已有的容器，和他共用同一个 Network Namespace。\nKubernetes 的 Pod 需要让多个容器共用同一个 Network Namespace，所以需要先找一个容器创建 Network Namespace，再让其他容器加入到这个预先创建好的 Network Namespace 中。让 Pod 中任何一个容器作为创建 Network Namespace 的容器都不合适，所以就出来了一个 pause 容器，这个容器体积很小，运行之后其进程永远处于休眠（pause）状态，且 pause 容器的进程 PID 为 1，因为除了创建网络命名空间外，pause 容器还创建了 Linux 进程命名空间，用于回收僵尸进程。\nPause 容器的源码可以在 这里 找到，可以看到它主要确保自己的 PID 为 1，处理一些 Linux Signal 之外，其余时间一直都在 pause。\n可以用 Docker 的 container 网络模型模拟一个 Kubernetes 的 Pod，因为想不出什么太合适的栗子，所以这个 “Pod” 里运行了一个 nginx server 和一个 registry server。\n$ docker run -d --name pause -p 8080:80 -p 5000:5000 --ipc=shareable rancher/mirrored-pause:3.6 $ docker run -d --name nginx --net=container:pause --ipc=container:pause --pid=container:pause nginx $ docker run -d --name registry --net=container:pause --ipc=container:pause --pid=container:pause registry $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES eaace8974956 registry \u0026#34;/entrypoint.sh /etc…\u0026#34; 2 minutes ago Up 2 minutes registry 247ed1ca07e3 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 2 minutes ago Up 2 minutes nginx 6cdf835a09f0 rancher/mirrored-pause:3.6 \u0026#34;/pause\u0026#34; 2 minutes ago Up 2 minutes 0.0.0.0:5000-\u0026gt;5000/tcp, :::5000-\u0026gt;5000/tcp, 0.0.0.0:8080-\u0026gt;80/tcp, :::8080-\u0026gt;80/tcp pause $ curl 127.0.0.1:8080 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; ... $ docker login 127.0.0.1:5000 Username: admin Password: Login Succeeded ","permalink":"https://blog.starry-s.moe/posts/2024/container-network-1/","summary":"\u003cp\u003e稍微折腾一下容器网络相关的东西……\u003c/p\u003e","title":"初探容器网络"},{"content":"K3s 是一个轻量的 Kubernetes 集群，Multus 是一个用于给 Pod 创建多个网络接口的 CNI (Container Network Interface) 插件，其创建的接口支持 macvlan。\n啥是 Macvlan 字面意思，根据 MAC 地址划分的虚拟子网 (Vlan) 就是 macvlan，网上能搜到很多有关 Macvlan 的介绍，这里不再过多描述。\n与之相对应的还有一个叫 ipvlan，是通过 IP 地址划分的虚拟子网。\nMacvlan 和 ipvlan 都是 Linux 系统的特性，其他系统不支持这个功能。\nPrerequisites 可以用 modinfo macvlan 检查系统是否有安装 macvlan 模块，根据 Docker 文档 中描述的建议是使用 Linux 3.9 或 4.0 及更新的内核版本。\n可以用以下指令检查系统是否支持 Macvlan（这里使用桥接模式）：\nsudo ip link add macvlan0 link enp1s0 type macvlan mode bridge # 这里替换 enp1s0 为网卡接口名称 sudo ip address add 192.168.122.205/24 broadcast 192.168.122.255 dev macvlan0 # 注意 IP 地址冲突 之后可尝试使用其他处于同一个网络（CIDR）的设备 ping 这个 192.168.122.205 IP 地址，能 Ping 通就说明你的防火墙没有屏蔽不同设备之间的二层数据转发。\n安装 K3s 根据 Multus 的 QuickStart 手册，准备一个新版本的 Kubernetes 集群（这里用的是 v1.27.8+k3s2），K3s 默认的 CNI 插件使用的是 Flannel。\n在国内的话需要先创建 /etc/rancher/k3s/registries.yaml 配置 Registry Mirror：\nmirrors: docker.io: endpoint: - \u0026#34;https://docker.nju.edu.cn\u0026#34; ghcr.io: endpoint: - \u0026#34;https://ghcr.nju.edu.cn\u0026#34; 之后使用国内源一键安装 K3s：\n#!/bin/bash curl -sfL https://rancher-mirror.oss-cn-beijing.aliyuncs.com/k3s/k3s-install.sh | \\ INSTALL_K3S_VERSION=v1.27.8+k3s2 \\ INSTALL_K3S_MIRROR=cn \\ sh -s - server \\ --cluster-init \\ --system-default-registry \u0026#34;docker.nju.edu.cn\u0026#34; 安装 Multus CNI 接下来安装 Multus CNI 插件，下载 multus-daemonset.yml 配置，需要编辑 kube-multus-ds DaemonSet hostPath 的路径到 K3s 对应的路径上去。\nwget \u0026#39;https://raw.githubusercontent.com/k8snetworkplumbingwg/multus-cni/master/deployments/multus-daemonset.yml\u0026#39; 编辑 kube-multus-ds DaemonSet 的 hostPath 的配置为 K3s 的路径。\n... volumes: - name: cni hostPath: path: /var/lib/rancher/k3s/agent/etc/cni/net.d - name: cnibin hostPath: path: /var/lib/rancher/k3s/data/current/bin ... 还要编辑 kube-multus-ds DaemonSet 的 Container 配置，增添一条 command arg：\n... containers: - name: kube-multus image: ghcr.io/k8snetworkplumbingwg/multus-cni:snapshot command: [\u0026#34;/thin_entrypoint\u0026#34;] args: - \u0026#34;--multus-conf-file=auto\u0026#34; - \u0026#34;--multus-autoconfig-dir=/host/etc/cni/net.d\u0026#34; - \u0026#34;--cni-conf-dir=/host/etc/cni/net.d\u0026#34; # ADD THIS LINE: - \u0026#34;--multus-kubeconfig-file-host=/var/lib/rancher/k3s/agent/etc/cni/net.d/multus.d/multus.kubeconfig\u0026#34; ... 之后 kubectl apply 上面的 Multus Daemonset 配置，等待 kube-multus-ds DaemonSet 跑起来后，可以看到 /var/lib/rancher/k3s/data/current/bin 目录下有新增 multus 可执行文件。\n$ sudo ls /var/lib/rancher/k3s/data/current/bin | grep multus multus 自定义 Multus CNI 配置文件 新建一个名为 macvlan-conf 的 NetworkAttachmentDefinition Custom Resource，自定义 multus 配置文件：\n这里需要注意 config 中的 master 网卡接口要设置为物理机上对应的网卡接口名。\n咱把 K3s Server 安装在了 QEMU 虚拟机中，虚拟机使用的是 libvirt 创建的默认网卡，CIDR 编址为 192.168.122.0/24，网关 192.168.122.1。 为了能在其他虚拟机 / 物理机上也能访问到虚拟机中使用了 macvlan 的 pod，multus macvlan 配置文件也使用 libvirt 网卡的 CIDR。\napiVersion: \u0026#34;k8s.cni.cncf.io/v1\u0026#34; kind: NetworkAttachmentDefinition metadata: name: macvlan-conf spec: config: \u0026#39;{ \u0026#34;cniVersion\u0026#34;: \u0026#34;0.3.1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;macvlan\u0026#34;, \u0026#34;master\u0026#34;: \u0026#34;enp1s0\u0026#34;, \u0026#34;mode\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;ipam\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;host-local\u0026#34;, \u0026#34;subnet\u0026#34;: \u0026#34;192.168.122.0/24\u0026#34;, \u0026#34;rangeStart\u0026#34;: \u0026#34;192.168.122.200\u0026#34;, \u0026#34;rangeEnd\u0026#34;: \u0026#34;192.168.122.210\u0026#34;, \u0026#34;routes\u0026#34;: [ { \u0026#34;dst\u0026#34;: \u0026#34;0.0.0.0/0\u0026#34; } ], \u0026#34;gateway\u0026#34;: \u0026#34;192.168.122.1\u0026#34; } }\u0026#39; $ kubectl apply -f macvlan-conf.yaml $ kubectl get net-attach-def NAME AGE macvlan-conf 59s 创建 Macvlan Pod K3s 将安装包体积做了精简移除了 macvlan CNI 插件，所以创建 Pod 之前需要手动下载 macvlan CNI 插件放到 K3s 的 data bin 目录。\n$ mkdir -p cni-plugin \u0026amp;\u0026amp; cd cni-plugin $ wget https://github.com/containernetworking/plugins/releases/download/v1.4.0/cni-plugins-linux-amd64-v1.4.0.tgz $ tar -zxvf cni-plugins-linux-amd64-v1.4.0.tgz $ sudo cp ./macvlan /var/lib/rancher/k3s/data/current/bin/ 之后创建 Pod，使用 Annotation 指定网络的配置文件，并让 Pod 被 Multus CNI 识别。\napiVersion: v1 kind: Pod metadata: name: nginx-macvlan annotations: k8s.v1.cni.cncf.io/networks: macvlan-conf spec: containers: - name: nginx image: nginx 如果一切顺利的话，kubectl describe pod nginx-macvlan 能看到以下的 Events：\nEvents: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 2s default-scheduler Successfully assigned default/nginx-macvlan to archlinux-k3s-1 Normal AddedInterface 2s multus Add eth0 [10.42.0.26/24] from cbr0 Normal AddedInterface 2s multus Add net1 [192.168.122.200/24] from default/macvlan-conf 因为 K3s 服务器跑在了 QEMU KVM 虚拟机里面，libvirt 默认网卡 CIDR 是 192.168.122.0/24。所以咱在物理机上访问虚拟机内的 Macvlan Pod IP 192.168.122.200，是能正常访问的。\n$ curl 192.168.122.200 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; ... 然后因为 Macvlan 的子接口 (sub interface) 无法与父接口 (parent interface) 直接访问，所以在节点的主机上访问运行在这个节点内的 macvlan pod 是访问不通的，也就是说无法通过节点主机的接口访问到 macvlan pod 的子接口，除非使用 ipvlan，可以参考以下这几篇讨论：\nSingle node Microk8s multus master interface cannot be reached Host and Containers cannot communicate - MACVLAN ","permalink":"https://blog.starry-s.moe/posts/2024/k3s-multus-macvlan/","summary":"\u003cp\u003e\u003ca href=\"https://k3s.io/\"\u003eK3s\u003c/a\u003e 是一个轻量的 Kubernetes 集群，\u003ca href=\"https://github.com/k8snetworkplumbingwg/multus-cni\"\u003eMultus\u003c/a\u003e 是一个用于给 Pod 创建多个网络接口的 CNI (Container Network Interface) 插件，其创建的接口支持 \u003ccode\u003emacvlan\u003c/code\u003e。\u003c/p\u003e","title":"K3s + Multus CNI 插件使用 Macvlan"},{"content":"用这么久 Arch 了，但是却很少写 Arch 相关的博客……\n最近常需要在虚拟机上装 Arch，所以把常用工具及配置整理在这儿，省得每次 pacstrap 时都要想半天咱需要装什么……\n装系统 Arch Wiki 的 Installation Guide 在使用 pacstrap 装系统时只写了最基础的软件包 base, linux 和 linux-firmware，可以在这一步补充亿些常用的软件。\npacstrap -K /mnt base linux linux-firmware \\ # 坠基础的核心组件 base-devel gcc grub amd-ucode archlinuxcn-keyring \\ # 装 AUR 软件需要用到, ArchLinux CN 以及启动引导使用的 GRUB zsh zsh-syhtax-highlighting zsh-autosuggestions \\ # 咱使用 zsh vim neovim git openbsd-netcat \\ # 文本编辑器 \u0026amp; Git 以及ssh 使用 proxy 的工具 sudo man-db htop wget \\ # sudo、man、更好用的 top、wget neofetch \\ # 装 X 用的（确信） mkinitcpio-firmware # 消除 mkinitcpio 的大量 WARNING（没什么用，但强迫症必备） 进 chroot 后编辑 /etc/pacman.conf，添加以下配置，启用 Arch Linux CN。\n# /etc/pacman.conf # 这里使用北京外国语大学镜像站 [archlinuxcn] Server = https://mirrors.bfsu.edu.cn/archlinuxcn/$arch 之后安装 yay:\nsudo pacman -Syy \u0026amp;\u0026amp; sudo pacman -S yay 如果电脑上安装了其他系统的话，需要额外安装 os-prober，让 GRUB 在生成配置文件时搜索安装了其他系统的磁盘。\nsudo pacman -S os-prober 如果是为 QEMU KVM 虚拟机装系统的话，在执行 grub-install 配置 UEFI 启动引导时记得加一个 --removable 参数。\nsudo grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB --removable sudo grub-mkconfig -o /boot/grub.cfg 如果不装其他网络工具，只使用 systemd-networkd 的话，需要创建一份默认的配置文件使用 DHCP，否则连不上网。\n# /etc/systemd/network/10-default.conf [Match] Name=enp* [Network] DHCP=yes 并启用 systemd-networkd Systemd Service：\nsudo systemctl enable systemd-networkd 基本上到这里就可以愉快的 reboot 了，一个精简的系统所需要的软件就基本装好了。\n常用命令行工具 如果只作为服务器 / 不包含图形的虚拟机使用的话，装这些咱常用软件，这部分因人而异，仅供参考。\nsudo pacman -S go \\ # 写 Go 用的 kubectl helm \\ # k8s 相关的命令行工具 docker docker-buildx \\ # 运行容器镜像的工具 privoxy \\ # 转发 socks 代理到 HTTP 代理的工具 proxychains \\ # 让 C 写的软件走代理的 Hook wireguard-tools \\ # WireGuard axel aria2 \\ # 支持多线程下载的工具 ffmpeg \\ # 转码视频/图片的工具 jq go-yq \\ # 格式化处理 json \u0026amp; yaml 的工具 jdk8-openjdk \\ # JDK \u0026amp; JRE（这里写的是 Java 8，可以换成其他的 Java LTS 版本） lm_sensors \\ # 硬件监测工具（查看温度之类的） net-tools traceroute \\ # 常用网络工具 nodejs npm \\ # NodeJS \u0026amp; Node Package Manager python3 python-pip \\ # Python 相关 btrfs-progs \\ # btrfs 相关工具 wireguard-tools \\ # 咱常用的 VPN bind \\ # 检查 DNS 网络相关的工具 (dig) ethtool \\ # 网卡驱动相关工具 bc # 命令行计算器 yay -S golangci-lint-bin \\ # Go 常用的 linter krew-bin # 可以理解为一个 kubectl 插件的包管理器 # 装完 Docker 后把普通用户添加到 docker group 中 sudo usermod -aG docker $USER 创建 Docker Daemon 的配置文件 /etc/docker/daemon.json，设定国内的 Mirror，这里用的是南京大学的 Docker Mirror：\n{ \u0026#34;insecure-registries\u0026#34; : [ \u0026#34;127.0.0.1:5000\u0026#34; ], \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://docker.nju.edu.cn/\u0026#34; ] } 如果需要跑虚拟机，需要装 QEMU 和 libvirt 相关的组件（咱用 virsh 管理虚拟机，不手搓 qemu 指令）：\nsudo pacman -S qemu-full libvirt K3s / RKE2 Server 在 Arch Linux 上安装了 K3s 或 RKE2，关机时会卡在 a stop is running for libcontainer containerd... 一分多钟……\n参考 这个 Issue，创建一个 /etc/systemd/system/shutdown-k3s.service Systemd 文件。\n[Unit] Description=Kill containerd-shims on shutdown DefaultDependencies=false Before=shutdown.target umount.target [Service] ExecStart=/usr/local/bin/k3s-killall.sh Type=oneshot [Install] WantedBy=shutdown.target 之后启用 shutdown-k3s.service，在关机时 Kill 掉 K3s。\nsudo systemctl daemon-reload sudo systemctl enable shutdown-k3s.service WireGuard Client 如果 Arch Linux 还配置了 WireGuard 客户端，而这台 Arch Linux Server 被放在了家里，只能通过有公网 IP 的 WireGuard 服务器连接进去，这时尽管设置了 WireGuard 的 persistent keepalive，但在运营商更换了你家的公网 IP 后，还是会碰到无法自动连接回去的情况，这时可以用咱的 这个简单粗暴的脚本，在 WireGuard 断连一段时间后，自动重启接口。\n图形界面 显卡驱动：\n# AMD pacman -S amdgpu # NVIDIA pacman -S nvidia X11/Wayland 这些相关组件会随着桌面环境一起安装，所以只需要装桌面环境即可，这里就不需要你额外装 X 了。\n# 咱用 GNOME sudo pacman -S gnome # 通常不直接装 gnome-extra，而是从里面选咱需要的 sudo pacman -S gnome-tweaks 常用的 GUI 软件 装好图形界面并顺利跑起来之后，就可以装常用的桌面软件了，下面这些是部分可能用到的软件，这些因人而异，仅供参考。\nsudo pacman -S vlc \\ # 视频播放器 virt-manager \\ # 管理 qemu 虚拟机 ttf-monaco \\ # 一个很好看的，在 macOS 上有预装的等宽字体 noto-sans noto-fonts-cjk noto-fonts-emoji ttf-dejavu \\ # 一些字体 ibus ibus-rime \\ # ibus + RIME 中文输入法 firefox \\ # 火狐浏览器 emacs \\ # 文本编辑器 virt-manager # libvirt 的图形客户端 在 AUR 中安装的软件：\nyay -S google-chrome \\ # 谷歌浏览器 visual-studio-code-bin # 文本编辑器 启用 Multilib 启用 Multilib 以安装那些 32 位的软件，例如 Steam。\n# /etc/pacman.conf [multilib] Include = /etc/pacman.d/mirrorlist 之后安装 Steam。\nsudo pacman -S steam 如果需要加速 Steam 游戏，可以安装 uuplugin-bin，把电脑伪装成 Steam Deck，酱紫路由器有 UU 加速器插件的话就能给 Steam 加速。\nyay -S uuplugin-bin 如果要运行 Windows 游戏，还要安装 Proton。\nyay -S proton 音乐 netease-cloud-music 这个包已经很久没更新了，现在很多功能用不了，除了这个还有一些基于 GTK4 写的网易云音乐客户端也能用。\nyay -S netease-cloud-music # 网易云音乐 yay -S cider-bin # Apple Music 流程图 Draw.io 这个工具画流程图很好用，而且支持 Linux，可以直接从 Arch Linux CN 安装。\nsudo pacman -S drawio-desktop-bin 未完待续，如果还想到了别的再补充到这儿。\n","permalink":"https://blog.starry-s.moe/posts/2024/archlinux-utils/","summary":"\u003cp\u003e用这么久 Arch 了，但是却很少写 Arch 相关的博客……\u003c/p\u003e\n\u003cp\u003e最近常需要在虚拟机上装 Arch，所以把常用工具及配置整理在这儿，省得每次 \u003ccode\u003epacstrap\u003c/code\u003e 时都要想半天咱需要装什么……\u003c/p\u003e","title":"一些 Arch Linux 的常用组件整理"},{"content":"这里没有年终总结。\nsed \u0026#39;s/2023/2024/g\u0026#39; 没什么头绪，不知道该从什么地方说起。\n旅行 2023 年咱去了很多很多的地方，去了成都、重庆、上海、长春、本溪、哈尔滨、长白山（是 2024 年初去的但依旧放在今年的总结里吧）。\n现在回想一下，在成都和重庆去了他们那边当地的漫展和一些专门为游客准备的景点（世界线展子好大）。今年一共去了三次上海，第一次是去的 Bilibili World 和 Bilibili Macro Link。第二次是去的 KubeCon。第三次是去看梶浦由记的 Live，顺便去了一趟野生动物园。（实际上差点就去了四次，但是上海梦兽和 KubeCon 时间撞车了，门票没买到所以没去成）。在吉林参加了两次兽聚，分别是长春的疯狂一夜小聚和长白山附近的白兽渊。长白山景区因为下雪封闭了所以没去成（嗯，都是某位雪神的锅，哼），滑雪时间来不及了也没滑上。年底去了尔滨冰雪大世界，体验了一把在室外零下二十多度的地方排队四个小时的滋味……\n生活 工作和生活方面与 22 年咱回到辽宁后没什么变化，咱依旧是居住在沈阳这座城市，今年是咱大学毕业后，在沈阳这个城市定居的第一年。不过幸好咱大学也是在沈阳念的，所以没有遇到过多的水土不服和气候、环境不适应的情况，也就是年初的时候经历过许多次的生病发烧、各种感冒（几乎不到一个月一次的那种），应该是因为租的房子的原因吧，空间狭窄、不通风、很闷，沈阳的冬天又那么的干冷，真的很容易生病。不过从校园生活转变为在校园外的感觉很不一样，咱之前可没和这么多的东北人打过交道，虽然第一反应觉得东北话挺逗挺有意思的，但时间久了实际上东北话有一种语气蛮横，充满脏话，很直白的那种，给人很不舒服的感觉。尤其是碰到过很多黑心出租车，欺负外地人，嗯，出租车司机只是咱举的一个栗子，就是总能在很多细节的地方找出曾经的老工业和军阀的气息。而沈阳排斥外地人的方式也很有特点，大多数人的思维方式也蛮与众不同的，总之就是碰到那种能和你唠一道的出租车司机，跟你骂骂咧咧抱怨这抱怨那的，你就迎合他说啊对对对，啊是是是，哄他心情开心就得了，咱一个人生活在这座城市，打车可不敢招惹这样的司机，也犯不上和这种人闹别扭是吧。\n咱没有什么地域黑的意思，至少咱还是喜欢沈阳这座城市的，在别的城市也能碰到不同的人和事，强者从不抱怨环境，但咱不是强者，不配抱怨环境，也决定不了自己所在的环境，不要问咱为什么要回沈阳，也不要羡慕那些自己没有而别人有的东西。咱只是觉得这座城市似乎出于什么原因，很多地方都和外界隔绝了一样，有种大范围的信息差不对等的感觉。经常能听到有人说 “东北谁爱回谁回，我反正不回” 这样的言论，但至少现在是有许多人在努力改善这种情况（当然也有许多人在努力防止这种情况被改善就是了）。有机会的话多去沈阳的市博物馆、陵寝和故宫那附近逛逛，了解点历史还是有帮助的，起码能帮助外地人熟悉这座城市，而不是单纯的通过表面现象去做结论。\n咳，说多了，至于为什么今年去了那么多城市一个主要的原因就是想尽可能的改善咱的社恐，咱很纳闷为什么在别的城市就能过的好好的偏偏回到东北就变成了这个样子。其实咱在之前上学的时候，就一直想的是以后坚决不留在东北，以后一定要去老师和亲戚朋友口中所说的南方大城市。当时咱就是很难适应东北的种种事情，咱和沈阳本地人几乎没有过什么交流，咱只记得那时候，路边的小商铺一直在用大声的音箱放着土味音乐和吆喝声，总能看到 “精神小伙” 和某手短视频、土味段子的这种低俗没营养的视频（我不看但身边总有同学在外放这些）。至于同学举行的聚会、社团活动什么的，咱在大一转专业之前试着参加过几次但因为很不合群，闹得十分不愉快而最终不再参加这样的活动了。工作之后，在意识到咱回到东北了，突然意识到咱根本就没办法和本地人正常交流这件事，从而变成了十分严重的社恐，就像一个丢了 Context 的 Go Routine 一样，咱就这么成为了一个大号的社会不适应者，等着被这个社会淘汰掉。其实咱有想过要不要去看心理医生之类的但最终还是不想去医院，没有什么理由就是觉得咱有自己的方式能解决这些问题，如果治不好的话就算了。逼着这种病态的社恐人去参加些什么社交活动，只会加重这种情况。\n出于爱好，咱经常去沈阳本地的漫展，也就是在年初的漫展上看到了一群大福瑞从而被拖下水入坑了福瑞控。讲真在其他城市的漫展很少能看到这么多的大福瑞，咱也是从这时候开始尝试和他们加好友聊天，还试着参加一些线下的社团活动（但是效果并不好，所以咱后来又把这些社团退掉了，到现在咱还是很谨慎几乎不加入社团什么的）。咱在入坑福瑞之后买了一台入门残幅相机，尝试给他们拍照返图，顺便认识了一些新的朋友。因为福瑞这个圈子，额，不太好和圈外的人解释，所以很长一段时间以来咱从来没和圈外的人提到过咱也是福瑞这个事。也就到了年底咱在别的装师那里捡了一个掉落头之后，才开始大量的向咱的社交帐号上发福瑞相关的东西，顺便去了长白山的兽聚，和一群大佬们合影、交换物料、试着参加一些活动什么的，不过咱依旧是和身边任何人保持着很大的距离感……\n咱没有刻意隐瞒咱是福瑞这些相关的东西，也并没有想背着别人搞一些坏事什么的。其实就算被身边的人发现了也没什么大不了的，只取决于圈外的人对福瑞的看法了，所以避免不必要的争吵，大多数时候咱还是不想让他们知道而已。所以请避免当面问我不礼貌的问题，不要开黄腔，不要讨论性别，不要讨论性取向，可以开玩笑但不要过分。崽子是崽子，内胆是内胆，不要把崽子的事情上升到内胆，如果不喜欢看可以不看，不要把崽子的形象和内胆进行绑定，不要盗图盗设定，不要拍打兽装头部，这些都是基本常识。\n但是，咱真的很想认识更多的朋友，虽然咱反感社交，但参加完这些活动后真的能开心好长好长一段时间。咱真的不再希望自己一个人孤零零的去漫展了，一个人去兽聚没人拼酒店票真的很没意思，很多旅游景点明摆着就是给多人准备的，一个人根本就玩不了（但是不要问我为什么没有邀请你一起去漫展/兽聚这些活动，只是单纯的认为不合适，我没有准备好，这样子会很尴尬的）。\n还有就是，网络上的社交软件能展示的东西太少了，这个窗口只能暴露出极少数的文字和图片等信息，但人们往往把网络上展示出来的部分信息当作成了这个人的全部，这很容易就会引起很大很大的误会，这也是咱为什么逐渐的不想在网络上发更多的消息了，尤其是咱的微信加了各种各样的好友，于是就不想再发只适合某类好友看的朋友圈了。聊天软件上发的几行文字是不带语速、情感、环境信息的，如果可以的话咱更希望是通过面对面的聊天去熟悉一个人，而不是通过他在社交平台上发的一些文字、聊天软件上发的表现不出来完整情感的几句话。至于那些曾经由种种原因已经产生的误会，咱也不打算去和别人解释了，有时候就保持着这些误会也挺好的，到能解开的时候自然就解开了，解不开就算了。\n但是咱还是很怀念那些曾经因为种种原因导致的已经不联系了的朋友们，唉。\n工作 工作一年多了，依旧在学很多新的知识。比较值得一提的是咱今年去了上海的 KubeCon，除了在公司的展台那里帮忙收拾东西，空余时间还可以去楼上的各个会场听大佬们的演讲。说实话除了上海应该不会再有别的城市能举行这种大规模国际化的、带有开源社区的大型活动了。貌似有很多公司是奔着商业主题相关的演讲去的，但咱个人层面则是更倾向于去看一些开源技术的演讲，咱属于是刚接触这个领域没多久，属于是什么都想听，但时间紧只能从日程表中选出某几个演讲去听的那种。尽管咱听不懂（听不懂英语 + 听不懂技术内容）但多少能收获到那些大佬们的一些思路、思维方式和写开源项目的风格、感受一下技术氛围之类的，至少咱后面的程序开发思路可以借鉴一部分，这些往往是商业的演讲容易遗漏掉的东西。听这些大佬们的演讲有一种在大学上课的感觉，只是听一遍的话肯定是记不住老师讲的什么内容的，而咱根本就没打算要把所有演讲的内容全记脑子里，咱就是感觉这种氛围是真的和大学的课堂很像很像。因为咱这个年龄就和个小孩子似的，去这种 Conference 要不是戴着公司的胸牌估计就直接被保安拦外面了……当时保安还怀疑我的胸牌是不是复印假的每次都是反复检查好久才放我进去。印象比较深的就是在发物料时，有好多在上海的大学生过来领，然后他们的胸牌上的公司名称写的要么是某某大学什么的，要么就是胡乱起的名字，就挺有意思的…… 嗯咱今年一共领了两种不同的英特尔袋子，一个是在 B 站的 BW 上领的（听说这个袋子在当时虹桥那边暴雨发水时保住了好多 Coser 的衣服），另一个是在 KubeCon 上领的，英特尔他真的好喜欢发袋子。去完 KubeCon 后一直想找时间去学 Rust 和 Linux Kernel 的 eBPF 相关知识来着，但这个貌似要推到 2024 年再去学了。公司对新人真的太好了，能有这样的机会去上海的 KubeCon 真的开心死了。\n从 KubeCon 回来后咱把咱自己曾经写的一个开源程序给重构了一遍，基本上就是咱的上一篇博客里讲的那些内容。本来想单独开一篇博客介绍这个程序的但最近真的真的太忙了没时间了所以就没写（实际博客内容都写一半了但既然写年终总结了就压缩一下内容放在这里吧）。因为这个程序主要还是应用在云原生相关的场景的，所以咱也仿照着 Rancher 官网、K3s 官网这些去重写了一下咱这个程序的文档网站（官网）。咱还把咱的程序按照咱的思维去重构了一遍，比如咱个人的观点认为，要编写一个清真的开源软件，除非万不得已，不要调用任何其他第三方的二进制文件（当然这里说的二进制文件是指一个可执行文件，不是动态库，还有除非你的程序就是设计为一个 Wrapper，否则为了长远考虑，不要为了实现某个功能而调用某个第三方的可执行文件），而是通过已有的 API 和 Library 通过代码去实现这些功能，再大一点的项目还会手搓轮子，不引入第三方库。然后咱还从用户侧的角度考虑了一下把那些用户可能遇到的使用体验不友好的地方全都重构了一遍（其实之前的用户体验也蛮好的，只是有那么几个可优化的地方……）。咱今年可是花了很大的精力去重新设计这个程序的代码，毕竟写一个 Demo 程序和真正的把它拿去给用户去用是两码事。起初这个程序是咱刚初学 Go 语言时，一边学 Go 的基本语法一边去糊这个程序的功能，现在一想当时咱写的程序真的很乱，设计的很难看（但起码能用），当时咱对于怎么处理 Go 的并发、怎么用 Context、接口到底是怎么用的这些一无所知，而且书本只能教给你接口、Context、Signal 是什么，但他们不会告诉你怎么在大型项目中优雅的使用它。重构完了这个项目之后尽管程序设计上依旧存在缺陷，但起码他比以前好了很多了，咱这回用了 Go 的 Channel 和 Context 更好的处理了异常和错误信息，还相对正确的使用了 Go 的 Interface 接口去设计。尽管重构后的程序功能和之前貌似没什么区别，对用户来讲改动不是很大（也就少了一些依赖，压缩包格式变了，日志的内容变了），但从代码这边基本上是完全重写了（修复了一些 bug 并引入了一些新的 bug）。咱可不希望只为了实现功能而写出丑陋的代码，因为这是开源的软件，如果有别的社区的人想做贡献时，没人愿意在丑陋的代码上耗费时间。\n所以说了这么多，咱把咱写的程序网址贴在这里，感兴趣的话就去看看：https://hangar.cnrancher.com\n游戏 今年并没打什么游戏，玩了一阵子的守望先锋，但这游戏越来越没意思了逐渐不怎么玩了，Minecraft 也没怎么玩，就偶尔空闲时间进去逛逛。同学有时候还会喊我去打一些游戏，但大多数时间咱都推掉了。\n想玩的游戏还有很多，一直想找机会二刷一遍月姬和魔法使之夜，魔夜重置版的支线咱也还没打完，还蛮期待过一阵子即将新出的月姬官方汉化和最终幻想 7 重置版的续作的。\n其他 2023 年实际上对咱来说是一个很糟糕的一年，我很烦那些不切实际的羡慕，我很反感那些对自己现状不满而总是羡慕别人的人。很多时候咱把咱好的一面展现出来而把不好的事情埋在心里，不想让别人担心，就算是生病或者心情不好到了极点咱也会发点和这些不相关的朋友圈和消息之类的，我不想向别人讲自己的烦恼和困扰，但这会给人一种 “他过得比我好，我好羡慕他” 的感觉。很多时候是咱靠着仅存的一点兴趣和爱好一个人在硬撑着，但是那种有些东西自己没有而别人有就去说风凉话的真的很恶心。很多事都不是凭空偶然发生的，特别的能力会招惹来特别的能力。嗯，不知道自己还能撑多久，也不知道自己以后会去哪里，总之就是挺喜欢橙子老师说的，“我们并不是根据背负的罪来选择道路，而是先选择道路再背负起自己的罪孽”，“所谓的 ‘逃’ 有两种，漫无目的的逃以及带有目的的逃。一般将前者称为 ‘漂浮’，后者称为 ‘飞行’”。不知道咱自己还能飞多久，也不知道自己是在故意挥动翅膀，装出自己好像在飞行的样子，实际已经坠落了呢。\n","permalink":"https://blog.starry-s.moe/posts/2024/hello-2024/","summary":"\u003cp\u003e这里没有年终总结。\u003c/p\u003e","title":"Hello 2024"},{"content":"最近遇到了一个归档文件格式选择的问题，于是顺手记录下来水一篇博客。\ntar 文件格式 tar 格式早期是为了将数据记录在磁带上的（现在貌似也可以？），这种归档格式很简单，要将一个文件写入 tar 包的时候，首先写入记录文件信息的 header，在 header 之后记录文件的数据（tar 格式不支持压缩所以是直接把文件数据拷贝在了 header 后面）。\n+--------+ | header | +--------+ | data | +--------+ | header | +--------+ | data | +--------+ ... +--------+ | header | +--------+ | data | +--------+ | end | +--------+ tar 有多种不同格式的 header。这里可以看 Linux 系统上常用的 tar 工具（GNU tar）代码， GNU tar 中实现的 header 结构定义文档参考这个 Basic Tar Format。\nGNU tar 的源码可以通过下面的方式克隆下载下来。\n$ git clone https://git.savannah.gnu.org/git/tar.git 在 src/tar.h 源码中可以找到 header 结构定义，其中 posix_header 的定义为：\nstruct posix_header {\t/* byte offset */ char name[100];\t/* 0 */ char mode[8];\t/* 100 */ char uid[8];\t/* 108 */ char gid[8];\t/* 116 */ char size[12];\t/* 124 */ char mtime[12];\t/* 136 */ char chksum[8];\t/* 148 */ char typeflag;\t/* 156 */ char linkname[100];\t/* 157 */ char magic[6];\t/* 257 */ char version[2];\t/* 263 */ char uname[32];\t/* 265 */ char gname[32];\t/* 297 */ char devmajor[8];\t/* 329 */ char devminor[8];\t/* 337 */ char prefix[155];\t/* 345 */ /* 500 */ }; 上面 header 结构可以看出默认情况下文件名 name 长度不能超过 99 (最后一位要存储 \\0)，但似乎后面 tar 协议支持了长文件名的情况，至于如何支持的各位感兴趣的可以自行去搜一下。\n除了 posix_header 之外，还有 star_header、gnu_header 等 header 结构，header 结构体占据的空间小于 512 字节，而 tar 的每个 block 都是 512 字节，所以一个 header block 占据 512 字节，末尾空余的字节填写 \\0，文件也以 512 字节为单位写在 header block 后面，多出来的空间填写 \\0：\n/* tar files are made in basic blocks of this size. */ #define BLOCKSIZE 512 union block { char buffer[BLOCKSIZE]; struct posix_header header; struct star_header star_header; struct oldgnu_header oldgnu_header; struct sparse_header sparse_header; struct star_in_header star_in_header; struct star_ext_header star_ext_header; }; tar 文件的 end 是由至少两个 block size （1024字节）的空白（\\0）组成，但是 GNU tar 创建出来的 tar 包的 end 长度可能大于两个 block size，因为似乎它创建的 tar 包的文件体积以 10K 为单位进行了对齐，可以用下面的方式验证一下：\n$ echo \u0026#34;hello world\u0026#34; \u0026gt; 1.txt $ tar -cv 1.txt -f test.tar 1.txt $ ls -al test.tar -rw-r--r-- 1 starry-s starry-s 10K Nov 12 11:42 test.tar 用 hexdump 可以看一下创建的 tar 包中包含的数据：\n$ hexdump -C ./test.tar 0000000 1 . t x t \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 0000010 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 * 0000060 \\0 \\0 \\0 \\0 0 0 0 0 6 4 4 \\0 0 0 0 1 0000070 7 5 0 \\0 0 0 0 1 7 5 0 \\0 0 0 0 0 0000080 0 0 0 0 0 1 4 \\0 1 4 5 2 4 0 4 5 0000090 3 5 4 \\0 0 1 2 1 1 2 \\0 0 \\0 \\0 \\0 00000a0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 * 0000100 \\0 u s t a r \\0 s t a r r y - 0000110 s \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 0000120 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 s t a r r y - 0000130 s \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 0000140 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 * 0000200 h e l l o w o r l d \\n \\0 \\0 \\0 \\0 0000210 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 \\0 * 0002800 其中前 0x200 长度 (512 bytes) 存储的是 header，0x200 ~ 0x2800 (10240 bytes) 区域存储了文件的数据 (hello world\\n)，文件数据后面均为空白 \\0，整体的 tar 包文件大小对齐到了 10K。\n栗子 因此这里可以用上面的 posix_header 结构体简单的写一个创建 tar 归档的程序。\n因为 header 中还包含了简易的计算 header 校验和的步骤，所以代码比较长，可以在 这里 找到。\n压缩 在创建 tar 格式的文件时是不支持压缩的，文件的数据直接写在了 header 后面（除非你想魔改创建 tar 格式的步骤，但没这个必要）。如果需要压缩的话是把整个 tar 归档用 gzip/bzip2/zstd 等其他压缩格式进行压缩，文件后缀为 tar.gz/tar.bz2/tar.zstd 等。因为是先将文件写入 tar 归档，再将 tar 归档进行压缩，所以压缩的效果会比把文件单独压缩再合并成一个 tar 包效果要好一些。\n特点 从上面的 tar 归档文件格式可以看出，tar 包中的文件是一个一个顺序排列起来的，因此 tar 包中是允许两个相同名称的文件存在的。\n如果想向 tar 包末尾附加新的文件的话也很简单，只需要找到末尾的 end block，将其覆盖重写新的文件的 header，之后再写入新文件的数据即可，因此向未压缩的 tar 包附加新的文件（甚至是覆盖掉末尾的一些文件）都是可行的。但是如果想向已压缩的 tar 包（例如 tar.gz）附加文件就不太可行了，除非先把 tar.gz 解压为 tar 格式，附加新的文件后再重新压缩成 tar.gz，但这样如果 tar 文件体积很大的话会造成额外的磁盘空间浪费和性能、时间的浪费。\n还有一点是 tar 中存储的文件是顺序排列起来的，但他没有一个 index 索引记录了每个文件的 header 所处的 offset。所以如果想知道一个 tar 包里面存了哪些文件的话，要从头到尾的遍历一遍 tar 包，因此如果这个 tar 包文件体积很大且包含很多零散的小文件的话，每次都要遍历读取 tar 包中的所有 header，会很麻烦。\n因此 tar 包不适合随机读取，未压缩的 tar 包还好，只要在首次打开文件时遍历一下把每个文件的 header 和 offset 记录下来就行，但如果是压缩过的例如 tar.gz 格式的压缩包，几乎就没办法随机读取（除非你得再去折腾 gzip 数据流，但几乎没人去这么做），如果想随机解压 tar.gz 中的某个文件，要从头开始先解压 gzip 数据流，从解压的数据流中遍历每个 tar header，在查找到待解压的文件 header 后再将其解压存储下来，麻烦得很！\n所以 tar 以及 tar.gz 等压缩的 tar 归档格式通常适合用在不需要随机读取，不需要向归档末尾附加文件的场景。\nzip 文件格式 zip 压缩包中文件的布局也是依次顺序排列的，文件的 data 可以是未压缩的文件原始数据 (Store)，或者是使用 Deflate 算法压缩后的文件数据。 在 zip 文件末尾还有一块区域，记录了每个文件 header 的索引信息，叫做 directory (central directory record)，directory 后面还有一小块区域用来记录 directory 的长度和数量等信息 (end of central directory record)。\nzip 压缩包中文件的数据布局简单描述一下是这个样子：\n+---------------+ | header | +---------------+ | data | +---------------+ | header | +---------------+ | data | +---------------+ ... +---------------+ | header | +---------------+ | data | +---------------+ | directory | +---------------+ | directory | +---------------+ .... +---------------+ | directory | +---------------+ | directory end | +---------------+ 详细的 zip 文件格式定义在 这里，因为 zip 包中，每个文件的 header 长度是不固定，而且还分为早期的 zip 和后续新增的 zip64 两种格式，手搓代码还蛮复杂的，图省事咱就不写样例代码了。\n特点 所以 zip 格式支持随机读取，如果想知道 zip 中存储了多少文件的话，只需要读取文件末尾的 directory。和 tar 一样 zip 也允许存在多个重名的文件。 而 zip 中存储的文件如果压缩的话，是每个文件单独压缩再写入到 zip 归档的，所以压缩的效果会较 tar 把所有文件都打包到一起再压缩要差些。\n如果想向已有的 zip 压缩包中增加新的文件，需要将新文件 header 和数据从 directory 处覆盖掉，最后重新在文件末尾写入新的 directory record。\n所以 zip 看起来比 tar 格式要更灵活一些，支持随机读取，同时还支持在不解压整个压缩包的情况下，增加新的文件。\nzip 支持 Deflate 压缩算法或 Store 不压缩仅存储文件原始数据这两种方式。Deflate 压缩算法与 gzip 使用的 Deflate 压缩算法是一个东西。区别就是 zip 是把文件单独用 Deflate 算法压缩，存储起来，而 tar.gz 是将所有文件先打包到一起，再用 Deflate 算法压缩。\n背景 上面说了这么多，zip 和 tar 的区别读着应该都已经清楚了。下面咱讲一下为什么要调查这个问题，写这篇博客，不感兴趣的话可以浏览器右上角关掉这个页面节省时间。\n起初是咱写了一个将容器镜像的 Blobs 文件导入/导出成一个压缩包的工具（类似 docker save/load，但是要支持多架构和多平台一起导出）（关于这个工具等咱逐渐完善后有时间的话打算单独再写一篇博客），一开始用的是 tar.gz 格式压缩。导出的逻辑是先把容器镜像的 Blobs (Layers, Manifest 和 Config) 文件先全部下载到本地，之后把这这些巨大的文件打包成一个 tar.gz 压缩包。逻辑上没什么问题，但是容器镜像普遍体积不小，尤其是要导出上百个镜像时，最后创建的 tar 包体积要几十个 GB。所以先把 Blobs 文件下载到本地占用了一次磁盘空间，再把本地未打包的 Blobs 文件打包成一个 tar 包又占用了一次空间。最后搞得磁盘被占据了双倍的空间。\n这还不算什么，如果在导出容器镜像时有时会遇到网络问题或其他因素导致某些镜像 Blobs 导出失败，这样导出生成的压缩包是一个不完整的 tar.gz 包，而咱想向已有的 tar.gz 包附加新的镜像 Blobs 文件的话就得把原有的压缩包解压，写入新的文件，再重新打包，体验极其不友好，咱自己用还行，但要是想把工具拿给别人用的话，光是给别人讲背后的逻辑就得磨叽半天，而且本来一个命令就能解决的问题却非要拆成先解压、再追加额外的 Blobs 文件、最后重新压缩这好几个步骤，而且很多时候因为镜像体积太大了解压和压缩很耗时，还会浪费巨多的磁盘空间，很多时候用户根本不知道要给磁盘预留这么大的空间而导致解压到一半失败了。\n所以为了解决这个问题，咱想办法在导出镜像时，采用实时写入的方式，在镜像的 Blobs 文件下载到本地后直接写入到压缩包文件中，而不是先把所有镜像的 Blobs 文件下载下来，再把下载的缓存文件夹打一个压缩包。这样导出镜像时消耗双倍磁盘空间的问题倒是解决了，而且还可以用多线程提个速。 但正如上面说的那样，tar.gz 格式的压缩包在创建完成后就没办法增加新的文件了，这期间咱想过要不换成不压缩的 tar 格式而不是 tar.gz 格式，因为大多数镜像的 Layer 文件本身是已经有 gzip 压缩的了，没必要二次压缩，但是镜像的 Config 和 Manifest 通常是未压缩的文本文件，会有一点额外体积开销。 这种方法看似可行，但因为 tar 他缺少文件索引，所以如果我想按照一份镜像列表按顺序依次将 tar 中存储的 Blobs 文件导入到镜像仓库中，就得遍历构建一遍 tar 包中的所有文件 header，程序中自行存一份索引，还是有点麻烦。\n所以最后在 Google 上搜有没有带索引、可以随机读取还支持附加文件的压缩归档文件格式时，重新熟悉了一下 zip 的结构和特点。\n因为咱的程序是用 Go 写的，Go 官方标准库提供了 archive/tar 和 archive/zip，用来创建/读取 tar 和 zip 归档。但是 Go 标准库不支持向 tar 包和 zip 包中附加额外的文件，tar 附加额外文件的方式蛮简单的所以不需要在修改标准库的基础上就能实现追加文件（只需要移除文件末尾的 end blocks）。但是 zip 想追加文件的话，就得先读取文件末尾存储的 directory 索引记录存储起来，附加完文件后再重新在文件末尾写入新的 directory 索引。\n几年前有人向 Go 提过这个 Issue，希望标准库能实现 zip append 文件的功能。 因为 Go 的 zip.Reader 是使用了 Go 的 io.ReaderAt 接口实现的，zip.Writer 是用 io.Writer 实现的。\nGo 标准库中提供的 io.ReaderAt 和 io.WriterAt 接口可以看作是参考了 POSIX 协议的 C 接口 pread/pwrite（Go 的 Interface 和这个系统调用的 Interface 不是一个东西），pread 可以读取文件中指定 offset 和长度的数据，并不改变文件自身的 seek offset。因为读取 zip 文件时要先读取文件末尾的 directory，所以用 io.ReaderAt 接口实现很合理。而创建 zip 文件时，要按顺序写入文件 header 和 data，最后在文件末尾写入 directory 信息，所以用 io.Writer 也很合理。\n但是如果想向 zip 附加文件的话，就得先用一个类似 io.ReaderAt 接口读取文件末尾已有的 directiory 记录，之后用类似 io.WriterAt 接口向文件末尾的位置写数据。而偏偏 Go 标准库没有 io.ReadWriterAt 这样的接口（就是把 io.ReaderAt 和 io.WriterAt 结合一起），所以最终这个 Issue 因为需要涉及到 Go 其他 io 接口的改动而无法实现关闭掉了。这里额外补充一下，Go 的 zip 标准库是用来对数据流进行操作的，而并非单纯的 zip 文件，所以只要实现了 io.ReaderAt 接口的“对象”都可以被 zip 库“解压”，所有实现了 io.Writer 的“对象”都可以写入 zip 数据。\n所以最后没办法，为了能够让咱写的工具支持在不解压 zip 文件的前提下增添新的文件的功能，只能自行造轮子，在 Go archive/zip 标准库的基础上增加了一个 zip.Updater。因为 Go 他确实没有 io.ReadWriterAt 这样的接口，但是 Go 他有 io.ReadWriteSeeker 这个接口，所以在不涉及到多线程竞争访问（或者加锁）的情况下，可以用这个接口实现 zip.Updater，向 zip 包附加额外文件的功能。\n在搞这些东西的时候刚好赶上公司的 HackWeek，本来咱已经创建了一个 HackWeek Project，就是上面咱说的容器镜像导入/导出工具的开发这些事情。所以咱在这个基础上又创建了一个新的 HackWeek Project，就是在 Go archive/zip 标准库基础上新增 zip.Updater 相关功能，链接我扔在 这里，感兴趣的话可以去瞅瞅。\n最终咱实现了 Updater 的代码仓库在 这里，感兴趣的可以去看看，点个 star 什么的。因为基于 io.ReadWriteSeeker 实现的 zip.Updater 并不是最优解，最正确的方式是 Go 什么时候出一个类似 io.ReadWriterAt 接口，在不用改变 Seek 的前提下就能读取/写入指定 offset 的数据，加上自认为咱的程序设计水平还赶不上 Go 维护者，所以咱想了一下就还是先不提 PR 给 Go 源码仓库了。\n","permalink":"https://blog.starry-s.moe/posts/2023/zip-tar/","summary":"\u003cp\u003e最近遇到了一个归档文件格式选择的问题，于是顺手记录下来水一篇博客。\u003c/p\u003e","title":"如何选择 zip 和 tar 文件格式"},{"content":"磁盘的扩容和分区的扩/缩容场景很常见，比如分区用着用着快满了，而磁盘有空闲的未分区空间，而这块区域恰好在这块分区的后面，这时可以对分区扩容。 在使用虚拟机（例如 QEMU）时，假设起初虚拟机的磁盘只创建了 20G，但用久了会存在不够用的情况，这时可以对磁盘扩容，之后再调整分区的大小。\n但是最近遇到了一个需要对磁盘缩容的场景，例如把一个 64G 的 U 盘用 dd 将整个磁盘的数据写入到一个 8G 的 U盘中（当然这个 64G U盘实际使用的分区大小不能大于前 8G）。 或者要把一个原本 50G 的 qcow2 虚拟磁盘缩小成 10G，用来制作别的镜像什么的。\n按照正常的思路，缩小磁盘空间之前要先缩小分区（还要缩小文件系统），确保分区都位于磁盘的前面，这样磁盘在截断后文件系统不会受损，大致步骤可以分为：\n缩小文件系统：例如使用 btrfs filesystem resize 缩小 BTRFS 文件系统至待缩小的分区的大小，确保文件系统的大小不超过分区大小。\n缩小分区：可以使用 fdisk 先删掉待缩小的分区，之后再重新创建新的分区，重建分区时设定新的分区的大小，且不要删除已有的 btrfs 或其他文件系统签名。这样在缩小分区的同时，不需要重新格式化，因此分区中的文件没有丢失。\n（除了 fdisk，还可以用 sfdisk，gdisk 或 parted 等工具调整分区）\n确保分区都位于磁盘的起始位置后，执行磁盘缩小的操作，将磁盘末端未使用的数据截断。\nGPT / MBR 分区表咱凭感觉来猜的话，是存储在磁盘的起始位置的，所以如果磁盘缩小时，将磁盘末端一些数据截断正常情况下应该是不会影响到存储在起始位置的分区表的。\n但是，在一些情况下，会出现缩小完磁盘空间后分区表受损的情况。\n举个栗子 首先使用 qemu-img create 创建一块 10G 的 QEMU 虚拟机磁盘。\n$ qemu-img create -f qcow2 disk1.qcow2 10G Formatting \u0026#39;disk1.qcow2\u0026#39;, fmt=qcow2 cluster_size=65536 extended_l2=off compression_type=zlib size=10737418240 lazy_refcounts=off refcount_bits=16 使用 qemu-nbd 工具将 qcow2 磁盘镜像与 Linux 内核通过 nbd 连接，这样可以在不启动 QEMU 虚拟机的情况下直接对 qcow2 磁盘分区进行操作。\n加载 nbd 内核模块，其中 max_part 参数是磁盘允许的最大分区数，默认为 0 所以这里需要把数值改大一点。\n$ sudo modprobe nbd max_part=8 将创建的 disk1.qcow2 镜像与 /dev/nbd0 连接。\n$ sudo qemu-nbd -c /dev/nbd0 ./disk1.qcow2 $ lsblk /dev/nbd0 NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS nbd0 43:0 0 10G 0 disk 使用 fdisk 初始化 GPT 分区表，并随便新建几个分区。\n咱都是 Arch Linux 用户了，fdisk 就不用我再详细说了吧。\n$ sudo fdisk /dev/nbd0 Welcome to fdisk (util-linux 2.39.2). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Device does not contain a recognized partition table. Created a new DOS (MBR) disklabel with disk identifier 0xf5c43a4b. Command (m for help): g Created a new GPT disklabel (GUID: 2EB767AB-0958-461B-B56D-697B3305AC83). Command (m for help): n Partition number (1-128, default 1): First sector (2048-20971486, default 2048): Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-20971486, default 20969471): +512M Created a new partition 1 of type \u0026#39;Linux filesystem\u0026#39; and of size 512 MiB. Command (m for help): t Selected partition 1 Partition type or alias (type L to list all): 1 Changed type of partition \u0026#39;Linux filesystem\u0026#39; to \u0026#39;EFI System\u0026#39;. Command (m for help): n Partition number (2-128, default 2): First sector (1050624-20971486, default 1050624): Last sector, +/-sectors or +/-size{K,M,G,T,P} (1050624-20971486, default 20969471): Created a new partition 2 of type \u0026#39;Linux filesystem\u0026#39; and of size 9.5 GiB. Command (m for help): w The partition table has been altered. Calling ioctl() to re-read partition table. Syncing disks. 本栗中，磁盘新建了两个分区，/dev/nbd0p1 是 512M 大小的 EFI 分区，剩余空间 /dev/nbd0p2 是 root 分区。\n$ sudo fdisk -l /dev/nbd0 Disk /dev/nbd0: 10 GiB, 10737418240 bytes, 20971520 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: gpt Disk identifier: 2EB767AB-0958-461B-B56D-697B3305AC83 Device Start End Sectors Size Type /dev/nbd0p1 2048 1050623 1048576 512M EFI System /dev/nbd0p2 1050624 20969471 19918848 9.5G Linux filesystem 之后简单的格式化一下两个分区，挂载并往里面写一些文件进去。\n$ sudo mkfs.vfat -F 32 /dev/nbd0p1 mkfs.fat 4.2 (2021-01-31) $ sudo mkfs.btrfs /dev/nbd0p2 btrfs-progs v6.5.2 See https://btrfs.readthedocs.io for more information. Performing full device TRIM /dev/nbd0p2 (9.50GiB) ... NOTE: several default settings have changed in version 5.15, please make sure this does not affect your deployments: - DUP for metadata (-m dup) - enabled no-holes (-O no-holes) - enabled free-space-tree (-R free-space-tree) Label: (null) UUID: a5fb30e5-eb5f-4a0b-8d2a-106e04e1488b Node size: 16384 Sector size: 4096 Filesystem size: 9.50GiB Block group profiles: Data: single 8.00MiB Metadata: DUP 256.00MiB System: DUP 8.00MiB SSD detected: yes Zoned device: no Incompat features: extref, skinny-metadata, no-holes, free-space-tree Runtime features: free-space-tree Checksum: crc32c Number of devices: 1 Devices: ID SIZE PATH 1 9.50GiB /dev/nbd0p2 $ mkdir -p mnt $ sudo mount /dev/nbd0p2 mnt $ sudo mkdir ./mnt/{boot,home} $ sudo mount /dev/nbd0p1 mnt/boot $ sudo touch ./mnt/example.txt 使用 btrfs filesystem resize 缩小 root 分区中的 BTRFS 文件系统大小至 7G，之后使用 fdisk 缩小 root 分区大小至 7G。\n$ sudo btrfs filesystem resize 7G mnt Resize device id 1 (/dev/nbd0p2) from 9.50GiB to 7.00GiB $ sudo sync $ sudo umount -R ./mnt $ sudo fdisk /dev/nbd0 Welcome to fdisk (util-linux 2.39.2). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Command (m for help): d Partition number (1,2, default 2): 2 Partition 2 has been deleted. Command (m for help): n Partition number (2-128, default 2): First sector (1050624-20971486, default 1050624): Last sector, +/-sectors or +/-size{K,M,G,T,P} (1050624-20971486, default 20969471): +7G Created a new partition 2 of type \u0026#39;Linux filesystem\u0026#39; and of size 7 GiB. Partition #2 contains a btrfs signature. Do you want to remove the signature? [Y]es/[N]o: N Command (m for help): w The partition table has been altered. Calling ioctl() to re-read partition table. Syncing disks. $ sudo fdisk -l /dev/nbd0 Disk /dev/nbd0: 10 GiB, 10737418240 bytes, 20971520 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: gpt Disk identifier: 2EB767AB-0958-461B-B56D-697B3305AC83 Device Start End Sectors Size Type /dev/nbd0p1 2048 1050623 1048576 512M EFI System /dev/nbd0p2 1050624 15730687 14680064 7G Linux filesystem 调整完分区大小后，因为这里没有移除 BTRFS 签名，所以分区的文件没有被删除，执行 lsblk -no NAME,UUID /dev/nbd0 可以看到 /dev/nbd0p2 的 UUID 也没有变化，和上面执行 mkfs.btrfs 时输出的一致。\n$ lsblk -no NAME,UUID /dev/nbd0 nbd0 ├─nbd0p1 C6B7-EF70 └─nbd0p2 a5fb30e5-eb5f-4a0b-8d2a-106e04e1488b 断开 NBD 连接，缩小 qcow2 磁盘大小到 8G。\n$ sudo qemu-nbd -d /dev/nbd0 /dev/nbd0 disconnected $ qemu-img resize ./disk1.qcow2 --shrink 8G Image resized. 重新将 qcow2 磁盘连接到 /dev/nbd0，会发现上面创建的磁盘中的几块分区不见了！\n$ sudo qemu-nbd -c /dev/nbd0 ./disk1.qcow2 $ sudo fdisk -l /dev/nbd0 GPT PMBR size mismatch (20971519 != 16777215) will be corrected by write. Disk /dev/nbd0: 8 GiB, 8589934592 bytes, 16777216 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x00000000 Device Boot Start End Sectors Size Id Type /dev/nbd0p1 1 16777215 16777215 8G ee GPT fdisk 输出中包含一条错误提示：GPT PMBR size mismatch (20971519 != 16777215) will be corrected by write.，大致意思是 GPT 分区表中记录的区块数量 (sectors) 和磁盘实际的区块数不一致。\n修复受损的分区表 所以修复上面栗子中受损的 GPT 分区表的办法是，重新建一个 GPT 分区表，并按照之前的分区位置，重建分区。\n这里重建分区时要注意，需要输入精确的区块位置，而不是类似 +50M 这样模糊的值。\n$ sudo fdisk /dev/nbd0 Welcome to fdisk (util-linux 2.39.2). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. GPT PMBR size mismatch (20971519 != 16777215) will be corrected by write. Command (m for help): g Created a new GPT disklabel (GUID: 3C587DB1-5978-45D2-AB05-9135D273D06D). The device contains \u0026#39;PMBR\u0026#39; signature and it will be removed by a write command. See fdisk(8) man page and --wipe option for more details. Command (m for help): n Partition number (1-128, default 1): First sector (2048-16777182, default 2048): Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-16777182, default 16775167): 1050623 Created a new partition 1 of type \u0026#39;Linux filesystem\u0026#39; and of size 512 MiB. Partition #1 contains a vfat signature. Do you want to remove the signature? [Y]es/[N]o: N Command (m for help): n Partition number (2-128, default 2): First sector (1050624-16777182, default 1050624): Last sector, +/-sectors or +/-size{K,M,G,T,P} (1050624-16777182, default 16775167): 15730687 Created a new partition 2 of type \u0026#39;Linux filesystem\u0026#39; and of size 7 GiB. Partition #2 contains a btrfs signature. Do you want to remove the signature? [Y]es/[N]o: N Command (m for help): t Partition number (1,2, default 2): 1 Partition type or alias (type L to list all): 1 Changed type of partition \u0026#39;Linux filesystem\u0026#39; to \u0026#39;EFI System\u0026#39;. Command (m for help): w The partition table has been altered. Calling ioctl() to re-read partition table. Syncing disks. 重建分区表后，不出意外的话，重新挂载分区是能访问分区中的文件的，分区的 UUID 也没有发生改动。\n$ lsblk -no NAME,UUID /dev/nbd0 nbd0 ├─nbd0p1 C6B7-EF70 └─nbd0p2 a5fb30e5-eb5f-4a0b-8d2a-106e04e1488b $ sudo -l fdisk /dev/nbd0 Disk /dev/nbd0: 8 GiB, 8589934592 bytes, 16777216 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: gpt Disk identifier: 3C587DB1-5978-45D2-AB05-9135D273D06D Device Start End Sectors Size Type /dev/nbd0p1 2048 1050623 1048576 512M EFI System /dev/nbd0p2 1050624 15730687 14680064 7G Linux filesystem $ sudo mount /dev/nbd0p2 mnt $ sudo mount /dev/nbd0p1 mnt/boot $ ls -alh mnt total 20K drwxr-xr-x 2 root root 4.0K Jan 1 1970 boot -rw-r--r-- 1 root root 0 Oct 18 22:36 example.txt drwxr-xr-x 1 root root 0 Oct 18 22:34 home sfdisk 备份分区表 如果觉得重建分区表时，分区的位置记不住的话（废话正常人谁能背下来这一串数字），sfdisk 的 --dump 参数可以备份分区表。\n$ sudo sfdisk --dump /dev/nbd0 label: gpt label-id: 3C587DB1-5978-45D2-AB05-9135D273D06D device: /dev/nbd0 unit: sectors first-lba: 2048 last-lba: 16777182 sector-size: 512 /dev/nbd0p1 : start= 2048, size= 1048576, type=C12A7328-F81F-11D2-BA4B-00A0C93EC93B, uuid=496140B3-C491-470B-98D7-BB95F55266A7 /dev/nbd0p2 : start= 1050624, size= 14680064, type=0FC63DAF-8483-4772-8E79-3D69D8477DE4, uuid=F918E93D-FB1D-4652-9657-CE24A29ADEA5 在执行磁盘缩小操作之前，可以先使用 sfdisk 导出分区表，缩小磁盘后再恢复。\nBackup partition table $ sudo sfdisk --dump /dev/nbd0 \u0026gt; nbd0.txt Remove the `last-lba` line $ grep -v last-lba nbd0.txt \u0026gt; partition-backup.txt After shrinking the disk size... Restore the backup partition table $ sudo sfdisk /dev/nbd0 \u0026lt; partition-backup.txt ","permalink":"https://blog.starry-s.moe/posts/2023/fix-shrunken-disk-broken-partition-table/","summary":"\u003cp\u003e磁盘的扩容和分区的扩/缩容场景很常见，比如分区用着用着快满了，而磁盘有空闲的未分区空间，而这块区域恰好在这块分区的后面，这时可以对分区扩容。\n在使用虚拟机（例如 QEMU）时，假设起初虚拟机的磁盘只创建了 20G，但用久了会存在不够用的情况，这时可以对磁盘扩容，之后再调整分区的大小。\u003c/p\u003e\n\u003cp\u003e但是最近遇到了一个需要对磁盘缩容的场景，例如把一个 64G 的 U 盘用 \u003ccode\u003edd\u003c/code\u003e 将整个磁盘的数据写入到一个 8G 的 U盘中（当然这个 64G U盘实际使用的分区大小不能大于前 8G）。\n或者要把一个原本 50G 的 qcow2 虚拟磁盘缩小成 10G，用来制作别的镜像什么的。\u003c/p\u003e","title":"修复缩小磁盘空间后受损的 GPT 分区表"},{"content":"今年的六月初的时候赶着 618 活动入手了 Kobo Libra 2 电纸书，距离上次博客更新刚好过去一个月，想于是想着把 Kobo Libra 2 安装 KOReader 踩坑的记录写在这里刚好可以水一篇博客。\n这首歌很魔性……\nKOReader\nKobo 安装 KOReader 的教程可以参照 KOReader Wiki。\nImportant Notes 首先把 Kobo 连接到电脑，用文本编辑器打开 .kobo/Kobo/Kobo eReader.conf，确保存在以下配置文件，禁止阅读器加载隐藏文件夹中的内容：\n[FeatureSettings] ExcludeSyncFolders=(\\\\.(?!kobo|adobe).+|([^.][^/]*/)+\\\\..+) Manual Installation Methods 按照手动安装 KOReader 的步骤，有两种安装方式可选择：\n第一种是在 KFMon 的基础上安装 KOReader，需要先安装 KFMon，安装 KFMon 的教程以及文件的下载连接在这里。\n除此之外另一种安装方法是基于 NickelMenu 的方式安装 KOReader。\n这里咱使用的是第二种基于 NickelMenu 的方式安装 KOReader。\n首先下载 NickelMenu 的 KoboRoot.tgz 安装包，像升级系统那样把压缩包拖到 .kobo 文件夹内，弹出 USB 后 Kobo 会自动重新更新。安装完成后 Kobo 右下角菜单栏会多一个 NickelMenu 菜单。\n在 此处 下载 KOReader 安装包，因为 Libra 2 等使用相似主板的电子书存在死机重启的不稳定 Bug 建议先下载包含修复此问题的 nightly build（参考 Issue），文件名以 koreader-kobo 开头的为 Kobo 使用的安装包。\n再次将 Kobo 连接到电脑，将 KOReader 安装包解压到 .adds 目录下。\n新建 .adds/nm/koreader 文件，写入以下内容：\nmenu_item:main:KOReader:cmd_spawn:quiet:exec /mnt/onboard/.adds/koreader/koreader.sh 弹出 USB，等待设备同步完数据后，就可以在 Kobo 的右下角菜单栏中启动 KOReader 了。\nKnown Issues 使用过程中只遇到一个 KOReader 的严重影响体验的问题，就是上面说的阅读过程中会经常死机重启，可以在 这篇 Issue 跟踪进度，目前可以尝试使用 这个 Patch，安装 nightly build 的安装包尝试解决。\nOthers 贴几张看电纸书的效果图供参考，Kobo 的显示效果比咱之前用过的 KPW4 好太多了。图书的话基本是从网络上找盗版资源了，KOReader 能够对 PDF 重排所以对 PDF 的支持效果也比 Kindle 好很多。\n","permalink":"https://blog.starry-s.moe/posts/2023/kobo-libra-2/","summary":"\u003cp\u003e今年的六月初的时候赶着 618 活动入手了 Kobo Libra 2 电纸书，距离上次博客更新刚好过去一个月，想于是想着把 Kobo Libra 2 安装 KOReader 踩坑的记录写在这里刚好可以水一篇博客。\u003c/p\u003e","title":"Kobo Libra 2 安装 KOReader"},{"content":" 找不到答案的时候就去看看这个世界。\n一些流水帐 容我先写一点流水帐…… 咱的习惯是因为这种旅行都十分的珍贵所以咱想把旅行的全部经过都记录到博客里，尽管纯文字给别人的观感不是很好但咱还是想把这些都写出来。\n一开始是没打算去 BW 的，计划是只去一趟 BML 就行，所以一开始咱没抢 BW 门票。过几天后 B 站公开了 BML 的消息，然后得知了今年的 BW 和 BML 是赶在一起举办的。于是咱抱着试一试的心态去抢 BML 的门票，第一次大会员优先抢票咱没抢到，于是当天晚上试着从 380 到 1500 的票档依次反复尝试点击抢票后，最终抢到了 1200 的内场票（内心在滴血），本来以为抢不到的，结果出乎意料的被迫忍痛斥巨资去看 BML 内场。然后就是 BML 门票抢到了，因为今年的 BW 和 BML 是在同一时间段举行，得知 BW 还有最后一次抢票机会，不去白不去后，最终抢到了一张 23 号的 BW 门票。然后蹲了好几天的 12306 候补沈阳到上海的卧铺票，结果最终还是没能抢到去上海的卧铺。由于机票和高铁票价格差不多，但高铁要坐十多个小时，所以蹲了几天卖机票的平台后最终以比较便宜的价格买到了沈阳往返上海的半夜机票。\n然后是 20 号晚上从沈阳桃仙机场坐飞机去上海，中间经停山东烟台蓬莱机场，被飞机空调冻了一路后在上海普通国际机场 T2 航站楼出发层的沙发睡了一晚（19 年的十一假期也是在这过夜的所以位置咱都记下来了）。21 号早晨七点被吵醒后买了一杯星巴克冰美然后一边回忆四年前去上海时的记忆一边坐地铁 2 号线（当时坐的是磁悬浮）。由于没抢到 21 和 22 号的 BW 门票所以上了 2 号线后咱也不知道该坐到哪里，最终是从 2 号线的始发站坐到了终点站，虽然没买到 BW 门票但是去了 BW 四叶草场馆外面走了两圈，最终实在进不去加上被热得受不了了，不得不从黄牛手里搞了一张邀请函才进去（别学，不要买黄牛手里的邀请函，原因后面会讲）。当天晚上快 5 点的时候上海西边下了大暴雨，由于觉得 5 点闭展的时候再去排队挤地铁一定会排很长时间，于是咱在不到 5 点的时候就早早的去地铁站门口排队了。当时尽管外面雨蛮大的但是场馆内还是很干，地铁口排队的地方用围挡围了十几个弯，然后排队的地方没有空调，在那里排了好长的队后差点没热昏过去。然后由于当天大暴雨出地铁站后打不到车，所以出地铁站后被迫淋着雨从地铁站骑共享单车到旅店，所以 21 号那天从浦东机场到国展中心四叶草再到后来回旅店一共走了 2.8W 步，晚上在手机看到了 BW 场馆部分露天过道被淹的消息，内心狂喜幸好我跑得早。\n22 号因为前一天腿差点走断了，于是上午是在旅店休息，下午去了一些上海其他比较知名的二次元打卡点。首先去了南京东路地铁口旁边的什么大药丸商场的 Square Enix 咖啡厅，没买咖啡，单纯的去拿相机给咖啡店摆的周边拍照。看了 FF7 和尼尔的一堆手办和纪念品，之后坐地铁去上海的外文书店。当天外文书店顶楼日文部分的人蛮多的，基本是被二次元攻占了，在书店绕了好几圈后找到了 Fate 画册（还是中文版），于是毫不犹豫的把它买了下来，塞到背包里。由于是画册，这本书巨大而且特别厚+沉。背着巨沉的背包后接着出发去梅赛德斯奔驰文化中心，BML 结束后随着人流和 19 年时一样，徒步走到中华艺术宫的下一个地铁站坐地铁回去。于是 22 号走了 1.4W 步，赶在地铁末班车停运前回到了旅店。\n23 号稍微睡了个懒觉后坐地铁去 BW，出地铁后绕了几个大弯排队后，在 BW 的检票炸鸡处被拦了下来，之后找现场的工作人员，在一顿十分尴尬的调查，被关了半个小时后终于把我放了进去（所以说不要买黄牛手里的邀请函！我再也不敢了55555……）进 BW 场馆时已经是十一点多了，由于在检票口被拦了半个小时，心情有点低落，所以一开始逛展时心情并不是很好。从 8 号厅挤到 4 号厅后找到了 21 号咱没找到的 Aniplex 展台，然后隐约的感觉有很多手办和展品 21 号那天没有摆出来。之后就是平复心情拿着相机挤在人堆里拍手办，然后去每个展台领无料（领了一堆袋子，尤其是英特尔的那个超大号麻袋）。晚上继续从 2 号线始发站坐到终点站去普通国际机场，中间在南京东路下车又去了一趟那个 Square Enix 咖啡厅，买了个 FF7 的音乐盒当纪念品。半夜飞回沈阳后，被沈阳的出租车司机唠了一路（还因为我住浑南吓唬我嫌我离得近想把我凌晨一点扔半路高架桥上）（实际是开玩笑但刚从南方回来还是不太适应这么爱唠嗑的司机）。23 号走了 1.7W 步。\n之后的几天回老家去了趟亲戚的婚礼，然后还没来得及休息，就 27 号和朋友一起去了吉林长春。27 号下午去了长春的这有山商场和桂林路市场，晚上去了南湖公园的长春解放纪念碑喂蚊子，因为连续好几天睡眠不足，当天晚上是回到酒店洗漱后倒头就睡了。第二天和朋友一起去了长春的兽聚，路上坐了长春的轨道交通（本来以为是地铁，结果发现长春的轨道交通非常日系，但是属于轻轨的那种，车型和沈阳浑南的有鬼电车好像是一样的，但不同的是长春的轨道交通的地面段是被栅栏围起来的，有独立的路权，不用等红绿灯，也不会遇到轻轨被汽车撞出轨等侵线情况）（长春的轨道交通没有屏蔽门，因为按级别划分来说是属于轻轨……）。在兽聚当一个野生摄影师给许多兽兽拍了巨多的照片，录了一些视频，然后一天过后非常非常的累，晚上 11 点眼睛就睁不开了，在兽聚的床位倒头就睡，再睁眼时已经是早晨 7 点了。\n29 号回沈阳，下午回公寓后用电脑把咱这几天拍的一大堆照片导到电脑里并做了备份并给这几天拍到的小动物加好友返图。晚上是瘫在床上一动不动了……\n没人疼就去漫展，逛完浑身疼。\n30 号一早起床出发去沈阳 SSCA 漫展，与今年前几次 SSCA 漫展不同，这次 SSCA 在 K11 的展厅举行（终于不是之前冬冷夏热的铁西区四维大仓库了），当天漫展人巨多（给 K11 一点小小的二刺猿震撼），咱依旧是在漫展当野生摄影师给别人拍照。之后晚上去的沈阳站坐高铁回沈阳南站。经过了一个多星期的特种兵旅行，孩子被彻底累瘫了，所以是休息了好几天才有力气去写博客，因为旅行的内容量实在太大了，一时半会写不完，所以这次的博客就先以流水帐的方式写了。\n一些照片 Bilibili World 2023 首先是一些在 BW 拍到的 Coser 和手办（以及第一天的暴雨）。\n上面是 D1 下午拍到的暴雨，其实 D1 还拍了一些其他的照片但懒得放在这里了，下面是 D3 拍的手办和 Coser。\n（然后咱就因为 Aniplex 展台这边站着的这只 bocchi 酱去看了《孤独摇滚！》……）\nBilibili Macro Link 2023 然后是在 BML 拍的一点照片，因为是在内场靠后排的位置，镜头一半都被前面的人挡住了，所以观感还不如看台效果好（下次坚决不买内场票了），大部分时间都在应援所以只拍了一点点照片。\nSquare Enix Coffee 在 SE 咖啡厅拍的周边什么的（官方的手办的脸属实是有点崩……幸好没买……）。\n（虽然看不懂，但是好活……\n长春·疯狂一夜 在长春的小聚上拍到的一些大福瑞们，这大热天的在户外穿貂真挺不容易的，当天有见到（并 rua 到）了很多大佬，十分开心。\n沈阳 SSCA 9th Day3 其他 因为在外文书店只拍了一张照片（书店有什么好拍的……），所以放在这里了。\n外文书店\n买的 Fate 画册还送了几张明信片，回家后拆开一看感觉光是这几张明信片就已经值画册的售价了……\n","permalink":"https://blog.starry-s.moe/posts/2023/2023-07-20/","summary":"\u003cblockquote\u003e\n\u003cp\u003e找不到答案的时候就去看看这个世界。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"七月末的短暂旅行小记"},{"content":"这个 Minecraft 存档是咱在 2020 年年初的时候建立的，起初是 1.15.2 单机生存，当时在 B 站学着 TIS 以及其他生电服的思路安装了一些生存辅助插件，后来升级到了 1.16.5，并在去年年底迁移到了我的 NAS 上改成了私人服务器。尽管玩了三年多的时间了但我从来没详细的在博客上记录这个存档，只有在前几年的年终总结中提到过“我在玩 Mincraft，今年建了什么建筑……”，眼瞅着三周年已经过去了，本来想录个纪念视频发 B 站上的，但因为太懒、不想学视频剪辑，这个计划一直咕咕了，不过最近想到可以把存档截图放博客里作为三周年纪念。\n出生点空置域 出生点空置域\n出生点已经被咱炸成空置域了，当时是在 2020 年花了几天的时间用三向轰炸机清理的空置域，y11 高度以下的岩浆并不碍事所以没有清理，现在的出生点空置域有一个收集末地刷沙机的简单收集装置（以后打算改成自动分类+潜影盒收集装置），橙色的建筑是地铁出生点站，图片右侧的是一个简易的刷鱼农场，主要靠这个农场获取墨鱼的黑色染料。\n原点空置域 原点\n原点空置域是咱的第二个空置域，之所以叫原点是因为空置域的中心座标为 (x:0, z:0)，原点空置域里只有一个全物品（垃圾桶）分类装置，这个原点空置域我记得是 2021 年用三向炸的，全物品也是在 21 年上半年建的，现在全物品已经全部完工并正常使用了，不过这个全物品目前只收集了一半左右的可堆叠物品，因为有许多物品在单人生存中很少用到。\n全物品垃圾桶右边蓝色圆形的建筑是地铁原点站，顶上是一个仅装饰作用的“停机坪”。\n全物品分类是这个存档里工程量最大的机器，当时建全物品时特地新建了一个村民交易所，买了巨多的石英和红石、萤石等建筑材料，清理水道时也花了巨长的时间。\n生存基地 生存时第一个建造的房子\n由村庄改造的庭院\n生存基地俯瞰\n刷铁机、工厂、地铁站\n当初建立存档后，是生存在出生点旁边的一个村庄里的，后来搬到了附近的河边，现在村庄已经没有村民了，被我改建成了一个中式的庭院。\n这个生存基地有一个简易的工厂，工厂一层是一个小型牧场和小型熔炉组和 1.15 版本能用的经验熔炉（升级到 1.16 后特性被修复了就不能用了），工厂二层有一个附魔台，三层是简易的村民交易所。工厂旁边有一个简易的刷铁机，尽管后来又盖更大的刷铁机了但这个没拆，尽管效率低点但一直能用。\n工厂侧面还有一个白桦树树场，效率蛮高的单人生存足够用了，后期的木材全是从这里获取的。生存基地的地下有一个能换乘三条线路的超大地铁站。\n1 号线站厅\n1 号线站台\n空置域线站台\n2 号线站台\n工业基地 工业基地有一个 320 超大熔炉组，然后是一个效率蛮高的刷石机和一个简易的复制铁轨的机器，地下有一个地铁工业基地站。\n320 熔炉组\n刷石机 \u0026amp; 铁轨复制机\n机场（在建） 不得不说生存修机场真的太麻烦了，时间全用来整地形了，铺混凝土倒不是很费事。现在这个机场只有一条跑道，打算建航站楼但是工程量很大，需要很长的时间整理地形，所以一直在咕咕姑中。\n地铁站 \u0026amp; 刷铁机 \u0026amp; 刷怪塔\n机场旁边的海上有一个大型的 8 核心刷铁机、一个简易的混凝土固化机和一个刷怪塔以及一个地铁站。后期建地铁等建筑的所有混凝土都是在这个混凝土固化机固化的，然后尽管这个刷铁机效率不是特别高但是单机生存勉强够用了，不够用的话就多挂机刷一会（/tick rate 200 警告）……\n摩天楼 其实这个地方我起的地名叫“三号村庄”，因为是第三个发现的村庄……\n本来计划建两个摩天楼的，但是建完一个之后，另一个楼就一直处于咕咕的状态。摩天楼旁边是一个大型的双岛式站台地铁站。\n跨海大桥 这个存档里一共有俩跨海大桥，第一个桥是 2020 年暑期时建的，第二个桥是 22 年下半年建的。\n甘蔗农场 甘蔗农场是今年上半年修建的，是一个简易的全自动甘蔗机，收集的甘蔗主要用于生成烟花火箭的原材料：纸。\n村民交易所 在修建全物品分类以及地铁站装饰时，需要大量的石英和萤石，因此修建了这个带打折的村民交易所，因为没有建袭击农场，所以目前与村民交易的绿宝石都是从村民交易所卖铁换取的，而铁是靠村民制作的刷铁机刷出来的。深刻体现了什么叫“取之于民，用之于民”的资本家思想（逃\n村民交易所旁边还有一个咱自己设计的全自动农场，但是因为咱不缺食物（可以从村民那里买金胡萝卜吃），所以这个自动农场建好后一直在闲置。\n海底神殿（守卫者农场） 生存中第一个发现的海底神殿，已经被改成了不需要清空水的袭击者农场（排水实在太麻烦了），目前所有建筑的海晶灯的原材料都是从这个农场获取的，海底神殿旁边是三号线地铁海底神殿站。\n地狱猪人农场 因为光影在地狱的效果不好所以咱把光影关掉了……\n这个猪人农场用来挂机刷经验以及获取金子，农场还包含了猪灵交易所，可以把刷取的金锭与猪灵换取石英、黑曜石、火焰弹等物品。\n地铁 这个存档里目前有三十多个已建成的地铁站，还有十多个在建的地铁站，这里贴几张咱自认为设计得比较有特点的地铁站。\n首先是这个双层侧式站台的地铁站，上层是已经建成的 2 号线，下层是正在建设的通往机场的 6 号线：\n这个是 3 号线的末地传送门站，这个站直接修在了末地要塞里，上层是地铁站台，下层是由末地要塞改造成的末地传送门入口，同时保留了要塞的书房作为该地铁站的小型图书馆：\n末地传送门 - 站台\n末地传送门 \u0026amp; 图书馆\n这个是村民交易所的地下的地铁站，用的云杉木作为柱子，还挺好看的：\n村民交易所 - 站台\n空置域西站：\n3 号线（左）、1 号线（右）\n一号线的保留了正线的侧式站台地铁站，方便甩站用（本次裂车本站不停靠）：\n南湖公园站\n一号线的地上段，弄了红石灯做了点简易的装饰：\n冰工厂站\n全物品分类旁边的原点站也很有特色，车站是圆柱体结构，两条线路十字交叉：\n原点站\n这个是二号线的车辆段，目前存档里只有二号线有车辆段（因为二号线太长了），别的线路还没有修车辆段的计划。\n以上基本是咱玩了三年的单人生存存档的全部内容了，还有些在建和小型的建筑个人认为没必要贴到这里，因为最近逐渐没有玩下去的兴趣了所以不知道以后还能不能继续坚持玩下去，所以想了一下这三年时间建的建筑蛮多的因此写到这里水一篇博客。\n","permalink":"https://blog.starry-s.moe/posts/2023/minecraft/","summary":"\u003cp\u003e这个 Minecraft 存档是咱在 2020 年年初的时候建立的，起初是 1.15.2 单机生存，当时在 B 站学着 TIS 以及其他生电服的思路安装了一些生存辅助插件，后来升级到了 1.16.5，并在去年年底迁移到了我的 NAS 上改成了私人服务器。尽管玩了三年多的时间了但我从来没详细的在博客上记录这个存档，只有在前几年的年终总结中提到过“我在玩 Mincraft，今年建了什么建筑……”，眼瞅着三周年已经过去了，本来想录个纪念视频发 B 站上的，但因为太懒、不想学视频剪辑，这个计划一直咕咕了，不过最近想到可以把存档截图放博客里作为三周年纪念。\u003c/p\u003e","title":"玩了三年的 Minecraft 生存存档"},{"content":"Controller 对初学着来说有那么亿点点抽象，虽然网络上能找到很多有关 Kubernetes Controller 的讲解，但是 Kubernetes 的学习过程往往是一个离散的而不是连续的过程。如果想弄懂 Controller 还是有蛮高门槛的，不要想着看完 Kubernetes 的文档，速成了 Kubernetes 的基本知识就去尝试写 Controller，这种操作就好比刚过完新手教程就去打高难副本，尽管能仿着 sample-controller 写一个能“跑”的 Controller，但仅仅只能做到能“跑”的程度……\n与标题有些不同，这篇博客主要讲的是萌新如何上手编写 Controller，如果你是 Kubernetes 初学者，希望这篇博客能帮助你建立编写 Controller 的学习曲线。\n前期准备 对刚接触 Kubernetes 的萌新来讲，这个体系还是蛮复杂和抽象的，只靠读文档看教程自学可不是那么容易。光是怎么安装一个 Kubernetes 集群，在不同的教程里就有无数种方法了。传统的安装 Kubernetes 的方法过于硬核，现在几乎没人选择这种方式部署集群了。咱常用的比较简单的方式有 k3s，光靠一个脚本就能在虚拟机上一键部署一个轻量级的集群，很适合萌新（前提是你没有必须用包管理器安装任何软件的强迫症），但是如果你想在国内的网络环境靠这个脚本安装 k3s 的话，需要一些参数配置国内源，这里不再赘述。除此之外还可以用 Docker 方式部署一个单节点 Rancher，Rancher 的 Web 界面可以更好的帮助萌新去管理 Kubernetes 资源（当然你还可以选择敲 kubectl 指令的方式），还有很多教程会推荐你使用 minikube，当然你可以选择任何一种方式去部署你自己的集群，只要你觉得这种方法适合你，而且部署的集群版本不要太低即可。\n如果想编写 Controller，你得有一定的 Kubernetes 基础（废话），并且熟悉 Go 语言（废话 x 2）。在看完 Kubernetes 文档，熟悉了 k8s 的资源和如何使用 kubectl 操作他们后，先别急着上手写 Controller。首先你得熟悉 client-go，client-go 的代码能在 GitHub (https://github.com/kubernetes/client-go) 中下载到，但记住它的 Go Module 为 k8s.io/client-go，不在 github.com。\n首先了解一些常见的 Kuberntes API 类型，知道 Kubernetes 的资源对象是怎么在 client-go 中用 Go 语言表示的，并如何调用 API 去管理他们（而不是仅凭 kubectl 命令行客户端去管理他们）， 这里不单单有 client-go 这一个 Git 仓库，还有 k8s.io/api, k8s.io/apimachinery 等仓库，后面写 Controller 时会经常用到这些 API。认识一下 TypeMeta 和 ObjectMeta （代码位置在这里），每个资源对象的 Go 结构中都包含这些数据（除此之外每个资源还有 Spec, Status 等），写代码时会经常用到 json/yaml 的 Marshal/Unmarshal 操作，熟悉到这个程度就可以了。\n然后是 Kubernetes 的自定义资源（Custom Resource, CR）这个概念，k8s 内置了一些 Resource 资源对象，例如 pod, deployment, service, secret 等，你可以用 kubectl 去 get/describe/create/delete... 这些资源，但如果你想往 k8s 中添加一些你自己的自定义资源，比如你想定义一个资源叫做 database，你用 kubectl create database ... 就能创建一个你自己想要的数据库，像 create pod, create secret 那样，然后还能对你的自定义资源对象进行 describe/delete/update... 等操作，就需要用到自定义资源（开发者更习惯叫他的简写 CR，以及自定义资源定义的简写 CRD）。Controller 就是用来管理这些 CRs 的。在开发 Controller 时我们需要定义 CR 中包含哪些数据，然后使用代码生成器生成资源的 DeepCopy 等方法，减少不必要的重复代码编写。\n可以不用把每个细节都尝试弄懂，把基本概念过一遍就行，学习 Kubernetes 的过程是一个离散的过程而不是连续的过程，当碰到哪个地方不明白卡住的时候直接跳过去看后面的内容就行啦~\n什么是 Controller 在上面介绍 CR 的定义时有解释 Controller 是用来管理 CR 的，比如我们执行 kubectl create database ... （实际是执行 kubectl apply -f 部署了一个 Kind 为 database 的 YAML，不能直接 create database，但这么说比较方便理解~）创建了一个 database 类型的资源，因为这个资源是我们自定义的，所以 Kubernetes 只是在 etcd 数据库中记录了：“我们创建了一个 database 资源，他的数据内容是什么什么……”，并没有进行创建数据库的操作！而 Controller 就是用来管理 Database 资源的生命周期的，比如我们 create database 之后，Controller 会发现我们新建了一个 Database 资源，然后会去创建一个 Database Deployment。当我们 delete database 时，Controller 会注意到我们删除了 Database，之后执行资源释放一系列操作。\n往简单了讲，Controller 干的事情就是对比资源当前实际的状态和我们设定的资源状态是否一致。比如这个资源定义的 replicas 为 2，但实际只有一个 Pod 在运行，Controller 就会再去创建一个 Pod 使其实际的 replicas 为 2。\n当然 Controller 实现起来比这复杂多了，可不是一个简单的 for 循环不断从 Kube API 中查询资源然后做对比这么简单，这用到了 Cache 缓存机制和 Informer 消息提醒机制，减少 Kube API 请求次数，读取内存中的状态缓存什么的，听不懂没关系，以后会懂的……\nsample-controller github.com/kubernetes/sample-controller 项目是一个样例 Controller，所有的初学者都是靠这个项目学习 Controller 的，相当于是高难副本中最简单的了，可以把这个样例 Controller 改造为自己的 Controller，用来学习。\n本篇教程以编写 database-controller 为例，按照 sample-controller 的 Controller 框架编写一个数据库的 Controller，重点在于怎么上手写 Controller，不在数据库。\n将 sample-controller 代码克隆到本地 $GOPATH 目录下：\n$ midir -p $GOPATH/src/github.com/\u0026lt;USERNAME\u0026gt;/ \u0026amp;\u0026amp; cd $GOPATH/src/github.com/\u0026lt;USERNAME\u0026gt;/ $ git clone git@github.com:kubernetes/sample-controller.git \u0026amp;\u0026amp; cd sample-controller 初始化 Controller 按照 sample-controller 的 Controller 框架，将其修改为我们想要实现的 Controller。\n修改项目名称为 database-controller，修改 git remote。 编辑 go.mod 修改 Module 名称，把代码的 k8s.io/sample-controller 改为 github.com/\u0026lt;USERNAME\u0026gt;/database-controller。 编辑 hack/boilerplate.go.txt 中的版权信息。 修改 README，OWNERS，SECURITY_CONTACTS 等信息。 编辑执行代码生成器的脚本 hack/update-codegen.sh 编辑脚本中的代码生成器所在位置，脚本中原本写的是使用了 go mod vendor 将 Go 依赖都放到了项目的 vendor 目录下时生成器的位置，按实际情况进行修改（比如改成 $GOPATH 目录下）。 编辑 code-generator 的参数，把 k8s.io/sample-controller 改成 github.com/\u0026lt;USERNAME\u0026gt;/database-controller, 并编辑 --output-base 的目录位置。 执行代码生成器脚本，确保能正确生成代码。 之后修改 pkg/apis/samplecontroller 目录为 pkg/apis/databasecontroller，同时把 samplecontroller 包修改为 databasecontroller。\n把代码中所有使用了 samplecontroller 包的地方都改为 databasecontroller（被代码生成器生成的代码可以不用改，后面会重新生成代码）。 修改 pkg/apis/databasecontroller/register.go 的 GroupName 为 database.\u0026lt;YOUR_DOMAIN\u0026gt;，例如 database.example.io。 修改代码生成器的注释，把 pkg/apis/databasecontroller/v1alpha1/doc.go 的 groupName 修改为 database.example.io。 重新执行代码生成器 ./hack/update-codegen.sh。 先简单熟悉一下修改后的项目的代码结构：\nmain.go 中先构建了 Kubernetes 和 database-controller 的 Client，之后基于 Client 构建了 SharedInformer，最后创建并启动 Controller。\n简单来讲，Informer 在资源发生改动时，调用相应事件的处理函数，它可以对“增加”，“更新”，“删除”三种事件进行“监控”处理（一点也不简单，太抽象了）。然后 Informer 还充当了缓存的作用，查询资源状态时只需要查询 Informer 的缓存即可，不需要反复调用 Kube API，减少性能损耗。\ncontroller.go 包含这些内容：\n构建 Controller 的 NewController、启动 Controller 的 Run，还有 Informer 在不同事件（Event）进行处理的函数…… 创建 Deployment 的函数，sample-controller 中的 CRD Kind 为 foo，这个 foo 创建的 Deployment 是一个 nginx Pod，有点抽象，后面要把 foo 改成咱们要实现的 database，原理实际都没变。 Controller 结构体中包含了：\nkubernetes 和代码生成器生成的 database 的 clientSet。 Informer 的 Lister，用来从缓存中获取资源。 workqueue：Rate Limit 消息队列。 Controller 在运行时实际是一直尝试从 workqueue 中获取资源并处理。Informer 在接收到状态更新后，会把更新的状态入队列，然后另一个 Routine 中会获取到队列中的消息，拿去处理。 （蛮复杂的，这里还是去直接看代码比较好） 修改 Controller 接下来按照上面讲的那样，修改 pkg/apis/databasecontroller/v1alpha1/types.go 中的 Spec 和 Status 字段，Spec 中的字段是你想定义的 Database 的状态，然后 Controller 负责按照你定义的 Spec 去创建 Deployments 并更新 Status。\n首先需要把 Foo 改名成 Database，然后编辑 Spec 中的字段，例如数据库所使用的镜像名称及 Tag，Replicas 冗余数以及其他你觉得创建 Deployment 所需的自定义配置。在修改完 Spec 和 Status 后需要重新执行代码生成器。\n之后在项目根目录下编辑 controller.go，修改控制器创建 Deployment 的逻辑，把 Foo 对象修改为 Database，然后按照你定义的 Spec，编辑 artifacs/example 目录下的 crd.yaml 和 example-database.yaml 文件，这部分咱就不把详细的步骤写到这里了，你可以根据你的想法尝试编写你的 Controller，在这里遇到问题最好还是自行尝试动手解决。\n其他 后面还有好多关于 Controller 相关的知识点我也还没搞懂，就不写到博客里误导别人了。除了 sample-controller 这种框架的 Controller 之外，还有很多人使用其他的框架编写 Controller，因为很多时候我们更关注于实现业务逻辑，因此可以套用一些 Operator 模板，常用的有 Operator SDK，可以通过这个工具生成一份 Controller 模板，然后按照你想实现的功能去修改代码即可，还有很多其他 Operator 可供选择，比如 Rancher 的开发者们使用 Wrangler 编写 Controller，基于 Wrangler 编写的 Rancher 使用的 Operator 有 eks-operator 等一堆 Operator，感兴趣的话可以去看看。Wrangler 的 README 中写的这一段蛮有意思的：\nMost people writing controllers are a bit lost as they find that there is nothing in Kubernetes that is like type Controller interface where you can just do NewController. Instead a controller is really just a pattern of how you use the generated clientsets, informers, and listers combined with some custom event handlers and a workqueue.\n之后如果想把你编写的 Controller (Operator) 应用到生产环境，打包给更多的人使用，可以把编译好的 Operator 二进制文件放到容器镜像中，之后使用 Helm 创建一个 \u0026ldquo;应用程序 (Chart)\u0026quot;，通过编写 模板，在安装 Helm Chart 时编辑 values.yaml 中定义的字段来自定义 CRD 的参数。Helm 的模板本质上是 Go Template 模板渲染引擎，所以用起来都是很简单的（确信）。\n","permalink":"https://blog.starry-s.moe/posts/2023/kube-controller/","summary":"\u003cp\u003eController 对初学着来说有那么亿点点抽象，虽然网络上能找到很多有关 Kubernetes Controller 的讲解，但是 Kubernetes 的学习过程往往是一个离散的而不是连续的过程。如果想弄懂 Controller 还是有蛮高门槛的，不要想着看完 Kubernetes 的文档，速成了 Kubernetes 的基本知识就去尝试写 Controller，这种操作就好比刚过完新手教程就去打高难副本，尽管能仿着 \u003ccode\u003esample-controller\u003c/code\u003e 写一个能“跑”的 Controller，但仅仅只能做到能“跑”的程度……\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e与标题有些不同，这篇博客主要讲的是萌新如何上手编写 Controller，如果你是 Kubernetes 初学者，希望这篇博客能帮助你建立编写 Controller 的学习曲线。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"当你刚开始尝试去写 Kubernetes Controller……"},{"content":"打算尝试在咱的 NAS 上搭一个 Harbor Registry Server 玩。\n首先介绍一下 NAS 上的环境，咱的 Kubernetes 集群运行在几个 QEMU 虚拟机里，虚拟机里运行的是 ArchLinux，因为就是咱折腾着玩的所以使用的 k3s 搭建的轻量级的 kubernetes 集群，然后其中一个集群安装了 Rancher 作为 Local 集群。\n环境准备 新建一个 Namespace，将 Harbor 的资源与其他资源隔离：\n$ kubectl create namespace harbor 为了启用 HTTPS，提前创建一个 TLS 类型的 Secret，存放证书:\n$ cat \u0026gt; cert.pem \u0026lt;\u0026lt; EOF -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- EOF $ cat \u0026gt; cert.key \u0026lt;\u0026lt; EOF -----BEGIN PRIVATE KEY----- ... -----END PRIVATE KEY----- EOF $ kubectl -n harbor create secret tls harbor-tls \\ --cert=cert.pem \\ --key=cert.key 提前创建 PVC (PersistentVolumeClaim)，咱这里先在 NAS 上新建了一个 NFS 服务器，之后创建了 NFS 类型的 PV (PersistentVolumes)，再基于这个 PV 创建的 PVC。\nArchLinux 上搭建 NFS 服务器：https://wiki.archlinux.org/title/NFS\n在配置 exports 时，需要配置上 no_root_squash 和 no_subtree_check，使挂载的目录及子目录具有写权限。\n# /etc/exports - exports(5) - directories exported to NFS clients # Use `exportfs -arv` to reload. /var/nfs/harbor\t10.0.0.0/8(rw,sync,no_root_squash,no_subtree_check) 获取 Helm Chart Harbor 的 Helm Chart 可以在 GitHub 获取，这里使用将 Chart 源码克隆到本地的方式安装，方便编辑 values.yaml。\n$ git clone https://github.com/goharbor/harbor-helm.git \u0026amp;\u0026amp; cd harbor-helm $ git checkout v1.12.1 写这篇博客时 Chart 的最新版本是 v1.12.1 (Harbor OSS v2.8.1)。\n编辑 values.yaml Harbor 的配置都定义在了 values.yaml 文件中，根据需要进行修改。\n这里列举些常用的可以修改的选项：\nexpose: # expose type, 可以设置为 ingress, clusterIP, nodePort, nodeBalancer，区分大小写 # 默认为 ingress（如果不想使用 80/443 标准端口，可以设置为 nodePort，端口为高位 3000X） type: ingress tls: # 是否启用 TLS (HTTPS)，建议启用 enabled: true # TLS Certificate 的来源，可以为 auto, secret 或 none # 如果为 secret，需要在安装 Chart 之前先创建 TLS Secret # 1) auto: generate the tls certificate automatically # 2) secret: read the tls certificate from the specified secret. # The tls certificate can be generated manually or by cert manager # 3) none: configure no tls certificate for the ingress. If the default # tls certificate is configured in the ingress controller, choose this option certSource: secret secret: # The name of secret which contains keys named: # \u0026#34;tls.crt\u0026#34; - the certificate # \u0026#34;tls.key\u0026#34; - the private key secretName: \u0026#34;harbor-tls\u0026#34; # Only needed when the \u0026#34;expose.type\u0026#34; is \u0026#34;ingress\u0026#34;. notarySecretName: \u0026#34;harbor-tls\u0026#34; ingress: hosts: # Ingress Host，如果需要允许任意域名/IP 都能访问，将其设置为空字符串（不建议） # 这里填写的域名务必能解析到当前集群 core: harbor.example.com notary: notary.example.com # Harbor external URL # 与 Ingress Host 相对应，如果启用了 TLS，那就是 https://\u0026lt;domain\u0026gt; # 如果没启用 TLS，那就是 http://\u0026lt;domain\u0026gt; # 如果 expose type 为 nodePort，则填写 http(s)://\u0026lt;IP_ADDRESS\u0026gt;:3000X (端口号不能丢) externalURL: https://harbor.example.com # 持久卷配置，默认为 true，如果是测试环境可以设置为 enabled: false (重新安装 Chart 时仓库里所有的数据都会丢失，不建议！) # 如果需要启用持久卷，可以在安装 Chart 之前提前创建好 PVC，并配置 subPath persistence: enabled: true resourcePolicy: \u0026#34;keep\u0026#34; persistentVolumeClaim: registry: # 填写已经创建好的 PVC existingClaim: \u0026#34;harbor-pvc\u0026#34; storageClass: \u0026#34;\u0026#34; # 如果共用一个 PVC，需要设置子目录 subPath: \u0026#34;registry\u0026#34; accessMode: ReadWriteOnce size: 5Gi annotations: {} jobservice: jobLog: existingClaim: \u0026#34;harbor-pvc\u0026#34; storageClass: \u0026#34;\u0026#34; subPath: \u0026#34;jobservice\u0026#34; accessMode: ReadWriteOnce size: 1Gi annotations: {} database: existingClaim: \u0026#34;harbor-pvc\u0026#34; storageClass: \u0026#34;\u0026#34; subPath: \u0026#34;database\u0026#34; accessMode: ReadWriteOnce size: 1Gi annotations: {} redis: existingClaim: \u0026#34;harbor-pvc\u0026#34; storageClass: \u0026#34;\u0026#34; subPath: \u0026#34;redis\u0026#34; accessMode: ReadWriteOnce size: 1Gi annotations: {} trivy: existingClaim: \u0026#34;harbor-pvc\u0026#34; storageClass: \u0026#34;\u0026#34; subPath: \u0026#34;trivy\u0026#34; accessMode: ReadWriteOnce size: 5Gi annotations: {} # Admin 初始密码 harborAdminPassword: \u0026#34;Harbor12345\u0026#34; 安装 Helm Chart 确保 Values 编辑无误后，就可以安装 Chart 了：\n$ helm --namespace harbor install harbor . 如果安装后发现 Values 中有些配置需要修改，可以在修改完配置后以升级的方式使配置生效：\n$ helm --namespace harbor upgrade harbor . 查看 Chart 的 Pods 运行状态：\n$ kubectl --namespace harbor get pods NAME READY STATUS RESTARTS AGE harbor-core-7b75785b64-9vzkx 1/1 Running 0 65m harbor-database-0 1/1 Running 0 77m harbor-jobservice-6f4d59bd95-25q44 1/1 Running 2 (65m ago) 65m harbor-notary-server-584698b475-lnt99 1/1 Running 1 (60m ago) 65m harbor-notary-signer-77685b6f94-pfngc 1/1 Running 0 65m harbor-portal-6fb6465fd6-hm4cg 1/1 Running 0 77m harbor-redis-0 1/1 Running 0 77m harbor-registry-5bbccf79fb-7hcm9 2/2 Running 0 65m harbor-trivy-0 1/1 Running 0 77m 其他 安装完成后，就可以完美使用 Harbor Registry 了。\n$ docker login harbor.example.com Username: admin Password: WARNING! Your password will be stored unencrypted in /home/user/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded 从 DockerHub 中 Mirror 一些镜像到 Harbor 中：\n$ skopeo copy --all docker://archlinux:latest docker://harbor.example.com/library/archlinux:latest Getting image list signatures Copying 1 of 1 images in list Copying image sha256:076c0233d1996165721320957be9a037a760574d6334281354b07b3b3c9440b1 (1/1) Getting image source signatures Copying blob f0e04a7b4686 done Copying blob 352736306209 done Copying config cc4866169d done Writing manifest to image destination Storing signatures Writing manifest list to image destination Storing list signatures ","permalink":"https://blog.starry-s.moe/posts/2023/harbor-helm-chart/","summary":"\u003cp\u003e打算尝试在咱的 NAS 上搭一个 Harbor Registry Server 玩。\u003c/p\u003e","title":"使用 Helm Chart 方式部署 Harbor"},{"content":"最近总在弄些容器镜像相关的东西，于是分享一些咱自己总结的有关容器镜像 Manifest 格式、常用工具以及代码相关的芝士。\nskopeo skopeo 是一个肥肠好用的容器镜像的辅助工具，常用到的功能有镜像拷贝 (skopeo copy)、镜像 Manifest 查询 (skopeo inspect)等……\nskopeo 仅支持 Linux 和 macOS 系统。\n安装 skopeo # ArchLinux sudo pacman -S skopeo # macOS brew install skopeo 除此之外还可以使用 skopeo 的容器镜像：\n$ docker run docker://quay.io/skopeo/stable:latest copy --help skopeo 由 Go 编写，但它启用了 cgo，编译的二进制文件需要动态链接第三方依赖，所以不同的系统编译的 skopeo 二进制文件并不一定互相通用，如果你的发行版的官方源没有提供 skopeo 软件包的话，只能手动安装 Go 和 skopeo 的一些依赖，然后 自行编译 skopeo 二进制文件。\nskopeo copy copy 可以灵活的拷贝容器镜像，它可以将容器镜像从 Registry Server 之间拷贝，还可以将镜像从 Registry Server 拷贝到本地的文件夹中，或者像 docker pull 那样拷贝到 Docker Daemon 中。\n在执行 skopeo copy 时还可以用 --format 参数指定拷贝过去的容器镜像的格式，用参数 --dest-compress-format 可以指定压缩格式。\n将容器镜像从第三方 DockerHub Registry Server 拷贝到自建的 Private Registry Server：\n$ skopeo copy docker://docker.io/library/nginx:latest docker://private.registry.io/library/nginx:latest --all 将镜像从 DockerHub Registry Server 拷贝到本地文件夹中：\n$ mkdir -p nginx $ skopeo copy docker://docker.io/library/nginx:latest dir:./nginx 将镜像从本地文件夹中拷贝到 Docker Daemon 中：\n$ skopeo copy dir:./nginx docker-daemon:nginx:latest $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest 448a08f1d2f9 13 days ago 142MB skopeo inspect skopeo inspect 查看容器镜像的信息，例如镜像的 Manifest、Config。\n$ skopeo inspect docker://docker.io/library/nginx:latest $ skopeo inspect docker://docker.io/library/nginx:latest --raw $ skopeo inspect docker://docker.io/library/nginx:latest --raw --config skopeo inspect 不加任何参数时，查询的是容器镜像相关的信息，输出的内容包括镜像 Digest、该镜像其他的所有 Tag 等一系列信息。\n在添加 --raw 参数时，输出的是该镜像的 Manifest 原始信息，因为是 RAW，所以输出的 Json 可能格式不是很友好，通常与 jq 一起使用。\n添加 --raw 和 --config 参数后，输出的是该镜像的 Config 的原始信息，Config 中包括容器运行时的一些配置项等信息。\nManifest Docker 文档 Registry image manifests 中介绍了几种常见的 Docker 镜像的 Manifest 格式。\n可以通过 skopeo 工具，从 Docker Hub 上挑一个容器镜像 (例如 nginx:latest)，查看这个镜像的 Manifest。\n// skopeo inspect docker://nginx:latest --raw | jq { \u0026#34;manifests\u0026#34;: [ { \u0026#34;digest\u0026#34;: \u0026#34;sha256:3f01b0094e21f7d55b9eb7179d01c49fdf9c3e1e3419d315b81a9e0bae1b6a90\u0026#34;, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.v2+json\u0026#34;, \u0026#34;platform\u0026#34;: { \u0026#34;architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;os\u0026#34;: \u0026#34;linux\u0026#34; }, \u0026#34;size\u0026#34;: 1570 }, { \u0026#34;digest\u0026#34;: \u0026#34;sha256:bc4cb92540db42f21dd806c4451f33b623a9b6441c882e8554325f3a3702da76\u0026#34;, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.v2+json\u0026#34;, \u0026#34;platform\u0026#34;: { \u0026#34;architecture\u0026#34;: \u0026#34;arm\u0026#34;, \u0026#34;os\u0026#34;: \u0026#34;linux\u0026#34;, \u0026#34;variant\u0026#34;: \u0026#34;v5\u0026#34; }, \u0026#34;size\u0026#34;: 1570 }, ...... ], \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.list.v2+json\u0026#34;, \u0026#34;schemaVersion\u0026#34;: 2 } 这里输出的 json object 的 schemaVersion 为 2，mediaType 为 application/vnd.docker.distribution.manifest.list.v2+json。\nschemaVersion \u0026amp; mediaType 容器镜像的 Manifest 有很多种不同的格式，先列举一下常见的 Docker 镜像的 Manifest 格式：\nschemaVersion: 1, mediaType: \u0026quot;application/vnd.docker.distribution.manifest.v1+json\u0026quot;\n旧版本的 Docker 使用这种 Manifest 格式，现已被弃用，有些旧的容器镜像依旧是这种格式的 Manifest。\n// skopeo inspect docker://mysql:5.5.40 --raw | jq { \u0026#34;name\u0026#34;: \u0026#34;library/mysql\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;5.5.40\u0026#34;, \u0026#34;architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;fsLayers\u0026#34;: [ { \u0026#34;blobSum\u0026#34;: \u0026#34;sha256:a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4\u0026#34; } ...... ], \u0026#34;history\u0026#34;: [ ...... ], \u0026#34;schemaVersion\u0026#34;: 1, \u0026#34;signatures\u0026#34;: [ { ...... } ] } (输出太长了所以我把不关键的内容省略掉了……)\n这里用 docker.io/library/mysql:5.5.40 这个镜像举例，实际这个镜像的 Manifest 格式为 schemaVersion: 1，mediaType: \u0026quot;application/vnd.docker.distribution.manifest.v1+prettyjws\u0026quot;，因为包含了签名信息。\nschemaVersion: 2, mediaType: \u0026quot;application/vnd.docker.distribution.manifest.v2+json\u0026quot;\n这个是现在常见的 Docker 镜像的 Manifest 格式。\n// skopeo inspect docker://hxstarrys/nginx:1.22-amd64 --raw | jq { \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.v2+json\u0026#34;, \u0026#34;config\u0026#34;: { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.container.image.v1+json\u0026#34;, \u0026#34;size\u0026#34;: 7898, \u0026#34;digest\u0026#34;: \u0026#34;sha256:0f8498f13f3adef3f3c8b52cdf069ecc880b081159be6349163d144e8aa5fb29\u0026#34; }, \u0026#34;layers\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.image.rootfs.diff.tar.gzip\u0026#34;, \u0026#34;size\u0026#34;: 31411405, \u0026#34;digest\u0026#34;: \u0026#34;sha256:f1f26f5702560b7e591bef5c4d840f76a232bf13fd5aefc4e22077a1ae4440c7\u0026#34; }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.image.rootfs.diff.tar.gzip\u0026#34;, \u0026#34;size\u0026#34;: 25573496, \u0026#34;digest\u0026#34;: \u0026#34;sha256:fd03b214f77493ccb73705ac5417f16c7625a7ea7ea997e939c9241a3296763b\u0026#34; }, ...... ] } 这个格式的 Manifest 包含了镜像的 Config 的信息以及 Layer 的格式和 Digest 信息。\nschemaVersion: 2, mediaType: \u0026quot;application/vnd.docker.distribution.manifest.list.v2+json\u0026quot;\n这个格式的 Manifest List 包含一个 manifests 列表：\n// skopeo inspect docker://docker.io/library/nginx:1.22 --raw | jq { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.list.v2+json\u0026#34;, \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;manifests\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.v2+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:9081064712674ffcff7b7bdf874c75bcb8e5fb933b65527026090dacda36ea8b\u0026#34;, \u0026#34;size\u0026#34;: 1570, \u0026#34;platform\u0026#34;: { \u0026#34;architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;os\u0026#34;: \u0026#34;linux\u0026#34; } }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.v2+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:cf4ffe24f08a167176c84f2779c9fc35c2f7ce417b411978e384cbe63525b420\u0026#34;, \u0026#34;size\u0026#34;: 1570, \u0026#34;platform\u0026#34;: { \u0026#34;architecture\u0026#34;: \u0026#34;arm64\u0026#34;, \u0026#34;os\u0026#34;: \u0026#34;linux\u0026#34; } } ] } 例如在 x86_64 (amd64) 架构的 Linux 主机上拉取 TAG docker.io/library/nginx:1.22 时，会根据此 Manifest List，拉取 Digest 为 sha256:9081064712674ffcff7b7bdf874c75bcb8e5fb933b65527026090dacda36ea8b 的镜像。在 aarch64 (arm64v8) 架构的 Linux 主机上拉取此 TAG 时，会根据 Manifest List，拉取 Digest 为 sha256:cf4ffe24f08a167176c84f2779c9fc35c2f7ce417b411978e384cbe63525b420 的镜像，在其他 OS 的主机上无法拉取这个 TAG 对应的镜像 (例如在 arm32v7 的 Linux 主机上拉取会失败)。\nmanifests 列表中，每个 digest 字段存储的是这个镜像的 Manifest 内容的 sha256 校验和。\n可以用 skopeo inspect 查看一下这个 digest 的镜像的 Manifest 内容，其格式为 schemaVersion: 2, mediaType: \u0026quot;application/vnd.docker.distribution.manifest.v2+json\u0026quot;\n// skopeo inspect docker://nginx@sha256:9081064712674ffcff7b7bdf874c75bcb8e5fb933b65527026090dacda36ea8b --raw | jq { \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.v2+json\u0026#34;, \u0026#34;config\u0026#34;: { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.container.image.v1+json\u0026#34;, \u0026#34;size\u0026#34;: 7898, \u0026#34;digest\u0026#34;: \u0026#34;sha256:0f8498f13f3adef3f3c8b52cdf069ecc880b081159be6349163d144e8aa5fb29\u0026#34; }, \u0026#34;layers\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.image.rootfs.diff.tar.gzip\u0026#34;, \u0026#34;size\u0026#34;: 31411405, \u0026#34;digest\u0026#34;: \u0026#34;sha256:f1f26f5702560b7e591bef5c4d840f76a232bf13fd5aefc4e22077a1ae4440c7\u0026#34; }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.image.rootfs.diff.tar.gzip\u0026#34;, \u0026#34;size\u0026#34;: 25573496, \u0026#34;digest\u0026#34;: \u0026#34;sha256:fd03b214f77493ccb73705ac5417f16c7625a7ea7ea997e939c9241a3296763b\u0026#34; }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.image.rootfs.diff.tar.gzip\u0026#34;, \u0026#34;size\u0026#34;: 626, \u0026#34;digest\u0026#34;: \u0026#34;sha256:ef2fc869b944b87eaf25f4c92953dc69736d5d05aa09f66f54b0eea598e13c9c\u0026#34; }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.image.rootfs.diff.tar.gzip\u0026#34;, \u0026#34;size\u0026#34;: 958, \u0026#34;digest\u0026#34;: \u0026#34;sha256:ac713a9ef2cca7a82e27f0277e4e3d25c64d1cf31e4acd798562d5532742f5ef\u0026#34; }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.image.rootfs.diff.tar.gzip\u0026#34;, \u0026#34;size\u0026#34;: 773, \u0026#34;digest\u0026#34;: \u0026#34;sha256:fd071922d543e072b21cb41a513634657049d632fe48cfed240be2369f998403\u0026#34; }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.image.rootfs.diff.tar.gzip\u0026#34;, \u0026#34;size\u0026#34;: 1405, \u0026#34;digest\u0026#34;: \u0026#34;sha256:2a9f38700bb5a0462e326fe3541b45f24a677ac3cd386c4922d48da5fbb6f0a8\u0026#34; } ] } 镜像的 Digest 实际上是这个镜像的 Manifest 内容的 sha256sum 校验和：\n$ skopeo inspect --raw docker://nginx@sha256:9081064712674ffcff7b7bdf874c75bcb8e5fb933b65527026090dacda36ea8b { \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.v2+json\u0026#34;, \u0026#34;config\u0026#34;: { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.container.image.v1+json\u0026#34;, \u0026#34;size\u0026#34;: 7898, \u0026#34;digest\u0026#34;: \u0026#34;sha256:0f8498f13f3adef3f3c8b52cdf069ecc880b081159be6349163d144e8aa5fb29\u0026#34; }, ...... $ skopeo inspect --raw docker://nginx@sha256:9081064712674ffcff7b7bdf874c75bcb8e5fb933b65527026090dacda36ea8b | sha256sum 9081064712674ffcff7b7bdf874c75bcb8e5fb933b65527026090dacda36ea8b - 同理，Config 的 Digest 为镜像的 Config 内容的 sha256sum 校验和：\n$ skopeo inspect --raw --config docker://nginx@sha256:9081064712674ffcff7b7bdf874c75bcb8e5fb933b65527026090dacda36ea8b | sha256sum 0f8498f13f3adef3f3c8b52cdf069ecc880b081159be6349163d144e8aa5fb29 - 除了上面的几种 Docker 镜像的 Manifest 格式外，还有 OCI 容器镜像 这种格式的 Manifest:\nschemaVersion: 2, mediaType: \u0026quot;application/vnd.oci.image.manifest.v1+json\u0026quot; // skopeo inspect docker://quay.io/skopeo/stable@sha256:9da6763a4d35592a6279e851738472d9cdaa8ff5a5da3c50b560f065d22c2bff --raw | jq { \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34;, \u0026#34;config\u0026#34;: { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.config.v1+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:6acf3c9f5dd48704618fa7ec2b95968a45c9e7809926a1f90f383bea4e9b3ede\u0026#34;, \u0026#34;size\u0026#34;: 3032 }, \u0026#34;layers\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.layer.v1.tar+gzip\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:529411ad578ab92819185dd8ef493eaa1eecc4f62b2ed2199db99ae23e6bf4cd\u0026#34;, \u0026#34;size\u0026#34;: 73881106 }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.layer.v1.tar+gzip\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:eeaa0b0d534352a9398996bcff9dc1184a78d310c22800aa6de07a6e2b1f8864\u0026#34;, \u0026#34;size\u0026#34;: 54520878 }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.layer.v1.tar+gzip\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:5ebf46cd2e6b356313b1dce504191fefce45df90dd8b5df7fe6b8cdd0fd06667\u0026#34;, \u0026#34;size\u0026#34;: 1849 }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.layer.v1.tar+gzip\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:d4779f97b4911cd73b8bbe8b96c6759b6f5c210928020e0c351294e7136aeb94\u0026#34;, \u0026#34;size\u0026#34;: 4061 }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.layer.v1.tar+gzip\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:f2e09c14b28b7453b48d13aace7cef657580e3b1cfdc0be8cfb9e685862a068f\u0026#34;, \u0026#34;size\u0026#34;: 228 } ], \u0026#34;annotations\u0026#34;: { \u0026#34;org.opencontainers.image.base.digest\u0026#34;: \u0026#34;sha256:7acf70fa27721ef08357823d79324a19d7e9b0d34873c93f33a1b654d784e3c4\u0026#34;, \u0026#34;org.opencontainers.image.base.name\u0026#34;: \u0026#34;registry.fedoraproject.org/fedora:latest\u0026#34; } } schemaVersion: 2, mediaType: \u0026quot;application/vnd.oci.image.index.v1+json\u0026quot; // skopeo inspect docker://quay.io/skopeo/stable:latest --raw | jq { \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.index.v1+json\u0026#34;, \u0026#34;manifests\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:3f678eca3035c64243c70598efeb4f60ef06a07b156444e21feed9488d47944b\u0026#34;, \u0026#34;size\u0026#34;: 1239, \u0026#34;platform\u0026#34;: { \u0026#34;architecture\u0026#34;: \u0026#34;arm64\u0026#34;, \u0026#34;os\u0026#34;: \u0026#34;linux\u0026#34; } }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:72464a265722c05436b5f46b9247929a882e73462f33ac1c000f4a34094fc90c\u0026#34;, \u0026#34;size\u0026#34;: 1239, \u0026#34;platform\u0026#34;: { \u0026#34;architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;os\u0026#34;: \u0026#34;linux\u0026#34; } } ] } Library containers 和 opencontainers Org 提供了许多容器镜像相关的 Go Library，例如：\ncontainers/image containers/common opencontainers/image-spec Docker Manifest 格式的定义位于代码：containers/image/v5/manifest\nOCI 容器镜像的 Manifest 格式定义位于代码：opencontainers/image-spec/specs-go/v1\nskopeo inspect 的代码位于 containers/skopeo/cmd/skopeo/inspect.go，skopeo 用了 cobra 框架来处理用户的命令行参数（这里悄悄安利一下 cobra 框架真的很好用，尤其是当你的程序有许多的子命令，每个子命令需要处理的参数还都不一样的情况），执行查询镜像 Manifest 的代码都在 run 函数里面。\n下面是咱写的一个栗子，使用上述的 Library 模拟一下 skopeo inspect 查看容器镜像 Manifest 的功能，其实查看容器镜像 Manifest 的代码实现还是蛮简单的：\npackage example import ( \u0026#34;context\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/containers/image/v5/transports/alltransports\u0026#34; \u0026#34;github.com/containers/image/v5/types\u0026#34; ) func Test_Inspect(t *testing.T) { // reference name format: docker://\u0026lt;image\u0026gt;:\u0026lt;tag\u0026gt; refName := \u0026#34;docker://docker.io/library/nginx:latest\u0026#34; ref, err := alltransports.ParseImageName(refName) if err != nil { t.Errorf(\u0026#34;ParseImageName: %v\u0026#34;, err) return } sysCtx := \u0026amp;types.SystemContext{ DockerAuthConfig: \u0026amp;types.DockerAuthConfig{ Username: \u0026#34;\u0026#34;, // docker username (optional) Password: \u0026#34;\u0026#34;, // docker password (optional) }, // set to true if server is HTTP or using insecure certificate OCIInsecureSkipTLSVerify: false, DockerInsecureSkipTLSVerify: types.NewOptionalBool(false), } source, err := ref.NewImageSource(context.TODO(), sysCtx) if err != nil { t.Errorf(\u0026#34;NewImageSource: %v\u0026#34;, err) return } data, mime, err := source.GetManifest(context.TODO(), nil) if err != nil { t.Errorf(\u0026#34;GetManifest: %v\u0026#34;, err) return } fmt.Printf(\u0026#34;Manifest mediaType: %v\\n\u0026#34;, mime) fmt.Printf(\u0026#34;Manifest RAW data: \\n%v\\n\u0026#34;, string(data)) // reformat output var obj any if err = json.Unmarshal(data, \u0026amp;obj); err != nil { t.Errorf(\u0026#34;Unmarshal: %v\u0026#34;, err) return } if data, err = json.MarshalIndent(obj, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;); err != nil { t.Errorf(\u0026#34;MarshalIndent: %v\u0026#34;, err) return } fmt.Printf(\u0026#34;===================================\\n\u0026#34;) fmt.Printf(\u0026#34;Manifest data: \\n%v\\n\u0026#34;, string(data)) } 接下来，是构建 Manifest List 索引的一个简单栗子，假设你分别向 Registry Server 上传了 \u0026lt;namespace\u0026gt;/example:v1.0.0-amd64 和 \u0026lt;namespace\u0026gt;/example:v1.0.0-arm64 两个不同架构的容器镜像，你希望用户在 AMD64 架构的主机上拉取 \u0026lt;namespace\u0026gt;/example:v1.0.0 的 TAG 时，自动拉取 \u0026lt;namespace\u0026gt;/example:v1.0.0-amd64 这个镜像，而在 ARM64 架构的主机上拉取时，自动拉取 \u0026lt;namespace\u0026gt;/example:v1.0.0-arm64 这个镜像。\n这里说的 Manifest List 实际是 schemaVersion 2, mediaType: \u0026quot;application/vnd.docker.distribution.manifest.list.v2+json\u0026quot;\n基本上你可以使用任何的 Registry Server，但 Harbor V1 除外，因为 Harbor V1 不支持 Manifest List。\npackage example import ( \u0026#34;context\u0026#34; \u0026#34;crypto/sha256\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/containers/image/v5/manifest\u0026#34; \u0026#34;github.com/containers/image/v5/transports/alltransports\u0026#34; \u0026#34;github.com/containers/image/v5/types\u0026#34; \u0026#34;github.com/opencontainers/go-digest\u0026#34; ) func sha256sum(data []byte) string { sum := sha256.Sum256(data) return fmt.Sprintf(\u0026#34;%x\u0026#34;, sum) } func getManifest(refName string, ctx *types.SystemContext) ([]byte, string, error) { // reference name format: docker://\u0026lt;image\u0026gt;:\u0026lt;tag\u0026gt; ref, err := alltransports.ParseImageName(refName) if err != nil { return nil, \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;ParseImageName: %w\u0026#34;, err) } source, err := ref.NewImageSource(context.TODO(), ctx) if err != nil { return nil, \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;NewImageSource: %v\u0026#34;, err) } return source.GetManifest(context.TODO(), nil) } func Test_BuildManifest(t *testing.T) { // reference name format: docker://\u0026lt;image\u0026gt;:\u0026lt;tag\u0026gt; refName := \u0026#34;docker://\u0026lt;REGISTRY_URL:PORT\u0026gt;/\u0026lt;NAMESPACE\u0026gt;/example:v1.0.0\u0026#34; ref, err := alltransports.ParseImageName(refName) if err != nil { t.Errorf(\u0026#34;ParseImageName: %v\u0026#34;, err) return } sysCtx := \u0026amp;types.SystemContext{ DockerAuthConfig: \u0026amp;types.DockerAuthConfig{ Username: \u0026#34;\u0026#34;, // registry username (required) Password: \u0026#34;\u0026#34;, // registry password (required) }, // set to true if server is HTTP or using insecure certificate OCIInsecureSkipTLSVerify: false, DockerInsecureSkipTLSVerify: types.NewOptionalBool(false), } manifestList := manifest.Schema2List{ SchemaVersion: 2, MediaType: manifest.DockerV2ListMediaType, Manifests: []manifest.Schema2ManifestDescriptor{}, } // add amd64 data data, mime, err := getManifest(\u0026#34;docker://\u0026lt;REGISTRY_URL:PORT\u0026gt;/\u0026lt;NAMESPACE\u0026gt;/example:v1.0.0-amd64\u0026#34;, sysCtx) if err != nil { t.Errorf(\u0026#34;getManifest: %v\u0026#34;, err) return } manifestList.Manifests = append(manifestList.Manifests, manifest.Schema2ManifestDescriptor{ Schema2Descriptor: manifest.Schema2Descriptor{ MediaType: mime, Size: int64(len(data)), Digest: digest.Digest(sha256sum(data)), }, Platform: manifest.Schema2PlatformSpec{ Architecture: \u0026#34;amd64\u0026#34;, OS: \u0026#34;linux\u0026#34;, OSVersion: \u0026#34;\u0026#34;, Variant: \u0026#34;\u0026#34;, }, }) // add arm64 data data, mime, err = getManifest(\u0026#34;docker://\u0026lt;REGISTRY_URL:PORT\u0026gt;/\u0026lt;NAMESPACE\u0026gt;/example:v1.0.0-arm64\u0026#34;, sysCtx) if err != nil { t.Errorf(\u0026#34;getManifest: %v\u0026#34;, err) return } manifestList.Manifests = append(manifestList.Manifests, manifest.Schema2ManifestDescriptor{ Schema2Descriptor: manifest.Schema2Descriptor{ MediaType: mime, Size: int64(len(data)), Digest: digest.Digest(sha256sum(data)), }, Platform: manifest.Schema2PlatformSpec{ Architecture: \u0026#34;arm64\u0026#34;, OS: \u0026#34;linux\u0026#34;, OSVersion: \u0026#34;\u0026#34;, Variant: \u0026#34;v8\u0026#34;, }, }) dest, err := ref.NewImageDestination(context.TODO(), sysCtx) if err != nil { t.Errorf(\u0026#34;NewImageSource: %v\u0026#34;, err) return } if data, err = json.MarshalIndent(manifestList, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;); err != nil { t.Errorf(\u0026#34;MarshalIndent: %v\u0026#34;, err) return } if err = dest.PutManifest(context.TODO(), data, nil); err != nil { t.Errorf(\u0026#34;PutManifest: %v\u0026#34;, err) return } } 构建 Manifest 的栗子中，用到了一部分 Manifest 的代码，用来获取 amd64 架构的镜像和 arm64 架构镜像的 Manifest 文本长度，并计算 Digest。\n","permalink":"https://blog.starry-s.moe/posts/2023/container-manifest/","summary":"\u003cp\u003e最近总在弄些容器镜像相关的东西，于是分享一些咱自己总结的有关容器镜像 Manifest 格式、常用工具以及代码相关的芝士。\u003c/p\u003e","title":"容器镜像 Manifest 相关内容整理"},{"content":"回忆前几天的旅行就仿佛在回忆一场睡了很长的梦一样……\n起初是没打算去那么远的地方旅游的，本来打算五一假期在沈阳那些我没去过的地方逛一逛就行，但是后来想了一下可以在平时周末的时候再去沈阳周边我没去过的地方，毕竟离得近，而这个难得的小长假不如去更远一点的地方玩一玩，于是想起来三年前就有去成都的打算了，但是由于种种原因一直拖到了现在，刚好我有几个大学同学在成都，于是最后看了一下机票价格降到了比较合理的水平就决定去四川成都玩了，之后因为成都离重庆很近所以决定先去成都溜达一趟，再去重庆逛一圈。\n所以这次的旅行记录就参照四年前咱一个人去上海的旅行那样，把每天的事情简单的回忆一下并记录到这里吧。\n4月27日 咱是请了几天年假打算错峰去旅行的，所以旅行是从27号开始，在出发之前沈阳迎来了一次大降温于是发烧感冒了好几天，在看完了沈阳的春天的最后一场雪之后（没错，快到5月份的时候沈阳下了一场雪），拖着生病还没完全康复身子出发去机场坐飞机前往成都……\n当时尽管身体因为还在生病没力气，但因为记错了飞机起飞的时间所以那天一大早就一直在忙着收拾行李跑去机场，根本管不上什么身体难受不难受的了……\n沈阳到成都的飞机飞了4个多小时，北方的天气也不是很好所以没在飞机上拍什么照片，到成都之后已经是晚上了所以那天一整天都没怎么拍风景的照片。\n不过晚上去了同学家拍了一阵子他那一柜子的手办……\n4月28日 因为出发前并没做攻略，咱就简单的查了一下成都的几个网红打卡点，于是28号那天坐地铁去了成都的野生大能猫基地。趁着人不是很多，可以比较安静舒服的在大森林里面一边溜达一边给大能猫拍照。\n那天成都一整天都在下小雨，然后我感冒没完全好，身体基本上是拿感冒药硬扛的，所以出了很多汗，加上下雨十分潮湿，我的双手得抱着相机所以没打伞，所以在能猫基地逛了一圈后上半身全湿了。\n然后是在第一天坐飞机的时候无意间发现我的手机摄像头拍照时照片放大后有几个细微的紫色的斑点，于是傍晚时去了太古里的苹果店约了服务人员帮我检测一下，最终得到的答复是镜头被激光扫到了导致的，尽管我买了AC+但是换镜头需要掏六百多的维修费用，因为相机的紫色斑点不是很严重所以掏六百多块钱维修的话不是很划算，于是回去和同学愉快的恰了一顿烤肉就撤了。\n4月29日 五一假期的第一天，和同学去了成都的西部国际博览城，逛了一天的漫展，当时腿都要走断了……\n所以这个红石公园有没有红石？MC 玩家狂喜（bushi\n最后这张照片，能拍到蒂法和克劳德的组合，感觉这次来成都漫展简直值了。当时在漫展找了一下午的克劳德都没找到他，最后碰到了蒂法后刚想给她拍照时突然遇到了准备回去的克劳德，于是赶紧喊过来和蒂法一起合照，真的当时他们摆出姿势后一下子就回想起了去年夏天玩 FF7 前几章时的感觉了，真的太激动了……\n晚上和同学恰了成都的火锅，因为担心会不会狠辣所以要了微辣的锅底，但后来吃起来觉得微辣不够辣，不是十分过瘾……\n4月30日 五一假期的第二天依旧是去西博城的漫展，拍了好多coser的照片……\n上午办完酒店退租后在写字楼的楼底下拍到了这只独自蹲在角落的小熊。\n之后是拖着行李箱去的漫展，在漫展那里找了存包的地方，顺便给举存包牌牌的小姐姐拍了张照。\n铃芽户缔\n之后是拍到的一些很漂亮的coser……\n因为这几天一直在到处溜达走路，所以逛漫展基本上都是走几步就得找个地方坐下休息一会……\n晚上坐高铁从成都东站前往重庆，因为到重庆之后是晚上所以有一点点迷路，拿手机导航绕了好几个圈……\n到重庆时因为赶上五一的高峰期，旅店的价格很贵，尽管我是提前定的，但还是两百多块钱定了一个很普通（甚至有点破）的房间，还没有独立卫浴……\n西南地区尽管还没进入夏天但已经开始湿热起来，不能洗澡是真的要命……\n5月1日 因为听说重庆的轨道交通蛮有名的，所以想去看一下比较知名的2号线李子坝站，就是那个把地铁车站修到了楼里的车站。\n但实际去了之后，因为人太多了光是从车站下车后下楼就挤了十多分钟，所以体验并不是很好，在马路上抬头看车站实际上也就觉得是地铁（单轨）从楼里穿了过去而已，没啥稀奇的，但毕竟来都来了……\n因为人特别多所以我不打算从李子坝站挤回去坐地铁了，而是徒步从李子坝站走到牛角沱站去坐3号线，尽可能的把人流错开。\n因为听说重庆的洪崖洞那边人特别多，加上下午实在是太热了，我去旅游的时候光想着会不会冷了所以带的都是厚衣服……一件短袖都没有带。于是在网上找了一下重庆的漫展，前往了重庆的国家会展中心……\n果然二刺猿还是应该去二刺猿该去的地方……\n傍晚漫展结束的时候，因为实在是太热了浑身出汗都湿透了，已经捂出痱子了，就坐地铁去了附近的瓦达瓜叉找了一家优衣库买了一件短袖换上了。\n在万达的麦当劳吃完晚饭后，坐地铁去了重庆的朝天门。\n到朝天门穿过商场之后，一直沿着江边的路往洪崖洞方向步行，一开始人还不是很多，但快到千厮门嘉陵江大桥后人就变得特别的多，于是在附近拍了一些照片后决定不去洪崖洞里面，想办法徒步离开这里。\n因为听说重庆把跨江大桥封了专门供游客通行，所以我也趁着人不是很多的时候从桥下的江边的路绕（爬山）到了大桥上边。\n快登桥的时候人巨多，非常的挤，但所有人都很有秩序，一点点的往前移动。\n所以走了几个小时之后终于登上了千厮门嘉陵江大桥，拍了一些照片，但实在是太累了没有掏相机拍照，手机的夜景效果比较勉强。\n因为江对面的第一个地铁站人很多，进站要排队，所以咱徒步走到了下一个地铁站，坐9号线回去的。\n六十九号线哈哈哈哈哈……\n这一天走了相当远的距离，步数达到了2W步，但实际咱的运动量可不只这两万步，从19年到现在很久没走过这么多步了……\n5月2日 因为返程的飞机是晚上的，所以白天还可以逛一天，上午在酒店收拾完东西，因为实在是走不动路了，也不想白天顶着大太阳去旅游景点，所以下午又去了重庆的漫展，在漫展基本上都是找地方坐着。\n顺便拍了一些照片。\n晚上坐飞机前往郑州，在郑州新郑机场过夜……\n5月3日 抵达郑州时已经是凌晨1点多了，在郑州机场的候机大厅里只睡了几个小时，因为没有可以躺的地方，所以后来实在困得受不了了就抱着行李箱开睡……\n郑州飞沈阳的飞机上咱基本上一直在睡觉，只有空乘在发水和早餐时是醒着的。\n在重庆机场候机的时候突然意识到5月3号下午还可以再从沈阳玩半天（确信），于是又买了一张沈阳漫展的票，去找之前认识的人在漫展上给他们拍照……\n回去的时候已经困得睁不开眼睛了，叫了出租车睡了一路……\n回想一下咱五一假期逛了三个城市，一共五天的漫展，还去了一些其他的旅游景点……\n算是报复性旅游吧，其实一开始没打算这么高强度旅行的，但玩着玩着就成了特种兵式旅游了……\n","permalink":"https://blog.starry-s.moe/posts/2023/2023-05-01/","summary":"\u003cp\u003e回忆前几天的旅行就仿佛在回忆一场睡了很长的梦一样……\u003c/p\u003e","title":"咱今年的五一旅行游记"},{"content":"从去年的春天到现在已经过去一年了……\n","permalink":"https://blog.starry-s.moe/posts/2023/spring-2023/","summary":"\u003cp\u003e从去年的春天到现在已经过去一年了……\u003c/p\u003e","title":"咱的摄影日记 - 2023 春"},{"content":"年初逛了一趟漫展之后突然想换新的相机了，因为对手里的 EOS 800D 成像不是很满意，暗光的高感表现很差，ISO 800 的时候 RAW 格式稍微拉一下阴影就会出现许多噪点，所以打算换个更专业点的相机，开拓些新的领域。\n预算方面我把相机和镜头控制在了 1W 出头，尽管这个价位能买到前几年的全画幅微单，但是综合考虑了一阵子后还是入手了佳能去年新出的 APS-C 画幅的 R7，用转接环可以搭配我已有的 EF/EF-S 镜头，能稍微节省一点镜头的开销，主要是我还挺喜欢手里的适马 17-50 这个镜头的。\n因为 RF 卡口的镜头价格太贵了，所以入手相机之后搜了一些评价不错的 EF-S 镜头，于是就买了广角镜头适马 18-35，所以最终还是超预算了。\n相机到了之后试着到处溜达拍了一些照片，用着记忆里很久以前用诺基亚自学摄影时的那点知识拍了些照片，挑几张自认为觉得还行的照片放在这里。\n第一张是在中街用适马 17-50 拍的，后面那几张是在买了适马 18-35 之后去辽宁省博物馆拍的，最后一张是笨蛋公主的 Q 版手办，也是用适马 18-35 拍的，这几张我就稍微调了颜色，没有其他后期，很久没练习拍照了，这几张图就看看就行。\n拿巨沉的人像广角镜头去拍实物特写，唉我真的是不知道咋想的……\n","permalink":"https://blog.starry-s.moe/posts/2023/canon-eos-r7/","summary":"\u003cp\u003e年初逛了一趟漫展之后突然想换新的相机了，因为对手里的 EOS 800D 成像不是很满意，暗光的高感表现很差，ISO 800 的时候 RAW 格式稍微拉一下阴影就会出现许多噪点，所以打算换个更专业点的相机，开拓些新的领域。\u003c/p\u003e","title":"“关于我逛了一趟漫展然后换了新的相机和镜头这件事”"},{"content":"为了让咱的 NAS 长时间稳定运行，斥巨资买了一台 APC BK650M2-CH，在 Arch Wiki 上看 APC 的 UPS 对 Linux 的支持比较友好，于是挑了个最便宜的带停电自动关机的 APC UPS，防止咱啥时候忘了交电费导致停电数据受损。\n参烤链接: APC UPS - ArchWiki\nUPS 到手后花了半个多小时读使用说明书，然后第一件事是把 UPS 的断电报警蜂鸣器关掉，省得我不在公寓的时候停电了 UPS 叫个没完吵到邻居。\n之后在装 UPS 之前先把我电脑支架背面一团电线重新整理了一遍，现在是台式机、显示器、NAS、光猫、路由器、无线 AP 都放在一起了，他们的电源线、网线、数据线、显示器线都团在了一起，整理起来炒鸡麻烦。\n先把漏油器、光猫和 NAS 的电源都插 UPS 上，然后接好 UPS 的 USB 数据线到 NAS 上。\n安装 apcupsd 安装 apcupsd，然后 systemctl enable --now apcupsd.service。\n$ sudo apcaccess status APC : 001,036,0869 DATE : 2023-01-08 11:09:23 +0800 HOSTNAME : ApertureNAS VERSION : 3.14.14 (31 May 2016) unknown UPSNAME : ApertureNAS CABLE : USB Cable DRIVER : USB UPS Driver UPSMODE : Stand Alone STARTTIME: 2023-01-02 23:57:44 +0800 MODEL : Back-UPS BK650M2-CH STATUS : ONLINE ...... 先把 NAS 里所有的应用都停掉，之后编辑 /etc/apcupsd/apcupsd.conf，把 TIMEOUT 改为 1，然后给 UPS 断电，这时 NAS 会自动关机。\nUPS 重新连接电源后，NAS 可能会自动开机，我的 NAS 是这样，但不确定所有 NAS 都这样。\n配置自动休眠 按照 Wiki 配置停电后自动休眠 (Hibernate / 休眠到硬盘)。\n在此之前，需要创建 swap 分区 (或 swap file)，然后配置休眠需要的内核参数并重构 initramfs。\n以 root 用户创建 /usr/local/bin/hibernate：\n#!/bin/bash # Hibernate the system - designed to be called via symlink from /etc/apcupsd # directory in case of apcupsd initiating a shutdown/reboot. Can also be used # interactively or from any script to cause a hibernate. # 可以在这里加一些在休眠之前执行的操作，例如让 bot 发个邮件提醒停电了之类的 # Wall message # 广播消息 wall -n System will be hibernate soon sleep 1 # Do the hibernate # 执行休眠 /usr/bin/systemctl hibernate # At this point system should be hibernated - when it comes back, we resume this script here # 现在，系统应当已经休眠了，当系统恢复运行的时候，脚本会继续从这里执行 # 可以在这里加一些在系统恢复之后的操作，例如让 bot 发个邮件提醒电力恢复了啥的 # On resume, tell controlling script (/etc/apcupsd/apccontrol) NOT to continue with default action (i.e. shutdown). exit 99 别忘了赋予可执行权限。\n# chmod +x /usr/local/bin/hibernate 创建软链接把脚本链接到 /etc/apcupsd 目录下面。\n# ln -s /usr/local/bin/hibernate /etc/apcupsd/doshutdown 此时给 UPS 断电后，NAS 会自动休眠，等一两分钟 NAS 会完成休眠，但 UPS 仍处于运行状态没有关机，长时间停电的话，UPS 的电量会耗尽。\nUPS 接回电源后，NAS 会从休眠中恢复。\n配置休眠后关闭 UPS 电源 创建 /usr/lib/systemd/system-sleep/ups-kill：\n#!/bin/bash case $2 in # In the event the computer is hibernating. hibernate) case $1 in # Going into a hibernate state. pre) # See if this is a powerfail situation. if [ -f /etc/apcupsd/powerfail ]; then echo echo \u0026#34;ACPUPSD will now power off the UPS\u0026#34; echo /etc/apcupsd/apccontrol killpower echo echo \u0026#34;Please ensure that the UPS has powered off before rebooting\u0026#34; echo \u0026#34;Otherwise, the UPS may cut the power during the reboot!!!\u0026#34; echo fi ;; # Coming out of a hibernate state. post) # If there are remnants from a powerfail situation, remove them. if [ -f /etc/apcupsd/powerfail ]; then rm /etc/apcupsd/powerfail fi # This may also exist, need to remove it. if [ -f /etc/nologin ]; then rm /etc/nologin fi # Restart the daemon; otherwise it may be unresponsive in a # second powerfailure situation. systemctl restart apcupsd ;; esac ;; esac 赋予可执行权限：\n# chmod +x /usr/lib/systemd/system-sleep/ups-kill 接下来给 UPS 断电，NAS 会自动休眠，等 NAS 休眠后再过几分钟 UPS 也会关机。\nUPS 关机后，给 UPS 接上电源，这时 UPS 会自动开机，然后 NAS 也会从休眠中恢复。\n不要在 UPS 还没关机的时候给 UPS 重新接回电源，会导致 UPS 关机后 NAS 刚从休眠中恢复就被强制断电。\n其他 折腾 UPS 的时候顺手给 NAS 换了个散热器升级了一下内存。AMD 原装散热器有亿点点吵所以换成了咱之前买的 ITX 散热器。\n用咱写的 telebot 查看一下空载时的 CPU 温度才不到 30 度。\nCPU: +28.2°C Uptime: 0.15 Hour TotalRAM: 46.45G FreeRAM: 42.66G AvailableRAM: 43.91G TotalSwap: 46.00G FreeSwap: 46.00G 运行一个虚拟机一个 MineCraft 服务器，CPU 温度不到 40，所以很安静。\n但是 UPS 它有噪音，晚上睡觉的时候能听见 UPS 它嗡嗡响，比 AMD 散热器的风扇动静还大，这个实在是无解，算了就先这样吧。\n","permalink":"https://blog.starry-s.moe/posts/2023/apc-ups/","summary":"\u003cp\u003e为了让咱的 NAS 长时间稳定运行，斥巨资买了一台 APC BK650M2-CH，在 Arch Wiki 上看 APC 的 UPS 对 Linux 的支持比较友好，于是挑了个最便宜的带停电自动关机的 APC UPS，防止咱啥时候忘了交电费导致停电数据受损。\u003c/p\u003e","title":"入手一台家用级 APC UPS"},{"content":"2023 新年快乐。\n","permalink":"https://blog.starry-s.moe/posts/2023/hello-2023/","summary":"\u003cp\u003e2023 新年快乐。\u003c/p\u003e","title":"Hello 2023"},{"content":"差不多去年的这个时候尝试过用树莓派插移动硬盘的方式试探性的组装了一个 NAS，但实际上用了不到两天这个方案就被废弃掉了……\n起因 不用树莓派的原因是，它是 ARM 架构的微型“电脑”，Arch Linux 官方只支持 x86_64 架构的系统，Arch Linux ARM 准确来说实际上是个第三方的系统。 然后树莓派的性能很差，只有一个板载网卡和 2.4G 无线网卡（我手里的是树莓派 3B），所以这玩意实际上更适合做嵌入式什么的，或者给初学者折腾入门 Linux 来用（但是看了眼现在树莓派的售价，我想应该不会有初学者买树莓派入门 Linux 了）。\n后来买了 NanoPi R4S 软路由，它内置了一个 RK3399 CPU，虽然也是 ARM 架构但是性能对于软路由来说很够用了，当时也是给它折腾了 Arch Linux ARM 系统还依次尝试了 systemd-networkd 和 netctl 给它的两个网口配置路由，但折腾归折腾，这种方式并不稳定，在日常使用过程中经常遇到重启路由器后上不去网的情况，还要手动 SSH 到路由器中再重启一次网络服务和防火墙才恢复。虽然手动改网络组件的配置文件的方式配置个路由器更底层些，这个过程也能更好的体会到路由器的一些原理，但是这种方案并不适合长期日常使用，我可不希望动不动家里路由器莫名其妙就断网了还要手动 SSH 到系统里查一堆日志后才能重连网络。\n之后我把手里的 R4S 卖掉了，因为 NanoPi 新发布了性价比更高且功耗更低的，拥有俩 2.5G LAN 网口，还有一个 M2 插槽和内置了 8G 闪存的 R5S。我给它安装了更适合路由器使用的基于 OpenWRT 构建的 FriendlyWRT 系统，这个系统内置了 Docker 和一些常用的应用（网络共享、Aria2、硬盘自动休眠之类的），在把光猫改桥接后，用它来做我的主路由器。然后把手里一块空闲的 2T 移动硬盘连接到路由器上，设置了 OpenWRT 的网络共享 (Samba) 服务后，实验性的当作我的 NAS 来使用。\n之所以是“实验性”的“NAS”，是因为我不确定 USB 连接移动硬盘的方式是否稳定，因为移动硬盘对供电有一定要求，我并不确定路由器的 USB 接口能否稳定的为硬盘供电，就算连接一块硬盘供电够用的话，我不确定连接两块以上的硬盘组磁盘阵列还能不能带得动，尽管这个问题能通过一根 USB 供电线来解决，但是我那半个巴掌大小的路由器上面既要插三根巨粗无比的 7 类网线，又要插硬盘和 USB 供电线，还要再占用一个插座插一个手机充电器给移动硬盘供电，这也太混乱了点，毕竟机械硬盘在读写过程中很怕震动，我在插拔网线或者插座上其他的电器时都避免不了的会对那块移动硬盘产生震动。\n然后路由器毕竟是路由器，你即要它负责整个家庭几十个网络设备的路由功能，又要跑 Samba 服务器，还要往里面装一些“上网插件”的话，对 CPU 的性能还是有一定要求的。因为我的路由器和电脑都有 2.5G 网口，所以我实际测试过当通过 Samba 拷贝文件的速度接近于 200MB/S 时，路由器的 CPU 4个核心就会全跑到 100%，然后拷贝就卡住了，时间久了文件就拷贝失败了（然后我不得不又设置了 QoS 把 2.5G 的网口限速成千兆网口）。\n所以最好的办法还是把 NAS 和路由器分开，路由器就用来做路由器该做的事情，NAS 就做 NAS 该做的事情。\n以上就是我组装 NAS 的整个心路历程，如果觉得上面这一大堆太磨叽的话，直接看下面就好了。\n配置清单 机箱：乔伯思 N1 主板：映泰 B550T-SILVER ITX CPU：AMD R7 5700G 内存：英睿达 8G 2666 固态：闪迪 500G NVME 硬盘：东芝 MG08ACA16TE * 1 电源：Tt SFX钢影 450W 其他：乐扩 4 口 2.5G PCIE 网卡 系统盘是之前折腾软路由时剩下的一块 500G 的 NVME 固态，除此之外双十一的时候还买了一块东芝的 16T 企业盘。\n本来想把除硬盘外的整体预算控制在 2K 以内的，但实际上光主板 + CPU 就两千多了……\n在深水宝上有更便宜的 5600G + B450 ITX 套装，但是这种来路不明的主板和散片 CPU 尽管便宜了几百块钱但是我也不知道它的 CPU 有没有“锻炼”过，主板有没有换过啥零件，反正我是不敢买。所以挑了好久，决定提高了预算，在狗东买的全新的板 U 套装，选的这个带板载 2.5G 网卡的主板，毕竟我可不想贪小便宜吃大亏。\n散热器目前用的是 AMD 盒装 CPU 带的散热，听说这个散热器在拆的时候极有可能会把 CPU 连根拔起，但是我有一个闲置的利民的 itx 散热器放在老家了没拿过来，所以现在只好先用原装的过度一下。\n本来是没打算买机械硬盘的，想着先用移动硬盘连在 NAS 上先用一阵子的，不过双十一硬盘便宜了好多，信用卡分三期还能再减 50，所以就先买了一块，估计够我用很长时间的了。\n装机 映泰的这块板子是不带无线网卡的，但送了一个 WIFI5 的无线网卡，需要手动安装上去，当时废了九牛二虎之力才接上了这两根 SMA 线……。\n然后走线的过程其实还挺顺利的，插上主板 24PIN、CPU 8PIN 和 SATA 供电以及风扇、机箱前面板跳线和 USB、音频线之外就完事了，找一些空隙把这些线绑起来就好了，说实话走线的过程可比之前给先马趣造装机容易多了，毕竟少了两根显卡供电线和一堆风扇的电源线还有 RGB 灯的线……\n装系统 NAS 的系统我采用的是 Arch Linux。首先，选一个 NAS 的系统肯定要优先考虑更适合做服务器的 Linux，其次 FreeNAS 这个系统是基于 FreeBSD/Unix 的，我就是单纯的不想用 BSD 所以就把它排除在方案外了（但是 NAS 里装一个虚拟机跑 FreeNAS 也不是不可以），至于网上总能听到的黑群晖我对这种盗版 + 闭源的系统很反感，所以想都不要想了。提到 Linux 的服务器发行版肯定有人更偏向于 Debian 以及 Debian 衍生的服务器系统以及红帽系列的被经常用在服务器的那些企业常用 Linux 系统，但是我只想用我熟悉的 Arch Linux。Arch Linux 的 Wiki 中有介绍过，Arch Linux 的思维是这个系统并不针对某类应用场景，而是让 Arch 的用户自己配置自己的系统来应用在哪些场景，所以理论上是可以把 Arch Linux 配置成一个适合应用在服务器上的系统，实际上也有 vps2arch 这个“黑魔法”脚本可以一键把 VPS 上已安装的其他 Linux 系统转成 Arch Linux。如果在这里你非要和我较真哪个 Linux 发行版好，哪个 Linux 发行版不好的话，我觉得这并不属于一个技术范围该讨论的问题而是一个哲学问题。\n安装教程在 Wiki 上就能找到，这里不再赘述，安装系统时需要装一些网络相关的软件，我配置网络使用的是 netctl，因为觉得 systemd-networkd 不怎么好用，我对 NetworkManager 不怎么熟悉所以就没装这个。然后配置无线连接时还需要用到 wpa_supplicant。\n配置网络 我的 NAS 上面一共有 5 个网口，其中一个网口为板载的 2.5G 网口，另外四个网口为 2.5G 的 PCIE 网口，我当初买这个 PCIE 网卡的时候想的是给它配置个桥接当交换机来用，这样只买一块网卡肯定比买个 4 口交换机便宜，因此装系统后配置网络这部分是重头戏，Arch Linux Wiki 上对配置桥接这部分只是简单介绍了几句就完事了，所以这部分我足足花了两个晚上才全部搞定。\n首先创建 netctl 的配置文件 /etc/netctl/bridge-br0 (文件名可以随意修改)，新创建一个虚拟的桥接接口 br0，这个虚拟的桥接网口绑定了上述的5个网口。我打算将板载的网口 (enp9s0) 连接路由器，然后那 4 个 PCIE 网卡的接口 (enp3s0 - enp6s0) 用来连接其他网络设备，所以要将 br0 的 MAC 地址设定为 enp9s0 的 MAC 地址。\n$ cat /etc/netctl/bridge-br0 Description=\u0026#34;Example Bridge connection\u0026#34; Interface=br0 # 接口的名称 Connection=bridge # 桥接模式 BindsToInterfaces=(enp9s0 enp6s0 enp5s0 enp4s0 enp3s0) # 将 br0 绑到 5 个物理网口上 MACAddress=enp9s0 # 设定 br0 的 MAC 地址与 enp9s0 接口的 MAC 地址一致 IP=dhcp # 以 DHCP 的方式为 br0 获取 IP 地址 除此之外还要配置 enp9s0 接口的配置文件 /etc/netctl/noip-enp9s0，不要让这个接口自动获取 IP 地址。\n$ cat /etc/netctl/noip-enp9s0 Description=\u0026#39;Example configuration\u0026#39; Interface=enp9s0 Connection=ethernet IP=no 之后执行以下命令使以上两个配置文件生效。\n# netctl enable bridge-br0 # netctl start bridge-br0 # netctl enable noip-enp9s0 # netctl start noip-enp9s0 顺利的话，执行 ip addr 可以看到新增加了一个 br0 网口 （不顺利的话就重启一下，再检查一下除了 netctl 之外是不是有别的配置网络的应用产生了干扰），然后原有的 5 个网口都绑定到了 br0 接口上了（接口的那一行出现了 br0）。\n然后 enp9s0 接口正常来讲是不应该从路由器上获取到 IP 地址的了，取而代之的是 br0 接口从路由器的 DHCP 服务器中获取了一个 IP 地址，然后 br0 接口的 MAC 地址和 enp9s0 接口的 MAC 地址都一致才对。\n以下是一个简单的栗子，在不考虑 IPv6 的情况 ip a 的输出是类似酱紫的：\n$ ip addr 1: enp3s0: \u0026lt;NO-CARRIER,BROADCAST,MULTICAST,PROMISC,UP\u0026gt; mtu 1500 qdisc fq_codel master br0 state DOWN group default qlen 1000 link/ether ab:cd:ef:xx:xx:xx brd ff:ff:ff:ff:ff:ff 2: enp4s0: \u0026lt;NO-CARRIER,BROADCAST,MULTICAST,PROMISC,UP\u0026gt; mtu 1500 qdisc fq_codel master br0 state DOWN group default qlen 1000 link/ether ab:cd:ef:xx:xx:xx brd ff:ff:ff:ff:ff:ff 这里 enp3s0 - enp6s0 这四个接口的情况基本一致所以在此省略 ...... 5: enp9s0: \u0026lt;BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel master br0 state UP group default qlen 1000 link/ether f4:bb:22:xx:xx:xx brd ff:ff:ff:ff:ff:ff ...... 6: br0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether f4:bb:22:xx:xx:xx brd ff:ff:ff:ff:ff:ff inet 10.10.10.233/24 brd 10.10.10.255 scope global dynamic noprefixroute br0 valid_lft 1606601sec preferred_lft 1375801sec ...... 至此，NAS 是可以与路由器下的同一局域网内的其他设备互相访问的，然后检查下 /etc/resolv.conf 如果 DNS 配置正确了的话，也是可以访问到公网的，执行 curl baidu.com 是应该有返回的内容的。\n但是我们目前只配置了 NAS 自身的板载网口 (enp9s0) 与 br0 虚拟网口的桥接这部分，现在其他设备通过网线插到 PCIE 网卡的那4个接口是上不去网的。\n在计网课程中，老师曾反复强调路由器和交换机的区别，路由器是 OSI 七层模型中的网络层的设备，而交换机是第二层的数据链路层的设备，但光是这么讲的话，死记硬背是能记住这两个设备之间的区别，但这种知识实在过于抽象，很难真正的理解，况且这个“网络模型”是按照已有的网络设备给它拆分成不同的层的，而并不是先制定出了分层的标准然后让设备严格按照这个模型去制作的，所以现在市面上卖的网络设备并没有体现出所谓的分层，不同的网络层之间的界限实际上是很模糊的。在网上搜这方面资料的时候看到有人把路由器称作“3 层交换机”，而常说的那种交换机则称为“2 层交换机”。说实话我也没彻底的搞明白数据链路层和网络层以及路由器和交换机之间的具体区别，不过往简单了说，可以把路由器看成是一个根据 IP 地址在不同的网段之间分发数据的设备，而交换机是通过 MAC 地址，只在一个网段内分发数据的设备，市面上常见的售卖的“路由器”商品实际上是一个真正意义上的路由器 + 交换机 + DHCP服务器和其他组件的组合体，知道这些基本就够用了，再往详细了讲的话我也讲不明白了。\n然后修改 PCIE 网卡的 4 个接口 enp3s0 - enp6s0 的 MAC 地址和板载网口 enp9s0 的 MAC 地址一致，这样5个网口和虚拟的 br0 网口都使用同一个 MAC 地址，就能实现交换机的功能了，至于为啥要把 5 个网口的 MAC 地址都设置一致这个别问我，我也不到为啥，如果这里有哪些知识点有误，可以评论告诉我。\n因为 netctl 好像不支持修改接口 MAC 地址的操作，所以这里还是要用到 systemd-networkd 在开机时自动修改网口的 MAC 地址，在 /etc/systemd/network/ 中创建 00-enp3s0.link - 00-enp6s0.link 这 4 个配置文件。\n# cat /etc/systemd/network/00-enp3s0.link [Match] # 这个是网口原有的 MAC 地址 MACAddress=aa:bb:cc:dd:xx:xx [Link] # 这个是修改后的 MAC 地址 MACAddress=f4:bb:22:xx:xx:xx NamePolicy=kernel database onboard slot path 确保 /etc/systemd/network/ 中没有其他的配置文件后，systemctl enable --now systemd-networkd 启动 systemd-networkd，在重启电脑后 5 个接口的 MAC 地址就都一致了。\n至此交换机这部分就配置完了。\n配置 Samba 目前我还没有机械硬盘，只有一个移动硬盘通过 USB 连接到了 NAS 上，目前我使用的是 hd-idle 配置了硬盘的自动启停。\n$ sudo hd-idle -a /dev/sda -i 300 然后安装 samba，在 /etc/samba/ 目录下创建 smb.conf，具体的过程请参照 Wiki。\n我把我的 16T 硬盘格式化成 btrfs 后挂载到了 /samba/hdd_16t_1 目录下面，然后对应的 Samba 配置文件为：\n[HDD16T1] force user = root comment = HDD 16T 1 path = /samba/hdd_16T_1 valid users = samba public = no writable = yes browsable = yes printable = no create mask = 0644 directory mask = 0755 read only = no 我打算只在内网访问我的 NAS，我还不打算把它暴露到公网上，所以目前不用太考虑安全的问题。\n然后我目前不考虑组 RAID，首先是因为没钱再买硬盘了，其次是 RAID 并不适合作为冗余备份使用，它没办法保证数据的绝对安全，所以如果我要存重要的数据的话，还是要往别的移动硬盘里也拷贝一份的，所以目前来看 RAID 我暂时用不上。\n东芝这块盘收货之后，我用 Samba 往里面烤了俩小时文件没遇到失败的情况，速度一直维持在 100MB/s 以上很稳定，至于噪音的话，白天是感觉不出来 NAS 的声音的，晚上因为配置了硬盘自动停转所以只要睡觉时不用它下载东西的话也是听不到声音的。\n其他 之所以买了 8 核 16 线程的 CPU 是因为我除了让它做 Samba 服务器之外还打算在上面跑一些别的服务啥的，目前除了 Samba 之外我在上面跑了 qemu KVM 虚拟机，然后在局域网搞了 Kubernetes 集群，因为公有云价格太贵了我自己租不起长时间的高性能 VPS，所以在本地起几个虚拟机装轻量级的集群用来学习 k8s 还是可以轻松实现的，不过我目前还没想好可以在集群里跑些什么东西。\n后续我打算把我的 MineCraft 单机生存的存档也放到 NAS 上面当服务器跑，这样就可以实现一些只有在服务器才能实现的操作了（比如挂个假人 24 小时挂机刷怪之类的）。\n以后有时间的话再写个 TeleBot 机器人啥的，用来远程监控 NAS 的状态。\nSTARRY-S\n","permalink":"https://blog.starry-s.moe/posts/2022/build-nas/","summary":"\u003cp\u003e差不多去年的这个时候尝试过用树莓派插移动硬盘的方式试探性的组装了一个 NAS，但实际上用了不到两天这个方案就被废弃掉了……\u003c/p\u003e","title":"NAS 装机记录"},{"content":"过了一个多月，多数植物的状态都有好转，期间土瓶草和几个状态很差的茅膏菜挂掉了，猪笼草新结了几个瓶子。\n图片由相机拍完后使用 GIMP 调整了尺寸、色温和曲线。\n","permalink":"https://blog.starry-s.moe/posts/2022/carnivorous-plant-221106/","summary":"\u003cp\u003e过了一个多月，多数植物的状态都有好转，期间土瓶草和几个状态很差的茅膏菜挂掉了，猪笼草新结了几个瓶子。\u003c/p\u003e","title":"食虫植物种植记录 - 2022.11.06"},{"content":" 想不懂咱是怎么忍住恐惧在大晚上的玩通关这游戏的公主线的……\n呐。那个，让我看看\nhttps://tsukihimecn.github.io/\n","permalink":"https://blog.starry-s.moe/posts/2022/tsukihimi/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/posts/2022/tsukihimi/images/1.png\" alt=\"\" /\u003e\n\n\u003c/p\u003e\n\u003cp\u003e想不懂咱是怎么忍住恐惧在大晚上的玩通关这游戏的公主线的……\u003c/p\u003e","title":"月姫 -A piece of blue glass moon-"},{"content":"一直想玩的游戏没有官方汉化，Switch 的游戏文件没破解的话是没办法装汉化插件的，尽管咱有 Switch OLED 港版主机，但是破解有被封的可能而且过程过于麻烦，破解后就不能联网了，所以咱在买了正版游戏但是看不懂日语后无奈之下选择了虚拟机，正好水一篇博客。\n目前有两个虚拟机可选，一个是 由 C# 编写的 Ryujinx，另一个是由 C++ 编写的 yuzu，这俩都是开源软件而且都能在 Linux 上运行，咱选的是后者。\nyuzu 提供的教程需要短接器和一张TF卡以及 switch 本体，从 switch 中获取 prod.keys 和 title.keys （非必须），喜欢折腾的可以买个短接器慢慢鼓捣，教程链接：https://yuzu-emu.org/help/quickstart/。如果懒得折腾的话从网上找个现成的 key 文件也能用。\nArch Linux 可以从 archlinuxcn 源或者 AUR 中获取。\nsudo pacman -S yuzu-git 第一次启动时会提示缺少 keys，可先忽略，选择左上角 File-\u0026gt;Open yuzu Folder，新建一个 keys 文件夹，将 prod.keys 复制进去后重启软件。\nyuzu 可以在不手动安装系统的情况下运行游戏，所以添加了游戏所在的文件夹就能玩了。\n然后就是在设置里面改一下手柄的按键布局，因为用习惯了 Xbox 手柄，所以咱把 A 和 B 位置对调了一下。\n后续：\nYuzu 2023-05-21 之后的版本对宝可梦做了些优化导致玩月姬时文字花屏乱码，玩月姬的话不要下载 2023-05-21 (1440) 之后的版本。\n然后 Arch Linux 最近滚完系统后遇到了 yuzu 的 Qt 启动失败报错：\nWarning: Ignoring XDG_SESSION_TYPE=wayland on Gnome. Use QT_QPA_PLATFORM=wayland to run on Wayland anyway. qt.qpa.plugin: Could not find the Qt platform plugin \u0026#34;wayland\u0026#34; in \u0026#34;\u0026#34; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: xcb. zsh: IOT instruction (core dumped) yuzu 查了一阵子找到的解决办法是设置 QT_PLUGIN_PATH=/usr/lib/qt/plugins 环境变量，覆盖掉 yuzu 安装包自带的 Qt 插件而是改用系统的。\n","permalink":"https://blog.starry-s.moe/posts/2022/switch-emulator/","summary":"\u003cp\u003e一直想玩的游戏没有官方汉化，Switch 的游戏文件没破解的话是没办法装汉化插件的，尽管咱有 Switch OLED 港版主机，但是破解有被封的可能而且过程过于麻烦，破解后就不能联网了，所以咱在买了正版游戏但是看不懂日语后无奈之下选择了虚拟机，正好水一篇博客。\u003c/p\u003e","title":"yuzu - Switch 虚拟机"},{"content":"重新捡起了弃坑多年的食虫植物系列。\n多图预警。\n咱其实很久以前就入坑了食虫植物，最早可以追溯到我念小学的时候，当时克服重重困难就为了养一两颗草，但是都没怎么养活过。后来念大学的时候因为许多原因不方便养所以弃坑了几年，大一还没有疫情的时候在暑假去了上海和杭州，大中午的顶着炎炎烈日坐了好几个小时的公交车从杭州市区到桐乡的“小虫草堂”实地参观了一番，当时拍了好多照片（感兴趣的可以看看这篇博客），疫情之后就再也没能去远一点的地方旅行过（两次实习除外），后来食虫植物这个玩意也逐渐被我抛在脑后很长时间没有去想过它。\n最近由于一些机缘巧合在研究地理学的太阳高度角与经纬度和节气之间的关系时（确信），无意间想起了我曾经养过的这群对生存条件要求非常苛刻的食虫植物，这个念头挥之不去，加上现在有了一定的养这玩意的基础，于是又重新入坑了这个系列。\n以下的图片都是植物邮寄到手缓了四五天后用相机拍的直出照片，没调颜色，没裁剪，只对图片压缩了尺寸。光照用的是全光谱的植物补光灯，因为是新到的小苗，很多植物状态并不太好还伴随着许多叶片的枯萎，因为懒加上没有镊子，所以有些植物的枯萎叶子没有修剪。后续如果养的好的话，也许会出新的系列专门记录一下。\n布凯茅膏菜\n某不知名的茅膏菜\n布凯茅膏菜\n新种植的活水苔（左）和不知名的瓶子草（右）\n白瓶子草\n土瓶草\n布凯茅膏菜\nFake Dracula\n爱斯捕虫堇\n后面还有几棵猪笼草，但是瓶子基本都枯萎了只剩绿油油的大叶子，所以就不拍照片了，等以后如果养活了再水一篇新的博客吧。\n","permalink":"https://blog.starry-s.moe/posts/2022/carnivorous-plants-1/","summary":"\u003cp\u003e重新捡起了弃坑多年的食虫植物系列。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e多图预警。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"食虫植物回坑小记"},{"content":"前一阵子通关了最终幻想7重置版，放几张截图到这里水一期博客。\n严重剧透警告：如不想被剧透请勿阅读本篇内容！\n卖花的大姐姐\nTifa\nAerith 的千层套路\nReunited\n云片好帅\n穿这么少的衣服，干的却是正经生意\n可爱捏\n爱丽丝老套路了\n比我想得还要可爱捏\n","permalink":"https://blog.starry-s.moe/posts/2022/finalfantasy-vii/","summary":"\u003cp\u003e前一阵子通关了最终幻想7重置版，放几张截图到这里水一期博客。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e严重剧透警告\u003c/strong\u003e：如不想被剧透请勿阅读本篇内容！\u003c/p\u003e\n\u003c/blockquote\u003e","title":"FinalFantasy VII Remake 游戏记录"},{"content":"最近搬了新的住处，用的是移动的宽带，因此尝试着把移动的光猫改成桥接，接到我的软路由上面。\n因为我不知道PPPoE拨号的帐号和密码，尽管这个光猫的超级密码网上一搜就能找到，但是我不知道PPPoE帐号的密码就算改了桥接也没办法拨号。 于是先借助网上能搜到的资料尝试把宽带帐号的密码给搞出来。\n一开始尝试着登录光猫的后台页面，在设置拨号上网的页面那里F12大法，把input元素的type=\u0026quot;password\u0026quot;改成type=\u0026quot;text\u0026quot;， 但是发现这里预填写的密码已经是加密过的******，因此这个方法行不通。\n然后看教程有说尝试打开光猫的telnet，把配置文件用ftp传出来，但是试了一下所有的尝试打开telnet的方式在这个光猫上都不好使，于是这个方法也行不通。\n之后在光猫登录管理员帐号之后，在“管理-\u0026gt;设备管理-\u0026gt;USB备份配置\u0026quot;这里找到了可以把配置文件备份到U盘的地方， 于是找了一张空内存卡格式化成FAT32，放读卡器里插在光猫上，把配置文件备份到U盘上。\n备份至USB\n这里备份之后不要立即把U盘拔下来，貌似光猫在备份完配置文件后没有立即把数据sync到U盘中，需要等一阵子再拔U盘。 等多久我也不确定，反复试几次直到U盘上出现了e8_Config_Backup文件夹就可以了。\n然后下载RouterPassView， 用这个工具打开配置文件，就可以找到里面光猫上的所有配置了，包括宽带帐号和密码。\n之后在网络设置里面改桥接，就可以用软路由拨号上网辣。\n使用了一下移动的宽带发现貌似他们把所有的ICMP的ECHO回显请求屏蔽掉了，所以尝试ping任何IP都是不通的。别的貌似没什么问题。\n","permalink":"https://blog.starry-s.moe/posts/2022/gm220-s-bridge-mode/","summary":"\u003cp\u003e最近搬了新的住处，用的是移动的宽带，因此尝试着把移动的光猫改成桥接，接到我的软路由上面。\u003c/p\u003e","title":"移动GM220-S光猫改桥接小记"},{"content":"之前买了个NanoPi R4S，当时给他装了Arch Linux ARM并用systemd-networkd配置了一个简易的软路由。不过systemd-networkd不支持PPPoE，所以当时我是把R4S接在租的房子的主路由下做子路由的，然后再给R4S接了一个小米路由器当作无线AP。最近从北京搬回家了所以想直接使用R4S做家里的主路由，因为R4S上手体验的那篇文章已经写完很久了，所以就不打算在那篇博客上做修改了，而是新开（水）了一篇博客。\n这里偷偷骂一下长城宽带没人反对吧\n准备工作 按照Arch Wiki的Router页面，你的电脑需要符合安装Arch Linux的基础硬件要求，且至少具备俩物理网口。\n个人觉得软路由没必要非得刷*WRT或者其他路由器专用系统，也没必要搞个爱快群辉什么的系统，我只想给他装我喜欢的发行版，然后我自己配置我需要的服务，只要有两个以上的物理网口就可以配置路由功能，给他们配置DHCP和流量转发就完事了，这样搞出来的路由器更符合咱自己的需求，相对来讲也更灵活一些，不用受限于那些路由器/NAS定制的系统，而缺点则是比较折腾，有可能不稳定。\n安装系统的步骤咱跳过不讲了，Wiki上有的东西没必要在这里重复一遍。\n配置IP地址 首先，将你电脑的两个物理网口一个用作WAN口（连接广域网），一个用作LAN口（连接局域网），有需要的可以自行修改网口的名称（通常默认的网卡名字为eth*，或者enp*s*）。 为了和Wiki同步，这里假设WAN口的名字为extern0，用来指连接到广域网的网口，LAN口的名字为intern0，代指连接到局域网的网口。\n本篇使用netctl配置网络，在修改配置文件之前，需要先停掉其他配置网络的服务。\n给LAN口配置一个静态IP地址。\n# /etc/netctl/intern0-profile # Config file for intern0 (LAN) Description=\u0026#39;Private Interface. (LAN)\u0026#39; Interface=intern0 Connection=ethernet IP=\u0026#39;static\u0026#39; Address=(\u0026#39;10.10.10.1/24\u0026#39;) IP6=\u0026#39;static\u0026#39; Address6=(\u0026#39;fdaa:aaaa:bbbb::0001/64\u0026#39;) SkipNoCarrier=yes 以上配置将为LAN口设定IPv4的地址为10.10.10.1，IPv6的地址为fdaa:aaaa:bbbb::0001。 你可以给这个网口设定任意的局域网IP地址，通常为10.*，172.*，192.168.*这些网段的任意一个地址， IPv6的局域网网段为fd00::/8，通俗一点讲就是fd**开头的一般都是局域网的IP地址。\n之后给WAN口配置DHCP或PPPoE协议。\n配置DHCP的方式自行翻Wiki或者看example，这里不重复讲了。\n在配置PPPoE之前需要安装ppp。\n# /etc/netctl/extern0-profile # Config file for public interface (WAN) Description=\u0026#39;Public Interface. (WAN)\u0026#39; Interface=extern0 Connection=pppoe User=\u0026#39;username\u0026#39; Password=\u0026#39;samplepasswd\u0026#39; # IP6=stateless # Always keep a connection established ConnectionMode=\u0026#39;persist\u0026#39; 使用以下命令启动netctl的配置文件。\nnetctl enable intern0-profile netctl enable extern0-profile 重启路由器，将WAN口与光猫的网口连接，使用ip addr查看网络设备的IP地址，顺利的话，可以看到一个名为ppp0的网口，并获取了一个运营商分给你的IP地址。\n1: intern0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether fa:97:da:d8:9d:8a brd ff:ff:ff:ff:ff:ff inet 10.10.10.1/24 brd 10.10.10.255 scope global intern0 valid_lft forever preferred_lft forever inet6 fdaa:aaaa:bbbb::1/64 scope global nodad valid_lft forever preferred_lft forever inet6 fe80::f897:daff:fed8:9d8a/64 scope link valid_lft forever preferred_lft forever 2: extern0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether ca:1f:4a:9b:29:df brd ff:ff:ff:ff:ff:ff inet6 fe80::c81f:4aff:fe9b:29df/64 scope link valid_lft forever preferred_lft forever 3: ppp0: \u0026lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP\u0026gt; mtu 1492 qdisc fq_codel state UNKNOWN group default qlen 3 link/ppp inet 123.123.123.123 peer 123.123.123.1/32 scope global ppp0 valid_lft forever preferred_lft forever inet6 240e:aaaa:bbbb:cccc:::eeee/64 scope global dynamic mngtmpaddr valid_lft 259132sec preferred_lft 172732sec inet6 fe80::aaaa:bbbb:cccc:dddd peer fe80::aaaa:bbbb:cccc:dddd/128 scope link valid_lft forever preferred_lft forever 如果遇到了问题，可以使用systemctl status netctl@extern0\\\\x2dprofile.service查看一下错误信息。 如果是认证失败的话，重启几次这个service说不定就好了。\n配置DNS和DHCP 安装dnsmasq，编辑/etc/dnsmasq.conf。\n# Setup listen address listen-address=10.10.10.1,127.0.0.1 # Do not read /etc/resolv.conf no-resolv # Use following dns servers server=114.114.114.114 server=8.8.8.8 server=8.8.4.4 # Bind interface interface=intern0 # Setup domain expand-hosts domain=foo.bar # Setup IPv4 DHCP dhcp-range=10.10.10.100,10.10.10.255,255.255.255.0,12h # Setup IPv6 DHCP dhcp-range=fdaa:aaaa:bbbb::000a, fdaa:aaaa:bbbb::ffff, 64, 12h 使用systemctl enable --now dnsmasq.service启动dnsmasq， 之后重启路由器，使用网线连接将电脑连接到路由器的LAN口，顺利的话可以自动获取一个IP地址。\n如果没获取到IP地址的话，有可能是DHCP服务器的问题，先尝试在电脑上手动设置一个IP地址，之后尝试ping路由器的IP（10.10.10.1）。 如果还是无法连接到路由器的话，就需要重新检查一下路由器的配置了。\n网络共享 首先参照Wiki，开启数据包转发的功能。\n之后安装iptables，配置ipv4和ipv6的流量伪装。\niptables -A FORWARD -i intern0 -j ACCEPT iptables -A FORWARD -o intern0 -j ACCEPT iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT iptables -A FORWARD -i intern0 -o ppp0 -j ACCEPT iptables -t mangle -A FORWARD -o ppp0 -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu ip6tables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE 之后可使用iptables-save -f /etc/iptables/iptables.rules和 ip6tables-save -f /etc/iptables/ip6tables.rules将ip桌子的规则保存下来。\nDone 以上配置完成后，按理来说路由器就已经配置好了。\n调试的过程为首先在路由器上尝试ping一个广域网的域名或IP地址（8.8.8.8），之后将路由器与电脑用网线连接， 电脑应当通过DHCP自动获取到一个随机的IP地址。 之后在电脑上尝试打开一些理应能打开的网站，应该是能打开的。\n如果能电脑可以ping通一个广域网的IP，但是打不开网站的话，就检查一下路由器DNS配置， 如果路由器上能ping通一个广域网的IP，但电脑连IP地址都ping不通，那就去检查一下ip桌子的流量伪装规则，检查一下网口名字有没有写对之类的。\n之后如果一切都调试成功的话，就可以把家里的无线路由器改成“有线中继”模式了，这样家里的无线路由器将只作为一个无线AP使用，路由的功能将全部由刚刚配置好的软路由实现。\n配置好“有线中继”模式后，电脑连接无线WIFI后获得的IP地址应当是软路由分配的IP地址，网段为刚刚咱们设置的10.10.10.*， 而不再是192.168.*的IP地址了。\n","permalink":"https://blog.starry-s.moe/posts/2022/archlinux-router/","summary":"\u003cp\u003e之前买了个NanoPi R4S，当时给他装了Arch Linux ARM并用\u003ccode\u003esystemd-networkd\u003c/code\u003e配置了一个简易的软路由。不过\u003ccode\u003esystemd-networkd\u003c/code\u003e不支持PPPoE，所以当时我是把R4S接在租的房子的主路由下做子路由的，然后再给R4S接了一个小米路由器当作无线AP。最近从北京搬回家了所以想直接使用R4S做家里的主路由，因为\u003ca href=\"/posts/2022/nanopi-r4s/\"\u003eR4S上手体验\u003c/a\u003e的那篇文章已经写完很久了，所以就不打算在那篇博客上做修改了，而是新开（水）了一篇博客。\u003c/p\u003e","title":"在Arch Linux上配置软路由"},{"content":"前两天下单了个Nano Pi R4S，4G内存的版本。通常情况下这玩意别人都把他当软路由用，但是今天咱收到货后想了一会拍大腿一寻思这玩意不就是个ARM架构的小电脑嘛~\n所以咱暂时先不打算给这玩意装OpenWRT或 *WRT这类的路由器系统了，而是把它当成一个超小号的带俩网口的mini主机折腾。\n开箱 USB 3.0、SD卡插槽以及三脚架接口\n供电接口和网口\n正面\n拆解 咱收到货后第一件事就是找螺丝刀和塑料卡片把这漏油器拆开看看（\n主板正面\n芯片的布局可以在R4S的商品页面查到，官方Wiki上也有更多关于R4S的介绍。\nArch Linux ARM 在Arch Linux ARM (简称alarm) 官网上没找到对R4S的官方的支持，简单搜了一下armbian有对R4S的官方支持。\n因为用惯了滚动更新发行版，所以不想用*bian系统，而*WRT系统的软件包相对其他发行版而言更少一些，系统也相当于被魔改过，所以除了做漏油器之外几乎干不了别的，所以这是我想安装Arch Linux的理由。\n然后咱搜到了一篇给NanoPi R2S安装alarm的教程，评论里有人提到了给R4S安装也是可以的。\n所以咱大致把这个教程翻译一下，再修改一些R2S和R4S在安装时的区别。\n以下内容需结合alarm的 aarch64通用安装教程食用，像更新pacman-key，ssh的密码之类的部分咱就不在这里重复了。\n准备SD卡 下载armbian的镜像，下载链接自行谷歌。\n通常下载好的文件是xz格式的压缩文件，需要使用unxz解压成img镜像。\n将armbian镜像的bootloader和uboot(32-32767区块的部分)用dd写到SD卡中：\n# Clean the sector before 32 dd if=/dev/zero of=/dev/sdX bs=1M count=32 # Write uBoot and bootloader dd if=Armbian_*.img of=/dev/sdX skip=31 seek=31 bs=512 count=32736 其实可以直接用dd把armbian的整个镜像写到内存卡中然后插入R4S开机，第一次开机后他会自动重新给内存卡分区，然后只需把/dev/sdX1格式化成ext4就能安装alarm了。\n使用fdisk给内存卡分区并格式化文件系统\n创建分区时先按o创建个MBR分区表，然后按n添加分区。第一个分区的起始区块(sector)需要设置为32768，通常情况下分一个区就够用了，或者你可以像我这样分俩区，一个给swap，不过实际没啥必要。\nDisk /dev/mmcblk1: 29.72 GiB, 31914983424 bytes, 62333952 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x33fc535e Device Boot Start End Sectors Size Id Type /dev/mmcblk1p1 32768 53944319 53911552 25.7G 83 Linux /dev/mmcblk1p2 53944320 62333951 8389632 4G 82 Linux swap / Solaris 创建完分区后，把root分区mkfs.ext4格式化成ext4，swap分区用mkswap格式化。\n解压alarm系统文件到root分区中\n复制并替换armbian的/boot中的文件到新建分区的/boot文件夹中。\n编辑/boot/armbianEnv.txt，更新rootdev的UUID 使用blkid或者lsblk -o+UUID可以查看UUID，注意是UUID不是PARTUUID。\n插电，开机 (此处不会出现五安大电牛)，网线连接R4S的WAN口到路由器的LAN口，第一次开机需要生成SSH Key所以时间会久一些，然后就可以ssh到R4S上去辣。\n内核 上述的安装步骤使用的armbian的内核，可以正常开机，但是想用Arch Linux stock aarch64内核的话，得替换一下DTB文件。（DTB文件是啥我目前还不清楚，如果后续弄明白了再更新到博客上吧）\nssh到R4S中，安装linux-aarch64。\n修改使用的DTB文件：\ncd /boot rm dtb ln -sf dtbs dtb 编辑armbianEnv.txt，在末尾添加一行fdtfile=rockchip/rk3399-rockpro64.dtb。\n在/boot/dtb/rockchip目录下是可以找到rk3399-nanopi-r4s.dtb文件的，但是目前用这个DTB的话会导致PCIE不能正常工作，导致LAN口无法使用。 dmesg的输出为：\ndmesg | grep pci [ 0.538310] ehci-pci: EHCI PCI platform driver [ 0.559708] ohci-pci: OHCI PCI platform driver [ 2.999933] rockchip-pcie f8000000.pcie: host bridge /pcie@f8000000 ranges: [ 2.999974] rockchip-pcie f8000000.pcie: MEM 0x00fa000000..0x00fbdfffff -\u0026gt; 0x00fa000000 [ 2.999987] rockchip-pcie f8000000.pcie: IO 0x00fbe00000..0x00fbefffff -\u0026gt; 0x00fbe00000 [ 3.000410] rockchip-pcie f8000000.pcie: no vpcie12v regulator found [ 3.500881] rockchip-pcie f8000000.pcie: PCIe link training gen1 timeout! [ 3.500944] rockchip-pcie: probe of f8000000.pcie failed with error -110 于是就先用rockpro64的DTB文件了。\n创建uBoot镜像和initramfs。\npacman -S uboot-tools mkimage -A arm64 -T ramdisk -n uInitrd -d /boot/initramfs-linux.img /boot/uInitrd-initramfs-linux.img ln -sf /boot/uInitrd-initramfs-linux.img /boot/uInitrd 创建个pacman的钩子，在以后更新linux-aarch64的时候自动的重新构建uboot和initramfs。\n在mkdir -p /etc/pacman.d/hooks目录下创建/etc/pacman.d/hooks/initramfs.hook\n[Trigger] Operation = Install Operation = Upgrade Type = Package Target = linux-aarch64 [Action] Description = Generate uInitrd Exec = /usr/bin/mkimage -A arm64 -T ramdisk -n uInitrd -d /boot/initramfs-linux.img /boot/uInitrd-initramfs-linux.img When = PostTransaction Depends = uboot-tools 重启，uname -a输出的应该是新版本的内核了。\n有个细节，用armbian的DTB文件时，开机后SYS LED灯是闪烁的，但是换到rockpro60的DTB文件后只有PWR灯长亮，别的灯都不闪了。\nRouter 虽然装的是Arch Linux ARM系统，但是这并不代表它不能作为一个路由器使用。\n系统默认用的是systemd-networkd管理网络，所以以下内容使用systemd-networkd配置路由器，暂时没遇到问题，如果不行的话我再换别的。\n参考: Router - ArchWiki\n重命名网络接口 这一步并非必须，但是我有遇到重启系统后网口从eth0变成eth1的情况，所以还是给网口重命个名好一些。\n首先移除并备份/etc/systemd/network中原有的配置文件。\ncd /etc/systemd/network # backup config files mv ./* /root/ 获取WAN口的mac地址。\ncat /sys/class/net/eth0/address 12:34:56:78:90:ab 创建10-extern0.link，重命名eth0到extern0。\n[Match] MACAddress=12:34:56:78:90:ab [Link] Description=WAN Name=extern0 另一个网口(LAN)在开机时systemd-networkd会自动给他重命名为enp1s0。\nWAN口配置DHCP客户端 这里我是把R4S的WAN口接到另一台路由器的LAN上，所以配置的是DHCP客户端。如果你打算直接把路由器接光猫，而且你的猫设置了桥接，那么你可能需要配置PPPOE。\n创建20-extern0.network。\n[Match] Name=extern0 [Network] DHCP=yes LAN口配置静态IP和DHCP服务器 给LAN口设置成另一个网络的静态IP地址，并配置DHCP服务器，给连接到LAN口的机器分配同一个网络下的其他IP地址。\n创建20-enp1s0.network。\n[Match] Name=enp1s0 [Network] Address=10.0.0.1/24 DHCPServer=true IPMasquerade=both [DHCPServer] PoolOffset=100 PoolSize=100 EmitDNS=yes # DNS=8.8.8.8 我这个配置是给LAN口设置了静态IP地址10.0.0.1，掩码255.255.255.0，启用了DHCP服务器， 设置了IPv4数据“伪装”(packets forwarded from the network interface will be appear as coming from the local host)。\n有关配置文件的参数可以使用man systemd.network查询。\n暂时还没搞懂怎么折腾IPv6，如果配置好IPv6的话我再补上……\n后续 之后咱装了JDK以及一堆我常用的小组件。为了测试性能，我把我以前备份的Minecraft服务器复制到R4S上跑了一下试试。我的服务器之前是在疼讯云学生主机上跑的(1核2G)，装了好多性能优化插件(lithium，phosphor，carpet\u0026hellip;)，版本是1.16.4，抱着尝试的心态跑了一下这个服务器结果发现很流畅，一开始区块加载的时候CPU的6个核心全跑满，之后就恢复到正常水平了。刚才尝试了一下长时间的生成区块貌似没什么大的问题，只要别一直用鞘翅跑图就行，应该是内存够用了所以运行效果要好一些，不过单核性能来讲的话肯定还是X86吊打R4S的。\n毕竟这就是半个巴掌大小的机器，跑MC的时候CPU温度才不到50度，应该不需要主动散热，功耗才十多瓦……\nMineCraft Server Performance\nArch Linux ARM\n参烤链接 NanoPi R4S NanoPi R4S - FriendlyELEC WiKi Installing Arch Linux AArch64 on the NanoPi R2S Generic AArch64 Installation | Arch Linux ARM Router - ArchWiki systemd-networkd - ArchWiki systemd.network(5) — Arch manual pages 在 NanoPi R2S 上安装 Archlinuxarm - 知乎 ","permalink":"https://blog.starry-s.moe/posts/2022/nanopi-r4s/","summary":"\u003cp\u003e前两天下单了个Nano Pi R4S，4G内存的版本。通常情况下这玩意别人都把他当软路由用，但是今天咱收到货后想了一会拍大腿一寻思这玩意不就是个ARM架构的小电脑嘛~\u003c/p\u003e\n\u003cp\u003e所以咱暂时先不打算给这玩意装OpenWRT或 *WRT这类的路由器系统了，而是把它当成一个超小号的带俩网口的mini主机折腾。\u003c/p\u003e","title":"NanoPi R4S上手 \u0026 安装Arch Linux ARM"},{"content":"之前咱自己搭过一个Miniflux服务器，不过当时用得并不频繁，逐渐的被咱弃用了。\n最近想订阅一些网站，因为使用RSS订阅的话，能收到更新提醒，不用经常的翻收藏夹去看页面内容有没有更新，使用RSS订阅的话也方便集中管理一些， 而且还能绕开推荐算法，只看自己想看的内容，这点还是蛮重要的。\n思考了几天发现我确实需要一个RSS订阅服务器后，于是决定这次把搭建过程记录下来，省得以后又忘了。\n准备 Miniflux官方文档（EN）：https://miniflux.app/docs/index.html\n安装 此部分配合官方文档食用：https://miniflux.app/docs/installation.html\n配置数据库： 首先需要安装postgresql数据库。安装方法因发行版而异，网上一搜就有。\n# Switch to the postgres user $ sudo su - postgres # Create a database user for miniflux $ createuser -P miniflux # Create a database for miniflux that belongs to our user $ createdb -O miniflux miniflux # Create the extension hstore as superuser $ psql miniflux -c \u0026#39;create extension hstore\u0026#39; # Change postgres password $ psql \u0026gt; \\password 安装Miniflux： 不同的发行版使用方法不一样，咱的这台服务器为Ubuntu，所以参照这里的教程配置APT源，安装Miniflux。\ncurl -s https://apt.miniflux.app/KEY.gpg | sudo apt-key add - echo \u0026#34;deb https://apt.miniflux.app/ /\u0026#34; | sudo tee /etc/apt/sources.list.d/miniflux.list \u0026gt; /dev/null apt update apt install miniflux 配置Miniflux 默认配置文件为：/etc/miniflux.conf。\n# See https://miniflux.app/docs/configuration.html LISTEN_ADDR=0.0.0.0:8080 LOG_DATE_TIME=yes DATABASE_URL=user=postgres password=\u0026lt;YOURPASSWORD\u0026gt; dbname=miniflux sslmode=disable # Run SQL migrations automatically # RUN_MIGRATIONS=1 之后线将刚刚创建的数据库用户miniflux设置为超级用户。\n$ sudo su - postgres $ psql \u0026gt; ALTER USER miniflux WITH SUPERUSER; 使用以下指令创建数据库表，并创建用户：\n$ miniflux -c /etc/miniflux.conf -migrate $ miniflux -c /etc/miniflux.conf -create-admin 之后将miniflux切换回普通用户。\n$ sudo su - postgres $ psql \u0026gt; ALTER USER miniflux WITH NOSUPERUSER; 最后重新启动miniflux。\n$ sudo systemctl restart miniflux 配置SSL（可选） 使用nginx转发流量，可以将服务器套在Cloudflare下面。\n编辑nginx的服务器配置文件，创建一个端口为443的服务器，并指定SSL key的位置：\nserver { listen 443 ssl default_server; listen [::]:443 ssl default_server; server_name miniflux; ssl_certificate /path/to/server.crt; ssl_certificate_key /path/to/server.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { proxy_pass http://127.0.0.1:8080; } } 之后执行sudo systemctl restart nginx，访问服务器地址即可。\nOthers Miniflux支持Fever和Google Reader等第三方服务，参考官方文档，可以在服务器的设置-\u0026gt;集成页面中配置，之后在别的设备中安装客户端，可以阅读订阅的文章，比网页版好用一些。\nSTARRY-S\n","permalink":"https://blog.starry-s.moe/posts/2022/miniflux-build/","summary":"\u003cp\u003e之前咱自己搭过一个Miniflux服务器，不过当时用得并不频繁，逐渐的被咱弃用了。\u003c/p\u003e\n\u003cp\u003e最近想订阅一些网站，因为使用RSS订阅的话，能收到更新提醒，不用经常的翻收藏夹去看页面内容有没有更新，使用RSS订阅的话也方便集中管理一些，\n而且还能绕开推荐算法，只看自己想看的内容，这点还是蛮重要的。\u003c/p\u003e\n\u003cp\u003e思考了几天发现我确实需要一个RSS订阅服务器后，于是决定这次把搭建过程记录下来，省得以后又忘了。\u003c/p\u003e","title":"自建RSS服务器：Miniflux"},{"content":"年初的时候买了先马趣造这个机箱，买这个机箱的主要的原因是先马鲁班太大了，之前买先马鲁班的时候没有考虑到机箱便携性的问题，因为台式机压根就没啥便携性可言。\n然额因为咱今年上半年要去北京，觉得台式机留在家里不用有些不忍心，所以某天在网上闲逛的时候看到了这款机箱。看了很多网上的评测视频后才决定入手。\n现在距离刚入手这台机箱已经过去一个多月了，前一阵子一直在忙所以没时间更新博客，于是直到现在咱才把换机箱这件事更新到博客上。\n配置 CPU、主板、显卡、电源、硬盘、CPU散热以及内存这些用的还是上一篇“我们来组装一台电脑吧”里面讲的配置。\n除此之外咱买了一个直径8CM的小风扇(ARCTIC P8)，和一个超薄的1.5CM厚的风扇(ID-COOLING TF9125)。\n配置方面没有太大改动，因为不打算装侧玻璃板，所以咱这次没有装RGB灯条。\n装机 最终的样子\n装机过程还是很顺利的，因为新机箱体积比较小，可供操作的空间有限，所以花了很长时间才装完。一开始还比较担心显卡太长会不会和右侧的ATX电源产生冲突， 不过华硕B550重炮手的主板的PCIE4X16是在第二槽，第一槽是个PCIE1，所以装上显卡后没有影响到右侧全模组电源的电源线， 但是显卡的底部空间很小，没办法塞下一个正常厚度的风扇了。\n机箱底部\n后来咱买了一个1.5cm厚的超薄风扇帮助显卡散热，不过风扇的尺寸咱买小了，本来应该买12cm的风扇咱买了个9cm的，到手后发现把风扇斜过来也能勉强固定住，于是就不打算换了。\n顶部\n正面\n机箱顶部用的是之前买的先马冰洞静音风扇，虽然不支持PWM调速但是很静音。然后因为右侧的空间被ATX电源占用了所以顶部只能装一个风扇。\n发热量大户实际上是显卡，CPU产生的热量很容易就能散开。所以所有风扇低速运行时，CPU和显卡的待机温度才比室温高十几度，只有玩游戏时CPU和显卡温度会高一些。\n把所有零件全部装上之后，就没有空间装机械硬盘了，不过还好我只有一块2.5寸固态硬盘，勉强塞在了前面板背面的硬盘位中。\n因为机箱空间有限，所以理线是个大难题，机箱几乎没有可理线的空间，所以我只好把一大团电线捆在一起。\n最终效果 最终效果\n白色机箱的确比黑色机箱好看很多，而且我反而觉得白色机箱更不容易脏一些，因为之前的黑色机箱手一摸就是油乎乎的大手印，但是这个白色机箱就没有。\n在网上看到有人在机箱前面贴苹果贴纸的，不过咱找了一下高中时买的Arch Linux贴纸，贴到了机箱顶部。\n趣造的机箱四面八方全是散热孔，所以就算咱把一个M-ATX机箱里面的所有东西全都塞到了这个小盒子里面，温度也并没有上升。要说影响的话，就是没有可以塞机械硬盘和摆手办的地方了（\n如果想塞机械硬盘的话，我得把我的ATX电源换成SFX电源。然后把CPU散热换成水冷或者下压式散热之类的，才能倒出空间装机械硬盘。不过咱买这个机箱目的就是为了能放到行李箱里面拉走，所以装机械硬盘的话容易在路上颠坏了。而固态就没这个担心。\n然后就是个人感觉先马趣造这机箱设计得还蛮不错的，机箱的所有地方都能拆，装机的时候可以先把机箱拆得只剩下一个铁架子，所以实际上装机没有增添太多难度。就是理线费劲了一些。全模组电源自带的模组线是真的硬。\n因为机箱小，去北京实习的时候咱买了个28寸的超大行李箱，于是这个行李箱在塞下这个机箱之后还能塞很多衣服。总之肯定是不会出现像上次那样坐高铁我一个人把机箱和显示器从北京扛回老家的情况了。\nSTARRY-S\n","permalink":"https://blog.starry-s.moe/posts/2022/sama-quzao/","summary":"\u003cp\u003e年初的时候买了先马趣造这个机箱，买这个机箱的主要的原因是先马鲁班太大了，之前买先马鲁班的时候没有考虑到机箱便携性的问题，因为台式机压根就没啥便携性可言。\u003c/p\u003e\n\u003cp\u003e然额因为咱今年上半年要去北京，觉得台式机留在家里不用有些不忍心，所以某天在网上闲逛的时候看到了这款机箱。看了很多网上的评测视频后才决定入手。\u003c/p\u003e\n\u003cp\u003e现在距离刚入手这台机箱已经过去一个多月了，前一阵子一直在忙所以没时间更新博客，于是直到现在咱才把换机箱这件事更新到博客上。\u003c/p\u003e","title":"电脑换壳——先马趣造"},{"content":"又到了写年终总结的时候了，说实话今年发生了好多好多好多的事情，我可能要写很久才能把这些事全写完。然而我文笔不好，回忆事情容易写成流水帐，所以不重要的事情我只好简短略过一下。\nGaming 容我翻一下去年的Todo List……\n今年在PS4上完成了三刷尼尔：机械纪元，全程没开简单模式和自动芯片，做完了大多数支线，然后除了DLC里的难度极高的斗兽场没有打，其他的DLC剧情全过了一遍，还看了几遍柏拉图的记忆。 顺便在B站会员购上买了两个尼尔的八音盒，曲子分别是Kaine和Weight of the world，尽管八音盒只能无限循环一小段，有种洗脑循环的感觉，但是偶尔听一下还是蛮好听的。 然后我应该是去年就把尼尔原著的短话就看完了，今年看的少年寄叶，不过只看了一半还没读完。长话因为和主线剧情一样所以我买来翻了几页就放起来了。 不得不说日本的游戏剧情支线真的特别多，全打完的话非常的肝，而且很费时间，不过发现了新的隐藏剧情还是很开心的。\n然后咱还在PS4上斥巨资买了正版的尼尔：伪装者，也就是机械纪元的前作（钱包在滴血），打通了一周目和二周目，然后因为时间原因加上后面剧情都是重复的，就没玩下去。尼尔：伪装者的游戏内容比机械纪元要少很多，而且可玩性比机械纪元差很多（本来机械纪元的游戏体验就不怎么好），所以这也是我玩不下去的原因之一。\n然后上半年的时候通关了传送门2单人模式，之前蛮期待的Nier:Reincarnation手游下载后看了几眼感觉不感兴趣没继续玩下去。然后月姬重置版只在日本发售，其他区服买不到，因为懒得换区加上不会日语，所以玩月姬的计划也被我抛在脑后。\n不得不承认咱的大部分时间都拿去打守望先锋了，这游戏玩上就有种停不下来的感觉，所以在守望上花了好多时间，然后经常在竞技模式里被气得卸游戏，过两天又想玩然后把它下载回来……\n其余时间还玩了一阵子Minecraft，完成了非常大的工程，在原点空置域修了全物品分类机，不过比较气愤的就是1.17新增了好多新的物品，我旧的全物品分类机装不下，然后1.18又在Y0至-64的高度区域生成新的洞穴，所以我之前的空置域又白炸了，所以我还在继续玩1.16.4，没有升级游戏版本。\n这么一回忆起来，怎么有一种我这一年的时间全荒废在打游戏的错觉……\nLearning 上面写的游戏经历只不过是一小部分而已，咱在今年买了Kindle PaperWhite4，看了《自控力》、《黑客与画家》这两本书，还二刷了《空之境界》原著，之后就是用Kindle看了一些技术类书的样章，不过在Kindle上有些书的代码是以图片的形式显示的，所以阅览效果并不好。\n咱还买了好多纸质书，都是技术相关的，因为大多都只是简单翻了几页，所以就不列举名字了，今年要是有时间的话就试着看几本吧。\n技术方面的话，咱今年靠着自己的努力尝试着写了一些程序，软件工程的大作业为了赶时间，用现学的前端知识和JS写了一个“能用”的问卷调查系统。不过后来我实在看不下去自己当时写的代码太不规范了，所以对代码进行了简单的整理和优化，顺便提高了一些安全性，不过和那些能稳定运行的大型软件相比肯定还是差远了。\n然后就是自学了点现代OpenGL，选了学校的计算机图形学选修课，不过老师讲课时用的老版本的GLUT进行画图，然后别的学生基本上就是上网找代码抄一下就交作业了，他们有些人甚至连透视都不知道是什么。\n所以我当时花了好多时间学OpenGL的矩阵运算和渲染方面的东西，这东西入门的门槛还真是挺高的。然后简单的了解了一下核心模式写Shader之类的操作，不过时间比较紧碰撞检测那些东西我就没学，所以最后给老师交作业时写了个比较简陋的世界模型，里面放了一个大正方形当作地面，然后渲染了几个正方体当作物体，贴了我的世界的材质…… 没弄碰撞检测和物理引擎之类的东西，用纯C语言写真的太难了。\n除此之外，咱学了一点GTK和Qt，用Qt写了软件工程结对编程的作业，然后用GTK写了个很简易的将多条视频合并成一个视频的小程序，挺多部分都是一边抄别人的代码一边学怎么写的，因为自己能力并不强，写的东西也都是勉强能用的程度，然后现在一回忆发现好多东西又都忘掉了。\nWorking 大三下半年我花了好多时间在网上找实习工作，然后因为我几乎没有准备就去面试，所以被问到算法题或者一些需要靠刷题和背书才能学会的知识时我几乎全答不上来，所以我挂了好多面试。\n额……因为我在此之前对秋招和春招之类的没有啥概念，我也没有找学长问这些经验，只靠着自己听老师和别的同学随口说的内容，现在回想起来当时自己纯粹是什么都不懂的状态在瞎找工作，也几乎没怎么考虑待遇和工作内容这类的十分现实的问题，在所有面试全都是被刷的情况下我去了最后一个同意我去实习的公司。\n我还记得我第一次面试时紧张得不得了，然后因为什么都没准备所以面试官问我所有的东西都答不上来，面试结束后就觉得我这种表现对面试官很不尊重。\n所以别问我实习和找工作相关的东西，我没办法给你任何有价值的参考意见，你看我这么胡扯的做法就能体现出来。\n所以要说结果的话，我在实习的时候放弃了继续工作的打算，开始向更多的实际问题思考，国庆假期回到家后，在研究生考试报名截止前两天报了本校的研究生考试，在距离考试不到两个月的时候辞职，12月初回学校，预习考试内容。\n很明显，我写这些东西的时候，已经考完了今年的研究生考试，结果可显而知，我得二战了。\n（亏我还能如此淡定的说出这些离大谱的东西）\n让我以一名阅读这些文字的访客的角度思考一下…… 好了别骂了别骂了，再骂孩子就吓得以后啥都不敢干了，我做了好多的心理准备才敢把这些事情写出来，要是有人骂的话我肯定忍不住要删掉的，毕竟万事开头难，咱已经吃过好多苦头了。\n我这只不过是一个什么都不懂的学生想凭借他的努力找到第一个实习工作的比较客观的真实反映而已，你看B乎上那些新编的故事有时候不能反映自己真实的情况，我承认我有些方法确实做得不够成熟……\n不过，这次实习我还是有很丰富的收获的，很幸运，我实习的公司对我很好，尽管任务量比较大，让实习生直接进行生产项目的开发，直接解决客户提的问题，但这些都还在能接受的范围内。 可能是因为咱刚接触这些领域吧，对这些还有一些新鲜感。\n我用实习的工资组装了一个台式机，就是之前博客里面写的那台电脑，当初从北京回家时因为快递拒收电脑，所以我扛着装电脑机箱和显示器的箱子坐高铁回家，别提有多狼狈了。\n在北京的这三个月的生活我可以用惨来形容，不用多说，你看我上面写的这些就能想到为什么惨了。\n只不过我没有在之前的几篇博客中提到这些事情而已，因为咱不想把技术类文章和这些琐事混到一起，说出来又解决不了什么实际问题。\n一提到实习这段经历就不由自主的把气氛搞沉重了，通过三个月的实习对北京这个城市有了一个新的认识，不过从自己眼中看到的事物并非是全面的，毕竟北京城太大了。\n因为缺乏生活经验，在北京自己一个人的生活可以用狼狈来形容。北京是个漂泊感很重的城市，在租房的那段时间几乎每天早晨起床时都会感受到一股强烈的孤独感，有一段时间每天都笼罩在几乎窒息一般的孤独当中，这可能是我最不愿回忆的一段经历了。\n中秋节假期前一天晚上想坐高铁回家，但是新修的北京朝阳站还没通地铁，节假日前一天晚上堵车非常严重，当时为了赶高铁我愣是从朝阳公园北门附近下公交车拎着公司发的中秋节礼品跑了4公里，不过还是没赶上那天的最后一趟高铁。\n国庆的时候抽时间回学校取我剩下的一些东西，回去的时候站在沈阳地铁上忍不住开哭。\n实习工作的时候每天都得长时间盯着电脑好几个小时没办法休息，很快我就发现自己起了很重的黑眼圈，有一天早晨坐地铁去公司的路上突然低血糖眼冒金星，到公司后头特别疼，于是不得不又请假，睡了一下午觉后身体十分难受，于是又请了一天假连着周末一起休息。\n我其实很不喜欢那种加班的时间去做无意义的摸鱼的事情，明明到了下班时间该收工走人了，却非要在岗位上刷一会手机赖着不走。上班的时间该干什么就干什么，而不是把加班当作一种很光彩的事，给老板创造价值可不是这么创造的，一个人每天能保持的比较旺盛的精力只有几个小时而已，而且人是需要一定时间进行思考的，真实的情况是程序员有时候一天的时间都很难写出来几十行优质的代码的，让一个人全神贯注十多个小时的干活这种事怎么可能呢？只不过是限制人身和思维的自由罢了，这样下去早晚会崩溃的，所以这也就是为什么现在有好多人只是为了完成目的而写代码的原因吧，他们几乎不在乎代码的完整性和可读性之类的东西，实现的功能都是复制粘贴东拼西凑搞出来的，还把代码行数作为编程能力的衡量标准，而且他们甚至连几本专业类的书籍都不愿意去看，嫌这种阅读书籍太浪费时间，而为了所谓的效率去看那些质量低、表面上是以教学为目的而实际上是推销自家编程课程的视频，你看现在随便在某视频平台一搜这类的关键字，有好多视频不都是这样吗？视频一直在推销公众号，评论区置顶了一堆群号和网盘链接，还真有很多人信。\n有一些人，看一点网课视频会调几个依赖库就可以写出很多绚丽的功能出来，报一个培训辅导班学几个月就能找工作，而做程序员的目的只不过是因为挣的钱多。所以现在研发人员的地位被搞得越来越低，甚至一说是程序员都被别人瞧不起。有的企业管理人员以为只要招一个会写代码的“农民工”，实现功能就够用了……\n算了不说了，果然变得过于敏感并不是什么好事，就算是选择考研也很难摆脱现如今的许多事实，撑不住了就只能开摆了。\n所以以上算是我一部分的考研的原因吧。辞职后的那段时间就算英语和政治能勉强速成一下，专业课几乎裸考，但是数学是真没复习完，更何况今年题变难了许多。\n不过回学校后内心还是十分沉重的，自己折腾了这么久落反而落得了这样一个结果，我还要和身边同学解释清楚为什么不继续找工作了，还要找些理由解释为什么考研。\n在学校待了三年有感情了，在离开学校后才意识到这一点。学校的老师在某些方面其实对我们学生非常好，给了学生很多不错的条件。缺点有是有，但是没必要总把那些问题挂在嘴边成天抱怨。\nOthers 换个话题吧，今年抽时间看了狼与香辛料，然后因为实在等不起国内的引进所以在网上找了资源看了FSN HF3。 Fate的HF线细节很多，音乐也很好听，剧情的节奏把握得也很不错，身为月厨的我看得十分满意。\n咱暑假的时候在B站会员购上预购了世嘉的卫宫家今天的饭的呆毛的手办，之后斥巨资预购了寿屋的两仪式再版手办。\n说实话真没想到能在2021年买到再版的空之境界的手办。\n11月底的时候付的尾款，组装后拍了几张照片。\n两仪式\n呆毛王\n以后不打算把太多时间花在游戏上了，至少我不想再像以前那样玩守望先锋了，其他比较缓和的游戏还是可以玩的。 之前在我的腾讯云学生版云主机上搭了一个小型的Minecraft服务器，主要是想和我的同学一起联机生存，年底进服务器发现他们盖了好多建筑，肥肠开心。\n其他游戏是真玩不下去了，以后还是得注重身体，从疫情开始到现在体重飙升至200斤了，最近经常熬夜搞得身体很不好，所以以后还是得注重身体。\n2022年咱可能要面临更多的问题，我暂时还有些不敢去想。还有半年就要大学毕业，然后还有好多我从来没经历过的事情需要去面对。\n所以还是尽可能的保持乐观吧，悲观解决不了任何实际问题。\n就写这么多吧，要是以后还想到了哪些东西再来补充。\n后续 在年终总结里加后续总显得有些怪怪的，但是最近这些事情我还是写到2021年的年终总结里吧，后续有什么事我可以再新开一篇文章（我是实在不想把2022年初发生的事情写到22年的年终总结里了）。\n事情就是，咱拿到了北京SUSE实习的offer。因为很中意这份工作，所以咱做了很长时间的心理准备，最后决定大四下学期回北京，继续租房子。\n嗯，要不是SUSE，俺是绝对不会再回北京的，别的公司联系我的话，我肯定会以考研为理由拒了。\nSUSE的面试非常的顺利，既是出乎意料又算是情理之中吧。\n所以我又一次花了很长时间，和学校的老师解释，和我以前的室友和新室友解释下学期我不回学校了。\n然后我又花了很长时间和家人解释，又一次的拿出很大的资金到北京来租房子。\n然后刚到北京就听说辽宁新出了许多的本土确诊病例……\n这次租房我坚决不自己整租了，首先是租不起，再就是自己一个人真的很孤独。\n然后就是，俺还没入职，所以后续的事我现在也没办法写。\n就这些。\nSTARRY-S\n","permalink":"https://blog.starry-s.moe/posts/2022/hello-2022/","summary":"\u003cp\u003e又到了写年终总结的时候了，说实话今年发生了好多好多好多的事情，我可能要写很久才能把这些事全写完。然而我文笔不好，回忆事情容易写成流水帐，所以不重要的事情我只好简短略过一下。\u003c/p\u003e","title":"Hello 2022"},{"content":"把吃灰了好久的树莓派带了过来，打算搞个NAS玩一下，简短的记录一下整个过程。\n这歌太魔性了哈哈哈哈哈……\n准备工作 树莓派以及所需的电源（废话） 16G以上的高速内存卡用来写系统镜像 硬盘（可以选择买移动硬盘或者直接买硬盘盒和机械硬盘自己组装） 网络设备：路由器、网线 （非必须）键盘、显示器、连接线等 树莓派我使用的是高一时买的树莓派3B（满满的回忆），硬盘是上半年为了存照片而买的西数2T移动硬盘，因为暂时闲置所以拿来一起组个云盘玩。\n内存卡需要质量好的不容易坏而且读写比较快的卡。\n装系统 系统咱安装的是ArchLinux ARM，安装教程直接看官方文档即可。\n一开始咱为了发挥树莓派3B的64位CPU的性能，我下载了64位的系统镜像，但是在配置无线连接的时候（可能是）驱动问题卡死，因为急着睡觉所以重新格式化内存卡后被迫安装32位的系统。\n安装教程咱就不重复写到博客里了，直接翻Wiki，尽管是纯英文的但是不难，都能看懂。咱就不打算在这翻译了。\n在格式化root分区时一开始想尝试一下树莓派上跑btrfs，但是开机时进了linux的救援(rescue)模式，懒得折腾还是老老实实换回了ext4，不然我一晚上不用睡觉了。\n在分区时除了boot和root之外，我额外分了2G的swap分区，树莓派1G内存有些小不过只是搭个人用的NAS的话实际上是不影响使用的。（这话咋读着这么别扭呢）\n因为咱要做NAS肯定得往树莓派上外接个硬盘之类的，树莓派3B只有USB 2.0 + 百兆网口，尽管速度很慢但是作为个人网盘来说不到10MB/S的速度还是比某些恶心网盘快很多的，在线看个1080P视频还是蛮轻松的，BD蓝光想想还是算了。\n把移动硬盘接到树莓派后lsblk查看一下分区表。因为咱这是块几乎全新的硬盘所以需要重新分区并格式化一下。\n如果你不熟悉在命令行上进行分区格式化的话，建议自行翻阅Wiki (fdisk)，因为往博客上写的话太难理解了别人肯定看不懂。\n最后咱把2T移动硬盘格式化成这个样子：\n# fdisk -l /dev/sda Device Start End Sectors Size Type /dev/sda1 2048 2147485695 2147483648 1T Linux filesystem /dev/sda2 2147485696 3907029133 1759543438 839G Microsoft basic data 其中的1T打算格式化为btrfs给Samba用，其余的800G打算格式化为NTFS留着给Windows当个移动硬盘。\n创建分区时别忘了更改分区类型，给Linux用的就是Linux filesystem，给Windows用的就是Microsoft basic data， 不然机械硬盘连接到Windows系统中将不显示分区，或者就是一直提醒你：该分区不可用，然后让你格式化，到时候一不小心点错了可是会丢数据的。\n安装btrfs-progs和ntfs-3g，之后格式化硬盘（NTFS还是建议到Windows系统中格式化）。\n格式化btrfs的时候加个-L参数设置分区的标签，这样方便在fstab中设置开机自动挂载。\n$ lsblk # 一定要看清楚自己格式化的分区名字 $ sudo mkfs.btrfs /dev/sdaX -L samba # -L 参数设置分区的标签 最后改一下/etc/fstab让设备在开机时自动挂载交换分区和移动硬盘。\n# \u0026lt;file system\u0026gt; \u0026lt;dir\u0026gt; \u0026lt;type\u0026gt; \u0026lt;options\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;pass\u0026gt; /dev/mmcblk0p1 /boot vfat defaults 0 0 LABEL=swap none swap defaults 0 0 LABEL=samba /samba btrfs defaults 0 0 重启系统后如果正常的话，分区会被自动挂载。\n配置网络 配置网络部分不适合在SSH中操作，建议使用显示器和键盘连接到树莓派上操作。\n除非你能保证你执行的每个命令都肥肠正确。\n无线网络 因为我电脑离路由器肥肠远，所以为了方便我还要给树莓派配置无线网络。首先照着Wiki上的netctl页面安装了wifi-menu所需要用的dialog，然后就用wifi-menu连接wifi了。不过为了方便以后连接，我需要给他设置静态IP：\n首先使用你比较喜欢的文本编辑器打开wifi-menu自动生成的配置文件，并修改成以下的样子\n# /etc/netctl.d/wlan0-YourWifiName Description=\u0026#39;Automatically generated profile by wifi-menu\u0026#39; Interface=wlan0 Connection=wireless Security=wpa ESSID=Your Wifi Name IP=static Address=(\u0026#39;192.168.xxx.xxx/24\u0026#39;) Gateway=\u0026#39;192.168.xxx.1\u0026#39; DNS=\u0026#39;8.8.8.8\u0026#39; Key=YOUR WIFI PASSWORD 其中修改Address为你想设置的CIDR地址、Gateway为默认网关、以及DNS。\n最后修改Key为Wifi密码（明文），如果需要加密的话可以去wiki上找相应方法。\n之后sudo netctl enable wlan0-YourWifiName设置好开机自动连接即可。\n这时候聪明的小伙伴会想到：我想使用网线联网并配置静态IP，该怎么办呢？\n配置有线网络 默认情况下，有线接口eth0使用systemd-network配置了DHCP，所以我们不需要改netctl的配置文件，只编辑/etc/systemd/network/eth0.network这个配置文件改成静态IP地址就好了。\n[Match] Name=eth0 [Network] Address=192.168.xxx.xxx/24 Gateway=192.168.xxx.1 DNS=8.8.8.8 重启系统后，使用ip addr检查设备的IP地址是否正确。\n配置防火墙 首先安装ufw。（因为对iptables不是十分熟悉，ufw比ip桌子好用一些，毕竟他叫Uncomplicated Filewall，所以咱先用ufw配置防火墙）\n食用方法请参见Wiki页面。\n因为咱打算搭一个Samba服务器，所以别忘了配置防火墙允许Samba的端口，按照Arch Linux Wiki：\n# Create or Edit /etc/ufw/applications.d/samba, add following content: [Samba] title=LanManager-like file and printer server for Unix description=Samba ports=137,138/udp|139,445/tcp 之后root账户执行ufw app update Samba加载配置文件，然后ufw allow Samba允许Samba的端口。\n如果你的树莓派上还装有其他服务（比如http，https等），别忘了ufw allow PORT开放端口，尤其是别忘了开SSH端口。\n最后ufw status查看防火墙状态信息，ufw enable开启防火墙。\nSamba 配合Arch Wiki食用。\n首先我们需要新建一个分组，然后在挂载的分区中新建一个文件夹作为Samba服务器的共享目录：\n$ sudo groupadd -r sambausers # 新建用户组 $ sudo usermod -aG sambausers username # 添加当前用户至分组中 $ sudo smbpasswd -a sambausers # 设置Samba用户的密码 $ sudo mkdir /samba/sharefolder # 新建文件夹用来存储共享的文件 $ sudo chown :username /samba/sharefolder # 修改文件夹的所属分组 $ sudo chmod 0770 /samba/sharefolder # 修改权限 （咱写的很详细了吧\n配置服务器 安装好samba安装包后，需要手动去/etc/samba/创建smb.conf配置文件，可以到Samba git repository中获取样例配置文件，咱只需要把它复制粘贴再简单修改一下就好了。\n# /etc/samba/smb.conf [global] # 修改工作组的名字 workgroup = MYGROUP # 服务器描述 server string = Raspberry pi Samba Server # 在文件末尾添加共享文件夹目录及相关配置 [sambashare] comment = Sample share file. path = /path/to/your/samba/folder writable = yes browsable = yes create mask = 0755 directory mask = 0755 read only = no guest ok = no # 允许访客随意登录 配置好文件后，启动smb.service和nmb.service\n$ sudo systemctl enable --now smb.service $ sudo systemctl enable --now nmb.service 访问服务器 咱GNOME用户直接打开文件管理器，选择左边的“+ Other Locations”，在底部输入服务器连接smb://192.168.xxx.xxx， 输入用户组、用户名和密码登录就可以访问共享文件夹。\nWindows系统中，首先需要到 控制面板-\u0026gt;程序-\u0026gt;启用或关闭Windows功能 里面，选中 SMB1.0/CIFS文件共享直通，保存后等一会安装完， 打开文件资源管理器输入地址\\\\192.168.xxx.xxx\\，登录后就能访问共享文件夹了。\nFrp内网穿透 配合frp文档食用更佳\n首先在frp的GitHub Release页面下载安装包。\n如果是树莓派用的话就下载arm版本的安装包即可。Arch Linux可以在ArchLinux CN源或AUR中安装frpc和frps作为客户端和服务端。\n# 树莓派上下载编译好的文件 $ wget https://github.com/fatedier/frp/releases/download/v0.37.1/frp_0.37.1_linux_arm.tar.gz # 解压 $ tar -zxvf ./frp_0.37.1_linux_arm.tar.gz $ cd frp_0.37.1_linux_arm/ # 编辑配置文件 $ vim ./frpc.ini $ ./frpc -c ./frpc.ini 客户端配置文件的格式可参考如下：\n[common] server_addr = server ip server_port = 6000 [samba] type = tcp local_ip = 127.0.0.1 local_port = 445 remote_port = 6003 其中端口号和token按需要自行更改，Samba服务的tcp端口号为445。\n服务端配置文件格式如下：\n[common] bind_port = 6000 为了安全，别忘了配置权限验证，同时别忘了修改服务器的防火墙设置。\nOthers 所以到此为止，咱的Samba服务器就搭建好了。\n随便传了个大文件试了一下，内网上传速度在6MB/S左右，有些慢但是还没搞清楚到底是什么原因导致的。\n","permalink":"https://blog.starry-s.moe/posts/2021/raspberry_pi_nas/","summary":"\u003cp\u003e把吃灰了好久的树莓派带了过来，打算搞个NAS玩一下，简短的记录一下整个过程。\u003c/p\u003e","title":"使用树莓派搭建一个NAS"},{"content":"很久很久以前就想自己组装电脑了，看到别人能有台高性能的电脑别提有多羡慕了。不过考虑到在校期间实在不适合把自己组装的电脑放到寝室中去，要是把电脑放家里的话只能假期玩短短的几星期，其余的时间闲置下来的话又觉得有些浪费，于是组装电脑的计划一直推延至今。最终在大四校外实习自己租房子之后才有了一个短暂而勉强稳定的环境可以让我组装台式机，所以在安置好自己的住处和一系列其他事情之后，我终于可以实现自己这个埋藏心底多年的愿望之一了。\n因包含插图，为了浏览体验我只对图片进行了适量压缩，\n网络不好的用户可能需要多花一些时间加载。\n配置清单 一边翻着某东的购物车一边写\nCPU + 主板: AMD Ryzen 5 5600X、华硕TFU GAMING B550M-PLUS (WI-FI) 共2477元 显卡: 撼讯 RX6600XT 红魔 3599元（之前的是实际买了技嘉 GeForce GT 730D3 529元) 内存: 英睿达 美光 DDR4 3200MHz 8Gx4 864元 固态硬盘: 西部数据 SN750 SE 1TB 929元 + 英睿达 美光 MX500 2TB 1299元 机箱: 先马 鲁班1 199元 电源: 长城 金牌电源 V7-700W 475元 CPU散热: 利民AK120 PLUS 169元 机箱散热: 利民 TL-R12 三个12CM风扇 119元 + 先马冰洞 风扇套装 3个12cm风扇49元 显示器：优派 VX2480-HD-PRO-3 165HZ 1143元 其他: 扎带5.5元 理线带 9.9元 追风者CMBO灯带 400mm两条 90元 因为我之前用笔记本时已经有一个 ikbc c87 红轴机械键盘和 罗技 G304 无线鼠标 以及之前弄拓展屏时买了 戴尔 U2419HS 显示器，所以这些配件我就不再列入装机清单里面了。\n排除显卡的话，整体配置全下来大概花了6.6K左右，有些配件是买完以后京东又降价了于是申请了价格保护退了一些回来。显卡打算以后等价格恢复正常后再买。所以现在买的是英伟达730D，尽管是亮机卡但是我还是决定多花一点预算去自营店买一张靠谱的全新卡，这样就算以后我换显卡了，这张旧的730还可以拿去给亲朋好友的上古时代老电脑“升级”一下。\n后续在旗舰店买了RX6600XT红魔，这卡可以说是AMD入门级显卡的旗舰款了。除此之外还买了一个高刷1080P显示器，然后买了3个不带灯光的纯白静音风扇和两条ARGB灯带用来装饰。所以整体算下来整机开销大约在12K左右。\n主板觉得华硕重炮手B550M就已经蛮符合我自己的需求了，在B站上看了一下B550的评测发现华硕的重炮手要比微星和技嘉的迫击炮强一些（也贵了好几百元），所以决定多花些预算上一张性能强一点的主板，为后续的升级留一些空间（不过我觉得就这配置已经很够用了没啥好升级的了\n因为AMD R7 5800X太贵了有点超预算，所以决定买的R5 5600X，除了核心数少了一些（跑编译少几个线程）之外，性能对于现在的日常使用来说已经很足够了。肯定比我笔记本上的R7 4800H强许多。\n因为自己打算在电脑装Linux + Windows双系统，所以实际上我给电脑装了2条NVME固态（SN750 SE 1T + 降速的SN550 1T），然后还配了2T的英睿达MX500，以后可能根据需要还会买几个机械硬盘存数据用。\n因为CPU散热不带灯光，尽管我不喜欢RGB那种太花里胡哨的效果，但是还是得买几个有光亮的机箱风扇，因为预算有限而且不装显卡暂时对散热要求不高，所以我只买了比较便宜的风扇，不然机箱黑咕隆咚的太不好看了，以后有需要的话再修改。\n后来咱又买了两条ARGB的灯带，然后花了一段时间把它安装到机箱里面，咱并不喜欢RGB，不过我还是希望机箱能有些观赏性的灯光。\n在B站找了几个电源测评介绍的视频看了一下，就买了长城的700W金牌电源，价格比较便宜不是一元一瓦，目前来讲我不装显卡就日常待机的话整体功率都不会超100W，主要是电费太贵了。 不过现在来看RX6600XT的功耗最高也就150W，（应该给这显卡贴个一级能效标识），所以电脑就算满载使用最高也就不到500W的功耗，日常使用的话显卡功耗只有20-30W，超级节能！\n从网上挑了很久的机箱发现实在没有比较便宜又顺眼的，一开始想买白色机箱来着，后来发现白色机箱要么就是奇葩风道要么就是超预算，所以最终决定买先马鲁班1黑色机箱，尺寸够大对散热和主板显卡长度几乎没有限制，不用买配件时总计算空间大小了。\n配置是周五定下来就从京东上买的，因为基本上都是自营，周六当天就全收到货了。所以周六+周日两天一顿折腾就把电脑装好。一开始还比较担心会不会安错，哪里出问题需要返工这类的情况，实际上装机十分顺利。除了理线花了一些时间以外其他都基本上是一次装齐直接点亮装系统，其实第一次装好机插电源后按开机键怎么也点不亮，当时吓够呛然后拔掉开机跳线检查是不是接线有问题。后来才发现是自己脑残电源开关开反了主板没通电肯定点不亮。\n防呆不防傻， 那么你能帮帮我吗？（逃\n装机 我装机时为了防止装错顺序返工，于是去B站搜了一个教程：【BV1jE411e7hw】，照着这个顺序安装基本不会出错，而且比较常见的问题视频上都有提到，比如萌新不是十分熟悉的内存插槽优先级以及比较难弄的前面板跳线。\n以下图片除了背部理线的那张图是用手机(iPhone XS)在弱光环境拍摄的，其余都是用相机(佳能EOS 800D + 适马17-50)拍摄，设备不是很好，技术有限，使用RawTherapee进行适量的裁剪调色\n主板\nAMD R5 5600X\n内存\n散热模具\n涂抹硅脂\n因为散热器赠的利民TF7硅脂比较干，所以我直接点9个点然后就扣散热器了。觉得没必要像网上有人那样戴手套把硅质抹匀抹平，也不用特别在意硅脂会不会留气泡，总觉得这些不会对散热有太大影响。\n毕竟用一年左右就得拆下来换新硅脂，到时候只要硅脂别太干粘住直接把CPU连根拔起就行。\n散热器底部\n特地拍了一张照片以确认我把散热器底下的膜撕掉了。\n安装散热器\n固态硬盘\n亮机卡\n装好的效果\n理线后的效果\n背面理线花了好几个小时把不同种类形状的线绑了起来，最顶上的风扇RGB灯光线实在没有空间收纳于是只好捆成一坨放在那。\n最终成果展示 最终成果演示\n装好Windows，安装华硕主板的软件，把风扇的灯调成了橙色长亮的模式。一开始调成浅蓝色觉得色温太低了有点冷，所以改成了暖色调。\n暖色\n给机箱内部拍一张特写，现在正在考虑要不要买一个手办放进去。\n少女梦幻粉\n后来买了新显卡和ARGB灯条后，把4根内存插满，设置好显卡的神光同步，把机箱颜色调成了“少女梦幻粉”。\n（相机的夜景效果不太好，所以看起来有些晃眼而且丑，实际上这颜色还是很好看的）\nArch Linux\n装好Arch Linux后的最终效果。\n最终我决定还是把机箱放在桌子上好一些，这样不但能透过玻璃“欣赏”内部构造，还不用担心底部电源的风扇“吸尘器”吸进去很多灰尘。\n机箱内部风道我也是采用的网上最推荐的风道方式，底部和右边为进风口，顶部和左边为出风口。因为现在没有显卡发热量并不大所以我只安装了左边的一个风扇和顶部的两个风扇。\n以后可能再买个手办和灯放到电源仓的上边，再搞点装饰。\n为什么买了RX6600XT 其实咱一开始是想买RTX3060Ti的，但是因为老黄溢价实在太高（NVIDIA f**k you），狗东双十一耍猴，所以去ytb看了一下评测发现这A卡可以通吃1080P全部的游戏（实际上2K很多游戏也全都能玩），而且价格比3060便宜许多，然后一想3060Ti的确有些性能过剩，而且N卡的Linux驱动真的很拉跨（尽管最近一阵子更新了很多东西但是真的就是不想再折腾N卡驱动了）。\n然后就是，如果真的玩fps游戏的话，有谁会真的开极高画质上2K144呢。咱玩守望除了把材质调最高之外其他都是最低，3A大作的话咱也就玩过尼尔和底特律，而且咱不玩赛博朋克2077，而且咱主要还是Linux用户。所以真的没必要花首发价2倍的钱去买一个所谓的能在2K分辨率下全高画质流畅运行游戏的显卡。更值得吐槽的是，现在网上一搜显卡评测，给人的感觉就是游戏不开极高画质就好像不能玩了一样，还有很多人还拿A卡开光追后的帧数和N卡作比较，说实话我本人对光追真没什么好感，我玩的这些游戏里没有支持光追的，而且就算玩支持光追的游戏，开光追也看不出多大差距来。\n网上有很多评测视频说这显卡显存位宽只有128比特，只支持PCIE4.0x8，核心面积小啊，丐中丐不值三千块钱这个价之类的一大堆缺点，不过这卡实际体验并没有网上传的那么不堪。它实际的游戏效果还是很好的，所以真没必要非拿硬件参数说事，缺点有是有，但影响并不大。\n实际上手体验后，这显卡日常待机时风扇转都不转，温度只有40-50度，功耗在20-30W之间肥肠节能。Linux里面卸载掉NVIDIA一大堆驱动后，安装amdgpu驱动直接就能用，没遇到过任何问题。\n（要不是因为刚需，谁会在这个时间点上买显卡\u0026hellip;\n游戏体验 守望先锋高画质（我不开极高画质），训练靶场或者进比赛帧数400fps直接跑满，打团时帧数大约下降到320-350之间。（正常人是不会在打团时盯着屏幕左上角看帧数变化的）\nMinecraft Java Edition 1.16.4 + Optifine（咱加了这么多定语是因为Minecraft有很多版本，而且还有很多用来改善画质或性能的Mod）：\n不知是MC的优化不好还是遇到了CPU瓶颈还是显卡驱动的问题，玩MC时帧数平时会有250帧，但是一到红石机器多的地方或者全物品分类机这类的地方，帧数就掉到了140帧以内，虽然帧数并不高（实际上也不低了），但是已经很流畅了，只不过对生电玩家不太友好。\n值得一提的是，这显卡在玩MC时功耗也只有30瓦左右，而且大多数时间风扇都不转，真的太环保了（\nArch Linux 整个安装Linux的过程十分顺利，不像笔记本那样经常遇到许多奇奇怪怪的问题。加上走的独显直连没有麻烦的双显卡混合交火，基本上是装好自己需要的软件后开机就直接用了。\n之前联想R7000P那个笔记本还经常无法调节屏幕亮度，TTY下面的警报“滴”声大得吓人，以前还遇到过nvidia+amdgpu+gnome进wayland就黑屏的问题（现在nvidia升470已经修复了）。\n曾经用的那个惠普更是因为英伟达显卡驱动和惠普奇葩的硬件在linux5.0内核之前经常出现黑屏死机这些问题，而且不开启独显的话就没办法连双显示器。\n所以还是台式机最香，觉得硬盘不够用了我就可以买块新硬盘扯根线扩容，主板上有4个内存插槽够我插很多根内存。CPU也都是可拆卸的只要主板支持我还可以继续升级，而且我可以选择没有集成显卡的CPU，显示器直连独显不用被那些驱动问题弄得头疼。\nOthers 其实最初我是想把装机的过程录下来拍成VLOG的，但是租的房子空间有限加上不想露脸，我一说话还会紧张不会组织语言，而且我没带三脚架，所以为了节省体力我只是拍几张照片放到博客上。\n尽管现在这个电脑显卡很差不能打大型游戏，但是他的强悍的CPU性能已经足够我干很多事情了。 一开始想测试一下CPU性能于是下载了Linux内核，用默认生成的config，make -j12编译。然后找个工具(lm_sensors)查看一下CPU温度。当我还没配好配置文件时突然发现内核他编译好了。\n然而除了写代码之外我暂时还没想好什么其他的使用这个电脑的方法。因为有点舍不得电费加上没有公网IP所以我也不打算把它当服务器用。\n可能有人会更关心我在北京实习的相关事情，其实我并不是不想写在博客里面，而是想等过几个月有了一个比较完整的实习体验后再写，因为最近每天都很忙而且心情变化很复杂，毕竟自己一个人离开学校到北京。所以我不想把某一刻的心情写在博客上当作我这一阵子的整体体验，现在还不是做总结的时候（心情好的话，也许我会写在今年年终总结上吧）。\n后续 2022-02-26补充:\n咱给这个电脑换了新的机箱，考虑了一下如果把换新机箱的内容添加到这里的话，会对原有的我组装电脑的内容产生影响，所以我新开了一篇博客，感兴趣的可以去看：电脑换壳——先马趣造。\n以后组装电脑相关的博客，都会在标签 台式机 里面找到。\nSTARRY-S\n","permalink":"https://blog.starry-s.moe/posts/2021/build-desktop/","summary":"\u003cp\u003e很久很久以前就想自己组装电脑了，看到别人能有台高性能的电脑别提有多羡慕了。不过考虑到在校期间实在不适合把自己组装的电脑放到寝室中去，要是把电脑放家里的话只能假期玩短短的几星期，其余的时间闲置下来的话又觉得有些浪费，于是组装电脑的计划一直推延至今。最终在大四校外实习自己租房子之后才有了一个短暂而勉强稳定的环境可以让我组装台式机，所以在安置好自己的住处和一系列其他事情之后，我终于可以实现自己这个埋藏心底多年的愿望之一了。\u003c/p\u003e","title":"我们来组装一台电脑吧"},{"content":"这是我入手的第一款RPG游戏，也是我迄今为止买的最贵的游戏，在大一的那个寒假狠下心来用压岁钱花了四百多在Steam上买的正版，后来在今年年初买PS4 Slim时又买了一张二手光碟以及DLC。\n尽管游戏玩了3遍，但是不敢保证说我把尼尔前前后后的每个细节都弄清楚，不过还是打算把我遇到的一些有意思的地方记录到博客中。\n遊樂園廢墟\n第一次玩尼尔：机械纪元时除了一些必要的支线任务外，其他支线任务几乎都没有做完就主线通关删档了。\n因为PC端没有官方汉化，觉得第三方汉化过于生硬就没有安装汉化包，于是我第一次玩这游戏时几乎全程英文生肉啃下来的，所以尽管游戏结局很令我感动，但是机械纪元究竟讲了怎样一个故事，期间为什么会发生这些事情，以及银莲、A2的过去究竟发生了什么，艾米尔是谁，为什么人们都说他很惨，塑料姐妹花的经历，为什么她们背负着很多罪孽我其实都不知道，所以第一遍玩完这个游戏后我很迫不及待的找了一个时间开始玩第二遍。\n第一次打这游戏时全程简单模式+自动芯片，因为没打支线练等级所以三周目时因为等级太低，半天杀不死一个怪物。\n然后因为没有手柄，只用鼠标操作，所以9s进行骇入后用鼠标很难控制方向，所以9s打怪时我几乎全程用手打，几乎没怎么进行骇入。\n二刷时买了联想拯救者的xbox的有线手柄，就为了打尼尔。因为渣笔记本性能弱，游戏优化很差，GTX1050Ti只能开低画质降低分辨率至1366x768，才勉强30帧“流畅”运行，不过第二次玩尼尔时也是由于时间原因没有做很多支线，E结局到现在也没打完，一方面是因为懒，另一方面是因为后来买了PS4。\n入手PS4后才终于才体验到比较流畅高清的画质，加上官方原配的繁体中文字幕(尽管是对照日语字幕翻译的，开英文语音时觉得字幕和语音有些对不上)，能更好的理解一些剧情。然后准确来说去年疫情 超长假期 的时候还买了繁体中文的尼尔短话和长话小说，所以对一些幕后的剧情有了简单的了解，所以我把绝大多数支线都做完了(除了三周目末尾的一个向4s汇报情报的支线以及速度之星这个废手的支线外，别的应该是都做完了)，还攒了全武器，打通了全结局(26结局+dlc结局)，最后在寝室打了E结局然后心满意足的删档。尽管游戏里还有一些特性我没有尝试触发（比如B站上随处可见的卡墙bug，左脚踩右脚上天，如何流畅帅气的打怪之类的），DLC斗兽场的最难级别没有打过（对我这手残党来说真的太难了），所以没有亲自打死SQUARE ENIX社长（大雾）有些可惜。不过我觉得还是可以先把我在这个游戏里的一些回忆记录下来，不然时间久了就又忘了。\n想了一下我不太会以叙事的方式讲述游戏的剧情，讲出来的话也就是通篇流水帐，所以我只打算把一些自认为不错的游戏截图贴上来，至于文字描述我暂时先不打算写，以后有时间再补上。\n其实我今年4月份就把游戏就打完了，但是我硬是拖了这么久才把游玩记录写到博客上。\n记忆\n八音盒\n游乐园的月之泪\n充满“干劲”的机器人\n游乐园\n机器人版 罗密欧与朱丽叶\n描述人类残暴性的作品\n摸头\nNieR:AutoFishing\nLunar Tear\n4s\nA2\n艾米尔的家\n森林国王\n沉没都市\n艾米尔的决意\n9s 陪寝\n任务\n创造不是那么简单的事了\n记好啦\n最轻松的！\n第6次格式化\n女人真恐怖\nMorning!\nMeow\n4s\nHacking A2\nEmil\u0026#39;s Memory\nShare Happiness!\nEmil\u0026#39;s Home\n《没中》\n孩子们的核心\n晚安，好梦！\nBrother\n利落地杀掉我\n柏拉图\n柏拉图的回忆\n谢谢你愿意听我说话\ndeb[U]nked\n好一个逃离现场\n[E]nd\nNieR:Automata\n","permalink":"https://blog.starry-s.moe/posts/2021/nier_automata/","summary":"\u003cp\u003e这是我入手的第一款RPG游戏，也是我迄今为止买的最贵的游戏，在大一的那个寒假狠下心来用压岁钱花了四百多在Steam上买的正版，后来在今年年初买PS4 Slim时又买了一张二手光碟以及DLC。\u003c/p\u003e\n\u003cp\u003e尽管游戏玩了3遍，但是不敢保证说我把尼尔前前后后的每个细节都弄清楚，不过还是打算把我遇到的一些有意思的地方记录到博客中。\u003c/p\u003e","title":"NieR:Automata 游戏记录"},{"content":"很久以前就打算二刷空境原著了，由于种种原因进展一直比较缓慢。\n最终在 Kindle (泡面盖) 上阅读时标记了一些不错的菌言菌语，整理到博客上。\n俯瞰风景 飞行这个名词，与坠落这个名词是相连结的。但越是迷恋天空的人，越会欠缺这样的认知，结果死了之后也只能持续朝云端飞行，不会往地面坠落下来，等于是朝着天空坠落。\n视野并不是眼球看到的景象，而是大脑处理过的景象。我们的视野受到我们的常识保护着，不认为自身的高度叫高，甚至觉得是种常识，没有高这个概念存在。反过来说，凡是人类，都活在俯瞰的视野中。\n人是活在箱中的生物，也只能在箱中生活。\n在这短暂存在的密室里，现在无论外界发生什么事都与式没有关联，也无法产生关联。这份实际感受，微微沁入她本应空虚的心。\n——如果自身的视野就是世界的一切，此刻世界的确正在沉睡。\n如果城市是深海，夜空就是纯粹的黑暗。在那片黑暗上，星辰就像散落的宝石那般闪闪发光。月亮是洞穴，一个凿穿夜空这张黑色图画纸的巨大洞穴。\n月亮其实不是反射太阳的镜子，只是在窥视这一侧的景色——在两仪家，式曾听人这么说过。\n一头宛如以一根根丝线梳就的黑发顺滑无比，只要风势一大，黑发迎风飞舞的模样就散发出无比幽玄之美。\n刀刃有六寸长，与其说是刀更像是一柄只由白刃构成的凶器。\n因为天空没有尽头。我认为如果能无拘无束的漫游、能自由飞往任何地方，就可以找到我不讨厌的世界。\n所谓的 ‘逃’ 有两种，漫无目的的逃以及带有目的的逃。一般将前者称为 ‘漂浮’，后者称为 ‘飞行’。\n我们并不是根据背负的罪来选择道路，而是先选择道路再背负起自己的罪孽。\n虽然根本不值得一提，我终究认为自己最后还是应该死于从俯瞰坠落。\n无论当事人下了什么决定，自杀还是会被视为自杀来处理。\n杀人考察（前） 人要无知一点比较好，黑桐。人在小时候只看得到自己，根本不会察觉别人的恶意。就算是污秽也好，当被爱的感觉转化成经验，人才能够以善意去对待他人——因为人只能展现本身已具有的情感。\n你要当心点，黑桐同学。不详的预感，会招来不详的现实\n痛觉残留 无法适应社会的人非常多，他们的存在本身却从一开始就无法适应这个社会。他们不应该存在，不，是无法存在。\n这让她很高兴。因为活下去，就等于痛苦下去。\n被排除在境界之外的人，也会被彻底剥夺其存在意义。所以，那只不过是肉块罢了。\n对于想不通的事，不要强迫自己接受比较好。\n因为缺乏感觉的人一样拥有身体，也能够移动自如，我们就认为他们除了没有感觉之外没什么不同。但这是错误的。没有感觉，就代表什么都接收不到喔，黑桐。\n黑桐没能赶上是吗？接下来，就看暴风雨是先抵达，还是先被制造出来。式一个人去，有可能反被打败啊，两仪。\n痛觉可是种好东西，有错的终究是伤口，不可以搞错先后顺序。我们需要痛觉，无论多么痛苦都一样。\n“没有什么伤是无法痊愈的。不会痊愈的伤口不叫伤口，叫作死亡。”\n伽蓝之洞 如果眼睛看得见，我大概正看着他应付的笑容。\n“你的嗜好还真奇怪。”\n“我好高兴。真让人惊讶，没想到橙子小姐也有跟普通人一样的温情和道义精神！”\n“没错，你无法过着正常生活。要烦恼也该有个限度，两仪式，你该认清现实了。你原本就是属于我们这边的人吧？ 所以——别再梦想什么普通（幸福）的生活了。”\n这女的——真是专挑我逃避的问题刺人痛楚。\n正因为失去的事物永不复返，我决定不再后悔。\n矛盾螺旋 所谓的变成大人，就是明智地将幻想取代。\n自以为早熟的愚昧，让我骄傲地接受了这个事实。\n追求社会上理所当然的生活就得遭受打击。只要接受我的人生注定如此，就不会觉得自己不幸。这和小时候一样。我以聪明代替幻想，决定一个人活下去。\n我明明热爱奔跑，奔跑明明曾是我的救赎，到头来我却发现那不过是发生了一些不幸后便可以抛弃的东西，不仅愕然。\n只要一堕落，人是否就会变得这么婆婆妈妈的？我不禁傻眼。\n这家伙以前曾说心是看不见的。因此，她绝不会对别人吐露肉眼看不见的烦恼。\n所以——为了不再做梦，我只不过是在被杀前抢先宰了对方。\n忍耐明明是你的优点，结果你却选择了痛苦的那条路。第一次见面的时候，胭条巴正要抹杀胭条巴。失去未来，变成空壳的你，也跟现在一样想死是吗？\n“重点明明在于学到什么，这个国家却本末倒置。只要有真材实料根本不需要什么证据，大家却为了得到资格去学习，而不是透过学习的成果取得资格。一个只剩下用来证明‘我学到这么多！’的资格，不就像契约书一样。”\n或许，她就是将如暗处鲜花般优美的日本幽灵，与外国童话中的妖精融合而成的结晶。\n“和他们结识，算是我在伦敦时唯一的疏忽吧。”\n灵长已经变得太复杂，是过度追求万能，替生命附加种种能力导致的结果。\n朦胧不定的东西会召唤朦胧不定的言语。事情明明这么简单，方才的平稳气息却已散去，让人难以呼吸。\n那是因为无论拥有怎样优秀的肉体、素质，对于一个人来说只能把一件事情做到极致。去到高处的话可以，然而除此以外的山便无法去攀登了。\n“你这是什么表情。让那系统崩坏掉的人就是你吧。所谓的精神异常者呢，由于自以为自己的异常是梦境所以才没有破绽。式过去也是这样的。但是却不由得注意到了名为黑桐干也的人。于是对两仪式的存在方式察觉到了异常。”\n“哦，离题了。说着与两仪有关的话就没有注意到，似乎是被什么逼迫着一般。不知不觉就说多了。说不定黑桐你明天就死掉了呢。”\n“\u0026hellip;\u0026hellip;不敢当。我会小心车子的。”\n也就是指男性之中的女性部分和女性之中的男性部分。从男性的语气来推断出是阳性，这结论未免下得太早了。无论是谁都会拥有偏向异性的思考模式。男扮女装的怪癖是最为典型的。现在的式毫无疑问是阴性的式。男性的语气，是她为了死掉的织而在无意识下进行的代偿行为。至少，是希望你还能够记得织的事情也说不定。呼呼呼，这不是很可爱吗？\n“\u0026hellip;”\n由于没有任何一点小的异常，所以也就注意不到大的异常。\n“要打开了。这可是阔别半年的自己的家呦，胭条。”\n两仪很开心似的说着。\n若不在人们身上使用相同的仪式死亡，给你的献祭便不完全。如果死亡之后再次复活的螺旋不完全。没有达到相互交缠且相克的条件，便无法将其联系起来。于是我便准备了他们的尸体作为阴，他们平常的生活作为阳。\n死者与生者无法兼容。在满是矛盾的这个世界中，个体是没有共通这层意义的。\n第一次脱离了死的困境，但那只不过是为了迎接第二次、第三次的死所注定的方法。这种有限的死的方式。\n“\u0026hellip;\u0026hellip;推了煞车坏掉的人一把，这种做法是不对的。”\n为了消除现象而引起的现象，最终会变成将自己向绝境逼迫的行为。但是果然，即使留下最初的现象不管，也会演变成被逼迫至绝境的情形。无论怎样努力，现象这个词的含义是不会消失的。\n由于事物总是连带有许多阻碍，所以并不存在完美的事物。\n橙子小姐的言辞一针见血。\n不过到了近代这种称呼就不再使用了。文明发达了，人们变得很容易就能够将自身灭绝。\n“学问和年龄无关，柯尼勒斯，虽然你外表看起来很年轻，但你总是只注意外表，所以内在才会追不上啊。”\n人类的个体若是完成，生存的意义就会消失。但各种人类却只为了生存下去的欲望而无意识地拒绝它，所有的人类在以人类身份思考时，变成比动物还要不如。明明为了完成而生存，却为了生存而拒绝完成。\n让一个人了解事物，与其教他，不如让他自己体验来得快。\n生命的证据不是如何去追求快乐，因为生命的意义，就是要去体会痛苦。\n——风停了，信号也已响起。\n来吧 ——该开始认真地奔跑了——\n我虽然讨厌别人的同情，但我知道拒绝别人同情的代价，最后报应会发生在自己身上。\n然后，男人的手伸了过来。\n“一个人站不起来的话，我就助你一臂之力吧。”\n男人“嗯”的一声，毫不做作地笑了。\n“我也认为你应该会这么说的。”\n那是一股不可思议、连我也想回报的笑容。\n“你就拿着吧，因为这以后得由你来守护才行。”\n我努力露出灿烂的笑容，但不知道是不是顺利笑了出来。\n“\u0026hellip;\u0026hellip;我也一样，希望有人来帮我，一直希望有人来帮我，但是，我却不知道该把自己从哪里解放出来\u0026hellip;\u0026hellip;而结果也不该知道的，因为根本没有可以帮助我的方法。不管意义如何替换，只有一开始的现象无法消除。”\n他回头看了一眼，那个被蒸汽和水声包围的地下室非常安静。那是连自己死了都不知道，到今天也还继续梦见日常之轮的脑髓灵魂安置所。\n但那也是不可能的，扭曲的轮回不会在同一个地方转动，若死者不能亲自结束身为死者的存在，日常生活永远不会到来。\n\u0026hellip;\u0026hellip;我失败了。不该和这些怪物扯上关系啊！\n\u0026hellip;\u0026hellip;那就是，红大衣魔术师最后的思考。\n从走廊看出去的夜景很安静、很寂寞，公寓周围只存有旁边那栋形状相同的公寓，公寓之间铺着柏油道路，还有绿色的庭院。那光景，与其说是夜景，还不如说是被绿意包围的墓碑。\n“为什么回来。”\n魔术师用沉重的声音问着。\n巴无力回答，只是一直看着荒耶。他没有回答的余力，若不是全力集中精神，他连正面看着魔术师也作不到。\n你的意志只不过是由幻想产生，由幻想所活化的东西而已。在这个世界死亡的胭条巴，已经只能在这里生活了。\n事情就是因为有尽头，所以才能观测到无限这件事。\n忘却录音 在确认自己的记忆时，不可以依靠他人的记忆。毕竟只有名为回忆的自我天平，才能决定过去\u0026hellip;\u0026hellip;\n所谓的忘记，其实是记忆劣化。回忆是一种不会消失、只会逐渐褪色的废弃物。你不觉得很可惜吗？人们竟然让属于永恒的事物生锈。亲手让身为永恒的事物化为烟尘。\n污秽由污秽自己解决是最好的作法，因为不管是什么人，想要清除污秽，就一定会受到污秽沾染，这是一个不详的循环，我们称之为 ‘诅咒’。\n所谓的天才，到最后只是把自己当成对手。\n妖精很难控制，操纵者常常在不知不觉间，从实现他们自己的愿望变成实现妖精的愿望。鲜花你听清楚了，要注意——使用自己以外的东西所制造出来的使魔，别走到操纵者反被操纵的下场\n我的能力只能从别人已经走过的道路来获得信息，但你却可以看到接下来的路通往哪里呢\u0026hellip;\u0026hellip;\n人之所以选择忘却记忆，绝不是因为那些记忆没有必要，而是因为记住那些事很危险。\n我们刻意忘却过去犯下的种种过错。忘却那些如果记得就会让自己崩溃的记忆。我们靠着这么做——才能守护自己现在是健康而无辜的幻象。\n“物质是用来消费及磨耗的事物，这个名为地球的世界逐渐走向崩坏也是自然的道理，因为在最后走向死亡是最正确的存在方式，所以谁也不会去解决这个问题。对我们来说，真正的世界只存在于各自的脑髓中而已。”\n杀人考察（后） 本能在表层意识具现化成人格时，将会驱逐所有理性，会凌驾我这个名为白纯里绪的人格。\n向对方抱有的情感，超出自己的容许量的时候吧，自己能承受的感情量是一定的，有些人容量很大，也有人容量很小，不论是爱情或者是憎恨，当那种感情超过自己所能容纳的量，那么超出的部分会转变为痛苦，如此一来，便不能忍受对方的存在。\n为了到最后让自己死去，所以我们只有杀一次人的权利。\n人一辈子只能承受一人份的人生价值，为了原谅无法走到尽头的人生，所以大家才会用尊重的态度看待死亡，因为生命等价，即使是自己的生命，也不是自己所拥有的东西。\n光是孕育意识的大脑，无法产生人格。虽然只有脑部也可以活下去，但我们必须先拥有肉体才能产生自我意识。有了肉体之后，和肉体一起培养，就有了现在的人格。喜爱自己肉体的人，应该属于社交型人格，而厌恶自己肉体的人，则属于内向型人格。虽然光有意识也可以培养出人格，但那样的人格是无法认识自己的，一般来说，心灵就会长成特别的东西。那样的话，已经不能称之为人格，和计算机没有什么不同。如果有谁只是一个大脑，那个人就必须创造出一个 ‘只有脑的自己’ 的人格。必须舍弃肉体这个大我，而保存意识这个小我。\n“不是有了知性才有肉体。”\n“而是，有了肉体之后，知性才得以诞生。”\n说到底，人类只不过是在自己这个空壳中做着梦而已。明明是那么地显而易见的。\n大部分的人并不是出于自己的愿望要过那样的生活。想要成为特别的存在却无法实现，这种形式才是真正的平凡人生。\n未来福音 她擅长的并非预测未来，而是教人如何避免遭遇到不幸。\n那是一种希望，希望对方相信她说的话。也是一种绝望，绝望于对方不可能相信。\n所谓的现实，即为数值尚未确定的公式。公式的数值会不断变动，不用说是求出答案，人们连要求出什么都不知道。然而——一旦这个数值确定下来，答案便再也不会改变。\n这一切都是醒着的，但没有什么活着的样子。没有任何例外。\n“就是因为知道得太清楚，才会看不见吗——橙子说得对极了。炸弹魔，你有没有听到？既然你的眼睛什么都没看见，不如废了算了。”\n“未来并没有不同。‘未来’这种东西，一开始便不存在。不存在的东西，当然没有办法控制。”\n她依然是老样子，即使自己遇到不幸，也没有显露出来，仍旧表现得潇洒又懒惰，完全就是时下高中女生会有的样子。\n“没错。那顶多算是憧憬。你就像个看到偶像，拼命叫个不停的幸福小粉丝。所谓的恋爱啊，应该要更轰轰烈烈、更不堪回首、更捉摸不定，如同不是抵达终点，便是发生意外的云霄飞车。总之啊，谈恋爱不可能留下什么美好回忆\u0026hellip;\u0026hellip;”\n“我漂亮地踩到地雷。”\n既然我可以用未来视取巧，相对地当然要承担一些代价。\n不论谁看见她，都会期待她未来的发展，另一方面，又暗暗希望她永远维持现在的样子\n在这个时代，幸福的未来相当罕见。\n既然看得见未来，当然也会了解过去。\n这十年——不，说得更正确，是十二年来，我始终像故事中模仿人类的机器人，融入这个城市的生活罢了。\n我遇见难得的朋友，之后又失去他。尽管试着承续他的衣钵，却每天被唯一的读者批评。\n尽管我也为此付出代价，往后的人生满是失败。但我至少还留有什么。\n“你很快会从这个世界上消失。你的前途一片漆黑，未来完全没有任何希望。你不会留下任何东西，也没有获救的可能\u0026hellip;\u0026hellip;但是，太不可思议了，尽管如此，你的梦想将继续活下去。”\n","permalink":"https://blog.starry-s.moe/posts/2021/karanokyokai/","summary":"\u003cp\u003e很久以前就打算二刷空境原著了，由于种种原因进展一直比较缓慢。\u003c/p\u003e\n\u003cp\u003e最终在 Kindle (\u003cdel\u003e泡面盖\u003c/del\u003e) 上阅读时标记了一些不错的菌言菌语，整理到博客上。\u003c/p\u003e","title":"《空之境界》摘抄"},{"content":"其实咱很久很久以前就开始看LearnOpenGL CN这个网站了\u0026hellip;\u0026hellip;\n前言 首先需要明白什么是核心模式，什么是立即渲染模式，立即渲染模式的代码中都包含glBegin()和glEnd()，绘图的部分都是在这两个函数之间，比如画一个点就是glVertex2f(x, y)，这种方式画图确实很简单，用户只要提供坐标和颜色就好了，不用知道GPU干了什么，而缺点是性能低，有很多限制，所以新版本的OpenGL为了给开发者提供更多的可操作空间而逐渐废弃了立即渲染改用核心模式。\n核心模式提供了很多强大的功能，可以管线编程，代码量增加了很多，所以对初学者不太友好。\nLearnOpenGL CN上面的代码基于C++，而OpenGL是用C编写的，教程上的代码除了矩阵运算部分可以使用C++的运算符重载而使代码编写起来变得更简单一些外，其他部分基本没啥区别，而且教程为了便于教学使用的也是面向过程式编程，没有将各个功能封装到一个类里面，所以咱这篇教程用C编写。\n要记住C就是C，C++就是C++，C不是C++的子集，只能说C++兼容部分C的代码，不要把C和C++混用，不要因为C++支持面向对象使得一些功能看起来简单很易于使用就轻易迈入C++的坑。\n准备工作 有关OpenGL的介绍以及安装GLFW、GLAD以及编译所需的CMake的部分可以直接看教程，咱尽可能把教程上没有提到的或者是刚开始学OpenGL很难理解的部分记录下来。\n大体上就是安装glfw，Arch Linux使用包管理器sudo pacman -S glfw-x11 (如果你使用的是wayland，那么安装glfw-wayland)，然后把下载的glad/glad.h复制到/usr/include下，把glad.c复制到工程文件夹的代码目录下。\n为使用CMake生成Makefile，编写CMakeLists.txt:\ncmake_minimum_required(VERSION 3.0) project( \u0026#34;Learn OpenGL\u0026#34; LANGUAGES C VERSION 0.1.0 ) set(C_FLAGS \u0026#34;-Wall -lm -ldl -std=c11\u0026#34;) set(CMAKE_C_FLAGS ${C_FLAGS}) set(OpenGL_GL_PREFERENCE LEGACY) find_package(glfw3 REQUIRED) find_package(OpenGL REQUIRED) include_directories(${OPENGL_INCLUDE_DIR} src) aux_source_directory(\u0026#34;src\u0026#34; GLSRC) add_executable(main ${GLSRC}) target_link_libraries(main ${OPENGL_gl_LIBRARY} glfw) 完成上述步骤后，确保工程文件夹的结构如下：\n├── build/ ├── CMakeLists.txt └── src/ ├── glad.c └── main.c 创建窗口 编辑main.c，加入所需的头文件\n// glad.h要加在glfw3.h之前 #include \u0026lt;glad/glad.h\u0026gt; #include \u0026lt;GLFW/glfw3.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; 在main函数中初始化OpenGL并创建窗口\nint main(int argc, char **argv) { glfwInit(); /* 使用OpenGL版本为3.3 */ glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); /* 使用核心模式 */ glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); #ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); #endif /* 创建窗口 */ GLFWwindow *window = glfwCreateWindow(800, 600, \u0026#34;Hello World\u0026#34;, NULL, NULL); if (window == NULL) { fprintf(stderr, \u0026#34;Failed to create window.\\n\u0026#34;); glfwTerminate(); return -1; } glfwMakeContextCurrent(window); /* 初始化glad */ if (!gladLoadGLLoader((GLADloadproc) glfwGetProcAddress)) { fprintf(stderr, \u0026#34;Failed to initialize GLAD\\n\u0026#34;); glfwTerminate(); return -1; } /* prepare render */ /* main loop */ glfwTerminate(); return 0; } 创建窗口的代码比较容易理解，到这里可以尝试编译一下代码检查有没有遇到什么问题，如果编译失败了可以尝试检查GLFW是否安装正确，代码哪里出现了什么问题。\n编译代码并运行生成的程序：\ncd build cmake .. \u0026amp;\u0026amp; make -j8 ./main 如果一切正常的话，可以看到窗口一闪而过就消失了，因为到目前为止我们只创建了一个窗口，创建完成后就结束了程序，所以窗口会瞬间消失。\n准备绘图 在绘制形状之前，我们需要一些准备工作比如设定视口、回调函数，创建顶点缓冲区等操作，然后在大循环中进行渲染绘制。\n视口 首先要告诉OpenGL咱的窗口尺寸是多少，以便OpenGL根据窗口大小显示数据和坐标。\n在/* prepare render */处添加代码：\nglViewport(0, 0, 800, 600); 首先需要知道你传给OpenGL的坐标都是-1.0到1.0之间的数，OpenGL再将其转换成屏幕上的像素点坐标，这个过程由GPU运算所得，所以你得告诉OpenGL你的屏幕尺寸，glViewport的前两个参数为0, 0指的是窗口左下角的位置，这个值咱目前不需要修改。\n回调函数 我们需要一个窗口被更改的回调函数，这样当窗口尺寸发生变化时，程序可以调用这个函数调整视口。\n我们还需要一个按键回调函数，当用户按下键盘上的某个按键后会调用这个回调函数处理按键操作。\n编写函数framebuffer_size_callback用来处理窗口尺寸更改:\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height) { glViewport(0, 0, width, height); } 这样当你拖拽窗口进行缩放时，窗口里的图像也会跟着窗口尺寸改变而进行缩放。\n编写key_callback函数处理用户按键操作：\nvoid key_callback(GLFWwindow *window, int key, int s, int action, int m) { if (key == GLFW_KEY_ESCAPE \u0026amp;\u0026amp; action == GLFW_PRESS) { glfwSetWindowShouldClose(window, GL_TRUE); } if (key == GLFW_KEY_Q \u0026amp;\u0026amp; action == GLFW_PRESS) { glfwSetWindowShouldClose(window, GL_TRUE); } } 当用户按下ESC或Q键时，可以结束OpenGL窗口的运行。\n然后我们需要注册这两个回调函数，在/* prepare render */处添加下面的代码:\nglfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetKeyCallback(window, key_callback); 大循环 在大循环中，每循环一次代表绘制一帧画面。这里利用了双缓冲将绘制的图形放到缓存中，然后将缓存中的图形刷新到显示器上。(因为OpenGL绘图操作是逐行绘制的，如果不先将图形存到缓存中而直接显示在显示器上的话，在画面快速变动时你很可能会遇到画面撕裂，垂直不同步)\n大循环部分的代码长这个样子:\nwhile(!glfwWindowShouldClose(window)) { /* 清空背景色为深灰色 */ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); /* draw something */ /* swap buffer */ glfwSwapBuffers(window); glfwPollEvents(); } 每次循环的开始需要使用glClear清空屏幕，这样就不会看到上一次渲染的结果。\n这里我们使用glClearColor设定清空屏幕的颜色为接近纯黑色的灰色。\n大循环每循环一次，OpenGL就渲染了一帧画面并显示在显示器上，所以你可以计算一秒钟循环的次数而估算游戏的帧率。\n因为我们使用了双缓冲，所以这时游戏的帧数被限制为等于显示的刷新帧数， 比如显示器刷新率为144帧，游戏的帧率就被锁为144，如果想解除这个限制需要改为单缓冲。\n到此为止，我们已经创建了一个游戏引擎，但是这个引擎还什么都没有做。\n尝试编译代码，可以看到一个黑色（深灰）的窗口，按ESC或Q即可结束运行。\n创建窗口\n如果你遇到什么问题，可以对照一下代码是否有问题。\n三角形 画三角形的过程很简单，首先要确定三角形的三个顶点坐标，然后告诉GPU这三个点坐标就可以了 :)\n如果你看不懂顶点着色器、几何着色器、片段着色器、光栅化这些难懂的知识点，那么你不必急于弄懂这个过程，等把图形绘制出来后再回来看这部分的内容。\n标准化设备坐标 因为OpenGL的坐标为都是-1.0f到1.0f之间的数（我们先不考虑视口变换这些复杂的情形）\nx, y, z的坐标为-1.0f到1.0f的坐标称作标准化设备坐标，坐标原点在窗口的正中央且在窗口的表面上，往右为x正方向，往上为y正方向，往屏幕里面为z正方向（这里是左手系）。\n有关标准化设备坐标的介绍请看这里。\n所以我们先声明三角形的顶点和颜色值到一个一维数组里面（用一维数组是因为顶点坐标值在内存的分布都是连续的，这样方便给GPU传坐标）。\nfloat vertices[] = { -0.5f, -0.5f, 0.0f, // 左下角 1.0f, 0.0f, 0.0f, // red 0.5f, -0.5f, 0.0f, // 右下角 0.0f, 1.0f, 0.0f, // green 0.0f, 0.5f, 0.0f, // y轴正上方 0.0f, 0.0f, 1.0f // blue }; 顶点缓冲 首先我们需要创建一个顶点缓冲对象，用来存我们的顶点信息，这个对象叫“Vertex Buffer Object”（VBO），之后创建一个顶点数组对象“Vertex Array Object”（VAO），用来存我们创建的VBO。\n为便于理解，你可以把VBO当作为开辟了一块GPU上的显存(Buffer)，用来存顶点和颜色信息，然后VAO是一个包含多个VBO的数组(Array)。\n绘图时可以把VBO中存的大量顶点信息发送给GPU，因为用CPU给显卡发顶点坐标的速度慢而且没办法一次发送大量的顶点坐标，所以我们把顶点坐标存到显存中，绘图时直接访问显存即可。\n生成一个VBO和一个VAO的代码为：\n// VAO和VBO的ID都是非负整型 GLuint VBO, VAO; // 生成一个VAO和一个VBO glGenVertexArrays(1, \u0026amp;VAO); glGenBuffers(1, \u0026amp;VBO); 我们刚刚创建好了一个缓存对象，我们现在需要告诉这个缓存的数据空间大小以及数据（顶点坐标）。\n首先我们绑定刚创建的VAO，然后绑定VBO\nglBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); 之后给VBO传递数组信息\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 第一个参数是目标缓冲的类型，我们刚刚把VBO绑定到GL_ARRAY_BUFFER上了\n第二个参数是顶点信息所占的空间大小，单位是字节。三角形一共3个顶点，每个顶点有3个坐标值和3个颜色值，\n所以大小是6 * 3 * sizeof(float)，不过我们可以直接用sizeof(vertices)知道整个数组的大小。\n第三个参数是数组的地址\n第四个参数告诉GL我们的顶点数据几乎不会改变，所以是GL_STATIC_DRAW。\n如果数据会被改变很多次，则为GL_DYNAMIC_DRAW\n如果数据每次绘制都会更改，则改为GL_STREAM_DRAW\n然后我们告诉CPU我们给VBO传递的数组都是什么：\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*) 0); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*) (3 * sizeof(float))); glEnableVertexAttribArray(0); glEnableVertexAttribArray(1); 第一个参数为位置，告诉这个数据传递到顶点着色器的哪个位置上\n第二个参数为大小，我们定义的那个数组一个顶点有3个坐标，所以是3\n第三个参数为数据类型，这里是float。\n第四个参数为false，暂时不用管他\n第五个参数为步长，一个顶点有三个坐标和三个颜色值，所以每传一个顶点，就走6 * sizeof(float)的长度。\n第六个参数为偏移量，因为我们定义的数组中前三个数字代表顶点坐标，后三个数字代表颜色，所以传递顶点坐标时，偏移量为0，传递颜色时偏移量为3 * sizeof(float)。\nVBO中内存数据\n之后使用glEnableVertexAttribArray告诉OpenGL启用顶点着色器上这个位置的数据。\n最后使用完VAO后要记得将其解绑：\nglBindVertexArray(0); 着色器 我们需要写两个着色器程序，分别为顶点着色器和片段着色器。\n开头说的核心模式可编程管线就是指我们可以写着色器程序，手动指定管线都进行什么操作。\n顶点着色器 因为OpenGL使用的是标准化设备坐标而不是屏幕上的像素点为坐标，所以GPU需要把标准化设备坐标转换为屏幕上的像素点，这个过程由顶点着色器实现。\n而顶点着色器不知道咱们三角形的每个顶点的坐标是多少，所以咱们得往着色器中传我们刚才创建的VBO里面存储的坐标。\n着色器程序使用GLSL编写，其代码和C很像\n在代码文件夹中新建一个vertex.glsl，编写以下代码：\n#version 330 core layout (location = 0) in vec3 aPos; // 传入坐标 layout (location = 1) in vec3 aColor; // 传入颜色 out vec3 color; // 向片段着色器发送颜色 void main() { gl_Position = vec4(aPos, 1.0); color = aColor; } 第一行代表我们使用OpenGL 3.3 核心模式\n第二行声明了一个类型为vec3（三维坐标）的变量，该变量的位置为0，需要人为的通过这个位置给他传值，这个变量代表顶点的坐标\n第三行声明的aColor用来代表颜色，顶点着色器不需要处理颜色，所以我们接收到颜色值后不需要处理，直接传出去即可。\nmain函数中gl_Position代表这个顶点的位置坐标，我们把CPU传给顶点着色器的vec3转换为vec4。\n片段着色器 顶点着色器处理完顶点后，由片段着色器计算每个像素点的颜色，所以如果我们想给三角形上色的话，也是在这个环节进行。\n在代码文件夹中新建一个fragment.glsl\n#version 330 core in vec3 color; // 接收顶点着色器发送的颜色 out vec4 FragColor; void main() { FragColor = vec4(color, 1.0f); } 第一行同顶点着色器，代表OpenGL版本为3.3 核心模式\n第二行表示接收顶点着色器发送的颜色数据到变量color\n第三行声明了一个类型为vec4(4维坐标)的变量，表示向外传递变量FragColor（该像素点的颜色值）\nmain函数中设定变量FragColor的值等于color，用来指颜色。\n最后一个值恒为1.0f，我们暂时不需要修改它。\n编译着色器 因为我们只是写了着色器程序的代码，需要让GPU将其编译。\n编译着色器的部分对应的LearnOpenGL CN教程在这里，本篇不打算重复讲编译着色器部分的代码。\n我们可以把编译着色器的代码封装到几个函数里面，这样可以减少main函数中重复代码的数量。\n有关这部分的代码我推荐使用这篇文章中讲述的方式从文件中读取glsl代码并将其编译。\n最后在main函数的准备阶段处的最下面，插入以下代码，编译你的着色器程序：\nGLuint shaderProgram = load_program(\u0026#34;vertex.glsl\u0026#34;, \u0026#34;fragment.glsl\u0026#34;); 我们期待的三角形 经过了前面的一番准备，我们创建了缓冲对象存顶点的坐标和颜色信息，之后编写了着色器程序处理顶点坐标和颜色。\n现在我们终于可以在大循环中画三角形了。\n在大循环的/* draw something */下面添加如下代码：\nglUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES, 0, 3); glBindVertexArray(0); 这串代码表示我们首先使用刚编译好的着色器程序，之后绑定VAO，绘制一个三角形，最后解绑。\n至此我们的工程文件夹结构修改如下：\n├── build/ ├── CMakeLists.txt └── src/ ├── fragment.glsl ├── glad.c ├── main.c ├── shader.c ├── shader.h └── vertex.glsl 因为我们编写了vertex.glsl和fragment.glsl，需要修改CMakeLists.txt，使得编译时将代码文件夹下的着色器文件复制到build文件夹下。\n在CMakeLists.txt的find_package下面添加如下代码：\nconfigure_file(src/vertex.glsl vertex.glsl COPYONLY) configure_file(src/fragment.glsl fragment.glsl COPYONLY) 编译后运行程序，可以看到一个五颜六色的三角形，它的左下角为红色，右下角为绿色，顶点为蓝色。\n三角形\n如果你遇到了问题，或者哪里不太明白，可以看咱写好的代码：\nmain.c\nshader.h\nshader.c\nvertex.glsl\nfragment.glsl\nCMakeLists.txt\n","permalink":"https://blog.starry-s.moe/posts/2021/learn_opengl/","summary":"\u003cp\u003e其实咱很久很久以前就开始看\u003ca href=\"https://learnopengl-cn.github.io/\"\u003eLearnOpenGL CN\u003c/a\u003e这个网站了\u0026hellip;\u0026hellip;\u003c/p\u003e","title":"Learn OpenGL"},{"content":"咱去年忘了更新这个系列\u0026hellip;\niso100, 50mm, 1/1000s, f2.8\n前一阵子买了二手的适马17-50 f2.8镜头，在网上看这镜头很适合新手学摄影，而且这个焦段+大光圈适用的范围也很广。遂把在家吃灰了一年的相机带回学校，打算找时间拍点风景照片。\n实际上买完新镜头后我就拿它拍了几张花的照片后也没怎么出过门，本来打算5月初份去长白岛拍樱花的然而经过了五一小长假的调休，上周末的体侧，这周辽宁省又开始闹疫情，所以只好先拍点校内的风景啦。\n如果你想看长白岛的樱花，不妨看一下Spring - 3这篇文章。\n仅使用Raw Therapee和Adobe Lightroom对照片进行了裁剪并调整颜色，并由GIMP压缩\niso100, 33mm, 1/1000s, f2.8\niso100, 50mm, 1/1000s, f2.8\niso100, 35mm, 1/1250s, f2.8\n拍摄自：2021-05-18\n在大风天拍蒲公英确实是个不明智的选择。\niso100, 50mm, 1/100s, f2.8\niso100, 50mm, 1/250s, f2.8\niso100, 50mm, 1/320s, f2.8\niso100, 50mm, 1/320s, f2.8\nSpring - 4","permalink":"https://blog.starry-s.moe/posts/2021/spring-4/","summary":"\u003cp\u003e咱去年忘了更新这个系列\u0026hellip;\u003c/p\u003e","title":"Spring - 4"},{"content":"旧电脑坏掉了，因为坏的有些复杂而且不忍心拿到学校的修理店去修于是打算等到暑假有时间自己买零部件修。（就不吐槽惠普的产品设计问题了\u0026hellip;\n于是在网上逛了一会下决心再也不碰惠普了之后买了联想R7000P 2020，满血RTX 2060(这里指的是最大功耗为115W的笔记本显卡) + R7 4800H还是很香的，打守望屁股终于能稳定200+fps了。\n所以隔了这么久我终于更新博客了。\n本篇原标题为「联想R7000P上手体验」，因为内容大多在讲安装Linux时遇到的问题及解决方法，所以把标题更改为「联想R7000P安装Arch Linux的常见问题」。\n安装Arch Linux 到手后就把之前买的西数SN750 1T固态换到了新电脑上，顺便格式化重装了个系统。\n双M2插槽配上1T + 500G NVME，美汁汁。\n于是直接给Linux分了150G root，16G SWAP，500G HOME（有点奢侈）， 然后还分了100G用来存steam游戏，剩下的全扔给Windows。\n装Linux过程中只遇到了终端的警报声有些大这个问题（插耳机时声音依旧从扬声器输出），别的问题都没遇到。\n之前的电脑总是遇到奇葩问题，用旧版本Linux内核关机或者lspci时会卡死，显卡驱动装不好会导致开机死机，声卡驱动一直有问题听歌时音量大一点就爆音，HDMI接口直连的NVIDIA显卡所以显卡驱动没配置好独显不工作时没办法外接显示器(后来才知道type c接口有DP视频输出)。\n新电脑买来装完系统后就遇到了一点小问题网上搜一下就解决了。\n屏幕亮度不能调节 开个浏览器能把眼睛晃瞎\n网上查了一下只有在bios设置为独显直连时解决亮度不能调节的方法，在混合显卡模式下，存在AMD显卡亮度用16位值表示而不是8位值表示的这个BUG (Feature?)所以没办法调节亮度。\n所以cat /sys/class/backlight/amdgpu_bl0/actual_brightness得到的是一个大于255的数。\n确保内核和显卡驱动都是最新的情况下，编辑内核参数amdgpu.backlight=0和acpi_backlight=vendor，可以解决混合模式下AMD显卡不能调节亮度这个问题。\n如果你经常切换混合模式和显卡直连模式的话：\n安装显卡驱动xf86-video-amdgpu和nvidia以及按需要安装nvidia的其他组件。\n复制/usr/share/X11/xorg.conf.d/10-nvidia-drm-outputclass.conf到/etc/X11/xorg.conf.d/\n编辑/etc/X11/xorg.conf.d/10-nvidia-drm-outputclass.conf在EndSection前添加一行参数允许nvidia驱动调节亮度。\nOption \u0026#34;RegistryDwords\u0026#34; \u0026#34;EnableBrightnessControl=1\u0026#34; 之后编辑/etc/modprobe.d/blacklist.conf禁用闭源驱动nouveau和ideapad_laptop，让显卡驱动调节亮度。\n# /etc/modprobe.d/blacklist.conf blacklist nouveau blacklist ideapad_laptop 编辑内核参数添加acpi_backlight=vendor和amdgpu.backlight=0。\n以systemd-boot为例:\n# /boot/loader/entries/arch.conf options acpi_backlight=vendor options amdgpu.backlight=0 最后重启电脑就能调亮度了。\nGDM不自启动 开机时GDM不会自动显示出来而是得手动切TTY2再切回TTY1才能显示。\n查Wiki得知是因为GDM在显卡驱动被加载之前就启动了。\n参照Wiki，设置KMS早启动。\n编辑/etc/mkinitcpio.conf\n# /etc/mkinitcpio.conf MODULES=(nvidia nvidia_modeset nvidia_uvm nvidia_drm amdgpu radeon) 如果你只使用独显直连模式的话可以去掉amdgpu和radeon。\n然后sudo mkinitcpio -p linux重新生成内核镜像，之后重启。\n这么做会使Wayland在开机时被禁用，所以在混合模式使用AMD显卡开机时无法使用Wayland，参见Wiki。\n将/usr/lib/udev/rules.d/61-gdm.rules复制到/etc/udev/rules.d/，并编辑61-gdm.rules将下面这一行注释掉：\nDRIVER==\u0026#34;nvidia\u0026#34;, RUN+=\u0026#34;/usr/lib/gdm-disable-wayland\u0026#34; 之后重启电脑再开机echo $XDG_SESSION_TYPE就可以检查现在使用的是wayland了。\nOptimus Manager 因为独显功耗太高了，使用独显直连模式在浏览网页写文档这类的轻度工作时电池待机只能2小时，用混合模式的话能待机4.5小时，外加上我也不打那些对性能要求很高的游戏， 所以日常使用时就在Bios里设置显卡为混合模式。\n然后在Linux系统里安装optimus-manager，修改配置为：使用电池开机时关掉NVIDIA显卡，只让AMD集显工作；有外接电源时则使用“hybrid”混合模式，如果需要玩游戏的话用nvidia-prime让独显运行游戏。\nOptimus Manager的配置方法和之前我之前配置旧电脑时讲的基本一样，唯一区别就是这电脑是AMD，旧电脑是Intel。\n所以编辑配置文件修改了这些地方：\n# /etc/optimus-manager/optimus-manager.conf # 设置开机自动切换显卡模式 startup_mode=auto # 使用电池时关掉独立显卡降低功耗 startup_auto_battery_mode=integrated # 使用外接电源时为混合模式 startup_auto_extpower_mode=hybrid [amd] # 因为安装的xf86-video-amdgpu, 所以修改驱动改为amdgpu driver=amdgpu 安装好nvidia-prime后在混合显卡模式（hybrid）下，使用prime-run让独显运行游戏。\n如果想让Steam以独显运行游戏，修改启动参数为prime-run %command%。\nWindows 在Windows系统下显卡独连时字体渲染有些蹦，设置了ClearType之后还是没啥改善。\n主要是Visual Studio 2019的字体渲染真的瞎眼，最后装了Text Sharp插件换了Jet Brains字体才看起来正常了一些。\n最后在NVIDIA控制面板全局设置里把平滑处理全关了，字体的锯齿才消失。\n貌似是因为NVIDIA把文本编辑器当游戏渲染了。\nOthers 在Linux系统里会遇到按Fn+Esc键时FnLock的灯没有亮这个问题，不过不影响FnLock的正常使用，所以就忽视了。\n如果要用诱骗线充电的话，用optimus-manager把独显关掉（用nvidia-smi得知独显在不使用的情况下仍有5W的功耗），然后装一个CPU功率调节的软件，例如cpupower-guiAUR，设置为节电模式，实测用小米65W GaN充电器给电脑充电，轻度使用没有卡顿掉电的情况。\n因为之前趁着狗东打折加上买显示器送的100E卡，只花了两百多买了一个紫米20移动电源（板砖），25000毫安且支持100WPD充电。按照上面讲的方法在电池满电的情况下一边轻度使用电脑一边充电，充电宝能用4小时左右，然后笔记本的电池还能续航4至5小时。（实在是因为原装充电器它太沉了）\n目前来看觉得这电脑还是蛮香的，AMD的CPU性能很强而且比intel版的Y7000P便宜一千块钱。尽管现在已经有二线厂商做AMD 5800系的笔记本了但是4800H的性能依旧够用，RTX3060显卡就当它是空气吧就算发售也是残血而且抢不到。\n然后就是电脑没有雷电3接口，只有一个支持USB3.2 Gen1的type c接口且支持DP1.2视频输出，不过USB接口倒是挺多的，电脑用到现在没有遇到啥AMD CPU引起的兼容性问题。\nGNOME 40\n","permalink":"https://blog.starry-s.moe/posts/2021/lenovo-r7000p/","summary":"\u003cp\u003e旧电脑坏掉了，因为坏的有些复杂而且不忍心拿到学校的修理店去修于是打算等到暑假有时间自己买零部件修。（就不吐槽惠普的产品设计问题了\u0026hellip;\u003c/p\u003e\n\u003cp\u003e于是在网上逛了一会下决心再也不碰惠普了之后买了联想R7000P 2020，满血RTX 2060(这里指的是最大功耗为115W的笔记本显卡) + R7 4800H还是很香的，打守望屁股终于能稳定200+fps了。\u003c/p\u003e\n\u003cp\u003e所以隔了这么久我终于更新博客了。\u003c/p\u003e","title":"联想R7000P安装Arch Linux的常见问题"},{"content":"本来路由器闲置了一年了都没咋用了，前两天想把OpenWrt系统刷回原厂系统。\n然鹅刷原厂固件时忘记改环境变量了，因为第三方Boot Loader也被我顺带刷回了原厂的所以现在开机无限重启。\n之前买单片机套件时赠了一条usb转ttl线的，但是被我放学校了。只好再从万能的某宝再买一条线，尝试着救砖了。\n(在某宝发现了一家店啥元件都有，还特别便宜。于是我还顺带买了很多杜邦线、电阻、LED灯、面包板等小玩意\u0026hellip;)\n砖了 拆机 Are You OK?\n北方冬季气候干燥，拆机时记得放静电，找根铁丝把自己连地线上 (找个金属外壳是接地的电器和自己连上也行)。\n拆开路由器外壳，卸下主板，顺手拆掉了散热片（屏蔽罩）。\n串口在图片上主板的左侧，旁边有标记，从上到下依次是TX、GND、RX、1。需要注意的是主板上的TX要接到usb串口的RX，主板上的RX要接到usb串口的TX，GND连GND，VCC不用连。为了防止接错线，小米还十分贴心的标注了每个接口对应的连接线的颜色。\nI\u0026#39;m very OK!\n找出家里吃灰好几年差点被我扔掉的电烙铁，刮刀头刮了半天电烙铁才上锡，把新买的杜邦线母线焊到主板上，和ttl串口线相连。\n(电烙铁太破了根本焊不上锡，焊得很丑，emmm)\n实际上可以买个4PIN单排针焊上去，把串口接到排针上就可以，我直接把电线焊到上面以后用起来会很麻烦。\n刷机 以下部分基于Arch Linux，其他系统的操作方式可能不一样（例如Windows可能需要超级终端访问串口，再想办法开一个tftp服务器） 刷机的原理: 通过ttl串口线连接路由器的主板，让路由器访问电脑上的tftp服务器，刷第三方Boot Loader。\n首先电脑上装一个tftp服务器。 $ sudo pacman -S tftp-hpa $ sudo systemctl start tftpd.service tftp的默认目录为/srv/tftp。\n这里使用HackPascal制作的Breed（第三方Boot Loader），下载链接，把下载好的Breed重命名为breed.bin，复制到tftp的默认目录。\n$ cd /srv/tftp $ sudo cp ~/Downloads/breed-mt7620-xiaomi-r3g.bin breed.bin 路由器插网线连电脑，设置静态ip地址192.168.1.3/24，将串口和电脑连接，先不给路由器通电，通常情况下usb串口的设备名称为/dev/ttyUSB0，如果不确定的话可以dmesg查一下。\n使用screen连接串口，波特率为115200。\n$ sudo pacman -S screen $ sudo screen /dev/ttyUSB0 115200 路由器通电，终端上会显示路由器启动的信息，等几秒后在选择启动项的时候按9，通过TFTP加载Boot Loader。\n如果串口在连接到电脑的情况下主板通电时没有响应，那就断开usb串口先给主板通电后再连接串口。 (我语文不好别骂我) 如果路由器没有变砖可以正常启动（蓝灯长亮），在正常开机过程中不能选择启动项。此时可以尝试在路由器开机后长按reset按钮7s以上直到主板重启，便可以选择启动项。\nPlease choose the operation: 1: Load system code to SDRAM via TFTP. 2: Load system code then write to Flash via TFTP. 3: Boot system code via Flash (default). 4: Entr boot command line interface. 7: Load Boot Loader code then write to Flash via Serial. 9: Load Boot Loader code then write to Flash via TFTP. You choosed 9 9: System Load Boot Loader then write to Flash via TFTP. Warning!! Erase Boot Loader in Flash then burn new one. Are you sure?(Y/N)y 之后设置路由器主机地址（192.168.1.1）和TFTP服务器地址(192.168.1.3)以及文件名称(breed.bin)。\nPlease Input new ones /or Ctrl-C to discard Input device IP (192.168.31.1) ==:192.168.1.1 Input server IP (192.168.31.3) ==:192.168.1.3 Input Uboot filename (uboot.bin) ==:breed.bin 按回车后开始刷机，过几秒钟后路由器会自动重启，第三方Boot Loader刷写完成。\n路由器断电，长按reset键的同时通电开机，灯闪烁后打开浏览器输入网址http://192.168.1.1便可访问breed后台。\nDone 第三方Breed刷完后，先用Breed刷小米官方的开发版固件，开启ssh，之后按照小米路由器3G折腾之刷OpenWrt记录这篇文章刷OpenWrt。\nBusyBox v1.19.4 (2018-10-29 07:52:03 UTC) built-in shell (ash) Enter \u0026#39;help\u0026#39; for a list of built-in commands. ----------------------------------------------------- Welcome to XiaoQiang! ----------------------------------------------------- $$$$$$\\ $$$$$$$\\ $$$$$$$$\\ $$\\ $$\\ $$$$$$\\ $$\\ $$\\ $$ __$$\\ $$ __$$\\ $$ _____| $$ | $$ | $$ __$$\\ $$ | $$ | $$ / $$ |$$ | $$ |$$ | $$ | $$ | $$ / $$ |$$ |$$ / $$$$$$$$ |$$$$$$$ |$$$$$\\ $$ | $$ | $$ | $$ |$$$$$ / $$ __$$ |$$ __$$\u0026lt; $$ __| $$ | $$ | $$ | $$ |$$ $$\u0026lt; $$ | $$ |$$ | $$ |$$ | $$ | $$ | $$ | $$ |$$ |\\$$\\ $$ | $$ |$$ | $$ |$$$$$$$$\\ $$$$$$$$$ | $$$$$$ |$$ | \\$$\\ \\__| \\__|\\__| \\__|\\________| \\_________/ \\______/ \\__| \\__| root@XiaoQiang:~# ","permalink":"https://blog.starry-s.moe/posts/2021/xiaomi-r3g-ttl-flash/","summary":"\u003cp\u003e本来路由器闲置了一年了都没咋用了，前两天想把OpenWrt系统刷回原厂系统。\u003c/p\u003e\n\u003cp\u003e然鹅刷原厂固件时忘记改环境变量了，因为第三方Boot Loader也被我顺带刷回了原厂的所以现在开机无限重启。\u003c/p\u003e\n\u003cp\u003e之前买单片机套件时赠了一条usb转ttl线的，但是被我放学校了。只好再从万能的某宝再买一条线，尝试着救砖了。\u003c/p\u003e\n\u003cp\u003e(在某宝发现了一家店啥元件都有，还特别便宜。于是我还顺带买了很多杜邦线、电阻、LED灯、面包板等小玩意\u0026hellip;)\u003c/p\u003e","title":"小米路由器3G之使用TTL串口刷机救砖"},{"content":"前天在狗东买了台27寸4K显示器，型号为优派VX2771-4K-HD，分辨率3840x2160，支持HDR 10bit色深（然而电脑只支持DP1.2），因为之前已经配置好了optimus-manager，所以电脑接上显示器就能亮，很幸运没有遇到物理问题。\n然后一看4K屏上的字小得瞎眼。\n如果设置分辨率为1080P，显示文字时会特别糊，根本没法看，效果还没有1080P显示器好。\n解决方法 首先按照Wiki设置GNOME的HIDPI:\n$ gsettings set org.gnome.settings-daemon.plugins.xsettings overrides \u0026#34;[{\u0026#39;Gdk/WindowScalingFactor\u0026#39;, \u0026lt;2\u0026gt;}]\u0026#34; $ gsettings set org.gnome.desktop.interface scaling-factor 2 在显示设置里将缩放调到200%后，界面被放大了2倍，在4K屏上的字倒是不瞎眼了。\n但是因为笔记本是15寸1080P，所以笔记本上显示的字大得离谱。\n解决方法是使用xrandr调整笔记本电脑的屏幕缩放，笔记本的分辨率为1920x1080，使用xrandr将画面的分辨率放大2倍，也就是调整为3840x2160，然后显示在分辨率为1920x1080的显示器上。\n首先使用xrandr查看每个显示器所对应的设备名称和分辨率。\n$ xrandr | grep \u0026#34;$extern connected\u0026#34; HDMI-0 connected primary 3840x2160+0+0 (normal left inverted right x axis y axis) 597mm x 336mm eDP-1-1 connected 1920x1080+0+2160 (normal left inverted right x axis y axis) 344mm x 193mm 这里HDMI-0是外接的4K显示器，分辨率为3840x2160，位置为(0, 0)。\neDP-1-1是笔记本的显示器，分辨率1920x1080，位置为(0, 2160)，在4K显示器的左下方。\n参见Wiki设置双显示器部分，用xrandr将笔记本的显示器缩放2倍，分辨率变为 [1920 * 2]x[1080 * 2]=3840x2160，位置还是在4K显示器的正下方。\n$ xrandr --output eDP-1-1 --scale 2.0x2.0 --panning 3840x2160+0+2160 --output HDMI-0 --auto 因为不需要修改4K显示器的分辨率，所以HDMI-0设置为auto。\n这样笔记本上的画面也显示正常了。\n但是用过一阵子会发现笔记本显示器上的字比4K显示器上的字小很多，看起来不方便，所以把缩放倍数改为1.6（我是从1.5-2.0之间一点点试的，才找到最适合自己的缩放倍数），这样解决了字体大小的问题，不过笔记本画面还是会有模糊（能接受）。\n[1920 * 1.6]x[1080 * 1.6]=3072x1728\n$ xrandr --output eDP-1-1 --scale 1.6x1.6 --panning 3072x1728+0+2160 --output HDMI-0 --auto 用到现在GNOME的缩放还算是完美，除了玩Minecraft用的HMCL启动器（Java程序）没有被放大之外~~（貌似缺配置，要是配置好了我再补充）~~，Steam界面缩放正常，饥荒、Dota2也都没问题。\nJava8不支持Hidpi缩放，如果想让HMCL支持缩放需要需要安装Java9以上的版本，所以还是算了，又不是不能用。 网易云音乐缩放方法参考这篇博客。 qt5设置环境变量QT_SCREEN_SCALE_FACTORS=2。\nOthers 仅限GNOME，因为我只用GNOME所以不知道其他DE开HIDPI的效果是什么样。\n听说Wayland支持不同显示器设置不同的缩放倍数，但是我笔记本的HDMI是独显输出，自带屏幕为集显输出，想启用独显输出画面除了用大黄蜂之外只能Nvidia Optimus，然而Optimus不支持Wayland（F**K NVIDIA）， 于是我现在都不知道用Wayland上双显示器的效果是什么样子，只好改用xorg和optimus-manager切换显卡，再用xrandr调显示器的缩放倍数。\n或者买一根type-c转DP的线连显示器，我电脑的type-c支持DP1.2，可以输出4K60fps，而且走集显输出。\nxrandr的指令是我自己试了很多遍试出来的，在我电脑上能用，期间遇到一堆问题(BadMatch)，没想好什么解决方法，所以在别的电脑上可能需要一些修改。\n如果你正考虑为你的笔记本购买一台新显示器而且你是Linux用户，你的笔记本又是双显卡，不知道HDMI是独显输出还是集显输出的话，建议你买一台和笔记本电脑的分辨率相同的显示器(或者2K)，这样能省去很多麻烦。\n用了几个月后经常遇到显示器通过HDMI连接到电脑但是没有视频输出的情况，所以现在改用的是type-c转DP的连接线，走集成显卡输出，就没有遇到过这个问题。\n","permalink":"https://blog.starry-s.moe/posts/2021/laptop-dualscreen-hidpi-scale/","summary":"\u003cp\u003e前天在狗东买了台27寸4K显示器，型号为优派VX2771-4K-HD，分辨率3840x2160，支持HDR 10bit色深（然而电脑只支持DP1.2），因为之前已经\u003ca href=\"/posts/2021/archlinux-pavilion-gaming-laptop/\"\u003e配置好了optimus-manager\u003c/a\u003e，所以电脑接上显示器就能亮，很幸运没有遇到物理问题。\u003c/p\u003e\n\u003cp\u003e然后一看4K屏上的字小得瞎眼。\u003c/p\u003e\n\u003cp\u003e如果设置分辨率为1080P，显示文字时会特别糊，根本没法看，效果还没有1080P显示器好。\u003c/p\u003e","title":"解决笔记本外接HIDPI显示器的缩放问题"},{"content":"本来我已经戴好耳机准备睡觉了的，突然想起来2020年的年终总结还没有写，恰好脑子里有想写的东西，于是大概构思了一下，便从床上爬起来开灯打开电脑开写年终总结。\nLunar tear\n因为思路不是很稳定，总是写了删删了写，所以隔了这么久才把原本已经放弃了不打算写的年终总结重新写出来。\n果然还是深夜适合写这些东西。\n今年原本打算能像去年那样在假期外出旅行的，然而疫情爆发后我就一直窝在家待着哪里都没去，不过在1月17号也就是武汉封城前几天，我自己一个人坐飞机跑去北京玩了一圈，当时还不知道有疫情这么一回事，到北京后就是找个地方住下，简单的去了一些景点，后来因为脚疼，很多路远的人多的地方都没有去成。在北京闲逛3天后就坐大客车回家了（一边坐车一遍骂京哈高铁京承段为什么一点进展都没有）。到家后不几天就听说武汉开始封城，然后北京就开始交通管制，现在想想还挺刺激的。\n然后暑假本来打算去上海BW2020的，在票都买好了之后，因为外出需要和学校审批（此处省略若干字），最终漫展门票全打水漂，飞机票退票手续费还花了三百多块钱。\n上半年宅在家里大半年，几乎是什么都没学，什么事情都没干。不过也借此机会每天都能睡个大懒觉，总之就是狠狠的歇了一顿，尝试着把高中时期欠的觉补回来，然而似乎并不管用。\n然后总感觉自己每天都很累，明明什么都没有干但是身体总是一点力气都没有，总之下半年开学后经历了很长一段时间才重新适应了学校的生活，期间心理变化很复杂。\n所以大二下学期和大三上学期的期末成绩基本上都是刚好及格。（真的是烤60分比烤80分还高兴）\n年初看了几集超电磁炮3，看到后来因为它更新太慢了就忘了继续看了。之后还看了格莱普尼尔，看这个番纯粹是因为它的OP是Hikaru唱的，看着看着觉得挺有意思而且官方更新速度很快，于是就把第一季追完了。\n然后因为Lacrimosa这首歌，我才看的黑执事，不过自己比较懒只看了第一季，第二季一直咕到现在都没有看，听说剧情挺虐的所以我更不敢看了。（明明第二季的ed比第一季的还好听）\n本来还打算看新世纪福音战士的，也是因为懒，看了一集就不继续看了。\n除此之外，年末的时候在睡前为了打发时间看了几集非自然死亡。\n这一年又打了一遍尼尔：机械纪元。和第一次玩不太一样，二刷时我尽可能的多做支线任务，不开简单模式和自动芯片。不过通关后我还没有打E结局，总想找个时间把其他支线任务做完。\n年初在逛淘宝时发现了台版的尼尔原著小说，于是毫不犹豫的把少年寄叶、短话和长话全都买了下来。不过截至目前我只看完了短话。在看完艾米尔的回忆那一章后很感动于是打开游戏找到相对应的支线任务，废了很大力气找到那三朵“Lunar Tear”（月之泪）之后，前往种着一大片月之泪的地下室。\n在网上看攻略找到了艾米尔居住的家，于是又走了很远的路到地下很深的地方，到他家里面拿（偷）走了面具。\n据说去他家偷完东西后会触发艾米尔的boss支线，不过因为在寝室没太多时间所以我没有继续玩下去。\n蛮期待2021年4月发行的尼尔续作的，不过有些担心我的笔记本还能不能跑得起来。\n尝试着二刷空境原著，不过没刷完，所以只好等以后有时间再看了。\n2020年下半年花了很大力气尝试玩懂FGO，不过最终因为太肝、自己太非、没时间而劝退，前几章的主线太枯燥乏味了，而且我貌似只对FSN系列和空境系列的人感兴趣，FGO里面的人物基本和他们不沾边而且我也不认识。\n很期待月姬重制版，尽管我目前还一点都不了解月姬。既然月姬重置版只在主机平台上映，尼尔续作也有主机版，那么我是不是应该提前准备一台PS4呢？\nPS5水货太贵了还是算了，除非等国行，然而等国行又要等到4月份。\n关键是我连PS4都买不起。\n2021年1月22日后续： 最终买了二手港版PS4 Slim，考虑了价格、重量、性能、体积等因素后没有买Pro（主要是没钱），因此现在变得非常贫穷。 换了笔记本上拆下来闲置了一年的1T硬盘，尝试着在尼尔：伪装者发售前三刷一遍尼尔：机械纪元，因为PS4太好玩了所以现在在后悔为什么不早点买PS4。\n2020年4月份的时候新开了一个Minecraft单机生存的坑，原本是打算看一下新版本（1.15.2）更新了什么新特性的（蜜蜂），结果玩上生存就停不下来了。先是花了两个星期用纯铁镐手挖两个史莱姆区块，用矿车运村民和僵尸照着B站的视频建了简易的刷铁机，之后又用不到一个月的时间解放末地。总之就是玩上了就停不下来了。然后照着B站各大UP主的视频做了末地刷沙机、然后是混凝土固化机，后来挂三向轰炸机肝了3天清了出生点空置域。用了短短几个月的时间一个人建了很多东西，去地狱打了凋零骷髅头，建海上刷怪塔刷火药和骨粉。后来物资储备足够多了之后就开始挖地铁（旧习难改吧），一年的时间挖了两条地铁线路，盖了十几座车站、一座跨海大桥、一栋摩天大楼。\n原来单机生存还能玩得这么有意思，B站上有很多生电大佬，然而红科搬的视频我基本都看不懂。\n后续可能要再修几条地铁，延长已有的线路，然后再搞一些建筑，炸一个原点空置域修全物品分类机，然后还打算升级1.16.4。\n就回忆到这里吧，2020是个特别的一年。\n犹豫了很久最后还是决定把之前删掉的部分文章恢复回来，不然总给人一种这个博客是在2020年创建的而不是2016年创建的错觉。\n2020年博客鸽了很长一段时间，当时尽管并没有放弃博客但是我真的什么都写不出来，因为看到自己以前写的水文觉得很恶心而且十分不适，于是就在某个心情不好的时候删掉了。后来换了一个新的域名之后就再也没和任何人提起“我还有一个博客”这件事情，因为把博客的文章全删除后几乎没人访问我的博客，新的访客量到现在为止才800多，其中绝大多数都是我自己调试页面刷新时点出来的。\n对啊博客就是用来记录生活的，所以就让“因为看不惯以前的自己写的啥也不是的水文最终将其全部删掉”也成为博客记录下的一件事吧。\n","permalink":"https://blog.starry-s.moe/posts/2021/hello-2021/","summary":"\u003cp\u003e本来我已经戴好耳机准备睡觉了的，突然想起来2020年的年终总结还没有写，恰好脑子里有想写的东西，于是大概构思了一下，便从床上爬起来开灯打开电脑开写年终总结。\u003c/p\u003e","title":"Hello 2021"},{"content":"赶在期中考试(骑磨烤柿)前把单片机的课后习题整理出来\u0026hellip;\n(实在是没什么可拿来更新博客的了, 就干脆写点复习资料吧\u0026hellip;)\n本篇内容为作者整理资料所得, 仅供学习使用。如需转载请务必遵循CC BY-NC-ND 4.0协议。 请勿将本篇内容作为权威的教学辅导资料使用, 因无法保证100%准确, 仅供参考。\n如果发现了本篇存在的错误, 欢迎在页面下方提issue指正。\n本篇文章使用MathJax显示数学公式，在使用RSS阅读器时会出现无法正确显示的情况。\n硬件结构\u0026amp;指令系统 8051复位后从地址0000H开始执行程序, SP的值为07H。\nPC: 两字节(16位)寄存器, 也称程序计数器。\nSP: 堆栈指针, 指示出堆栈顶部在内部RAM块中的位置。\n单片机的堆栈设在了内部RAM区, 单片机复位后, SP中的内容为07H(指向第0组工作寄存器的R7), 堆栈实际上从08H开始。\n若SP被初始化为39H, 则堆栈实际上是从3AH开始的。\n执行LCALL addr16指令时，单片机先将PC的低字节压栈，再将PC的高字节压栈，最后把转移地址送入PC中。\n与之类似的LJMP类无条件转移指令，单片机只修改PC的值，并不堆栈保存跳转前的PC中保存的地址。\n执行RET指令后, SP值减2 (因为PC为2字节寄存器), 进行两次出栈操作，第一次出栈送PC的高位，第二次出栈送PC的低位。\n中断服务程序结束指令RETI不仅将堆栈中保存的2字节地址分别送入PC的高位和低位中，而且复位中断系统。因此RET和RETI不同。\nRET和RETI对堆栈的操作是相同的。\nPSW中的RS1 RS0=10B时, R2的RAM地址为12H。\nPSW： 程序状态字寄存器, 从PSW.7至PSW.0分别为Cy(进位标志位), Ac(辅助进位标志位), F0(标志位), RS1和RS0(寄存器区选择控制位), OV(溢出位), 保留位, P(奇偶标志位, 奇数为1, 偶数为0)。\nD7 D6 D5 D4 D3 D2 D1 D0 PSW Cy Ac F0 RS1 RS0 OV P RS1 RS0 = 10B时, 使用第二组工作寄存器区, 第0组工作寄存器区R0-R7的地址为00H-07H, 第1组为08H-0FH, 第2组为10H-17H, 第3组为18H-1FH(每组长度为8个字节, 每个寄存器占1个字节)。\n因此, 当A为01110010B时, PSW中P为0(偶数个1)。\nINC A指令不改变PSW中的Cy，只有可能改变奇偶标志位P。\n假设PSW为18H, 即00011000B, 此时使用第3组工作寄存器, R0地址为18H, R7地址为1FH。\n复位后, 默认选择的寄存器区是0区。\n8051片外数据存储器的寻址空间为0000H~0FFFFH\n位地址07H位于字节地址20H, 位地址7FH位于字节地址2FH。\n片内RAM中20H~2FH这16个单元即可进行共128位的位寻址, 也可进行字节寻址。\n字节地址及其位地址见下表所示：\n字节地址 D7 D6 D5 D4 D3 D2 D1 D0 2FH 7FH 7EH 7DH 7CH 7BH 7AH 79H 78H 2EH 77H 76H 75H 74H 73H 72H 71H 70H 2DH 6FH 6EH 6DH 6CH 6BH 6AH 69H 68H \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; 21H 0FH 0EH 0DH 0CH 0BH 0AH 09H 08H 20H 07H 06H 05H 04H 03H 02H 01H 00H 因此00H~07H位于字节地址20H, 78H-7FH位于字节地址2FH。\n除此之外，一些特殊功能寄存器（SFR）可进行位寻址（字节地址能够被8整除），SFR中位地址有83个（共有88个，5个未用），能够位寻址的SFR的字节地址末位均为0H或8H。\n访问外部存储器时, P0口用来传输低8位地址和数据, P2口用来传送高8位地址。\n访问外部存储器时, ALE的输出用于锁存低8位地址。\n一个机器周期为12个震荡周期\n为保证读入数据正确, 在读一个端口引脚之前应先向相应的端口锁存器写1。\n如果在读一个端口引脚之前向对应的输出锁存器写了0, 将总是读到0。\n8051访问片外存储器时, 利用ALE信号锁存来自P0的低8位地址信号。\n只能用直接寻址方式访问特殊功能寄存器。\n如果为8052单片机, 在访问高128字节的RAM时, 只能用间接寻址方式寻址。\n访问片外数据存储器64Kbyte时, 使用DPTR做间接寻址寄存器。\n使用MOVX @DPTR类指令访问外部扩展存储器时, P2口输出高8位地址, P0口传送低8位地址和数据。\n8051中, PC和DPTR都用于提供地址时, PC是用户程序不可访问的, DPTR可以分为两个8位寄存器DPH和DPL使用。\n累加器A的值为30H, 指令MOVC A, @A+PC位于地址3000H。执行该指令时, 程序存储器地址3031H的内容被传送至累加器A。\n指令MOVC A, @A+PC长度为1字节, 位于地址3000H, 因此PC值为3001H, 故A+PC为3031H。\n设SP的值为5FH, 指令LCALL DELAY所在地址为2030H, 子程序DELAY所在地址为20A0H, 则该指令完成的操作是将地址2033H压入堆栈保存, 将地址20A0H送入PC, SP的值应在该指令执行结束后变成61H。 单片机执行子程序或中断服务程序时, 需要保护现场, 即将PC当前的值压栈保存, 当子程序或中断服务程序运行结束后再进行出栈。(所以如果子程序修改了栈的内容, 在子程序运行结束后程序有可能会运行错误)。\nPC是16字节寄存器, 所以SP需要加2, 以此分别保存PC的高、低8位的数据。\nLCALL addr16这条指令占3字节, 其中addr16占两字节, 因此程序可跳转64KB范围内的地址。\n(ACALL指令只能跳转当前所在的2K范围内的地址, 如果不涉及到片外数据存储器的话, 通常只用SJMP和AJMP)\n在网上搜到的答案「将3500H送入PC」是错误的, 实际是将20A0H送入PC, 因为DELAY所在的地址为20A0H, 和3500H一点关系都没有。\nMOVC访问 程序(ROM) 存储器, MOVX指令访问 外部数据 存储器。 MOVC为查表指令, 只有MOVC @A+PC和MOVC @A+DPTR这两条, 均为单字节指令。\nMOVX用于累加器A与外部数据存储器进行传送。\n可以是MOVX A, @DPTR, MOVX A, @Ri, MOVX @DPTR, A, MOVX @Ri, A，其中i为0或1.\n当使用MOVX @Ri类指令时，只有P0口用来传送地址和数据，P2口的状态不会发生改变，因此可使用MOV P2, #12H指令设定高8位的地址。\n当采用Ri作间接寻址时, 只能寻找片外256个单元的数据存储器, 此时8位地址和数据均由P0口传送，P2口的状态不发生改变。\n假设指令DJNZ R7, rel位于005FH, 如果在执行该指令前寄存器R7值为00H, 偏移量rel为02H, 则该指令执行后下一条要执行的指令所在的地址是005FH。 DJNZ R7, rel位于005FH, 该指令长度为2字节 (书上写的3字节是错的), 所以在执行这条指令开始时PC值在原来的基础上 + 2 变为0061H。又因为rel为02H, 所以执行这条指令后, PC值变为0063H。\n分析下面子程序的功能, 假设8051单片机的震荡频率为6MHz。 DL: MOV R7, #0AH L0: MOV R6, #250 L1: NOP NOP DJNZ R6, L1 DJNZ R7, L0 RET R7为10, R6为250, 因此两个NOP加上一个DJNZ一共循环了250次, 该250次的循环一共执行了10次。\nNOP为1周期指令, DJNZ为2周期指令, 两个NOP加一个DJNZ共4周期。\n6MHz下一个机器周期为\\(12 \\div (6 \\times 10^6)= 2{\\mu}s\\), 12MHz下一个机器周期为1微秒。\n故程序该子程序延时了\\((4 \\times 250 \\times 10 \\times 12) \\div (6 \\times 10^6) = 20(ms)\\)\n(实际上有10次MOV R6, #250和10次DJNZ R7, L0造成的30个机器周期的约0.6ms的误差)\n以下部分写于2020年11月25日\n汇编语言程序 编写一个子程序, 将内部RAM 40H~4FH的内容复制到50H~5FH。\nCOPY: MOV R0, #40H MOV R1, #50H MOV R2, #10H ; 40H~4FH一共复制了16次 LOOP: MOV A, @R0 MOV @R1, A INC R0 INC R1 DJNZ R2, LOOP RET 因为没有MOV @RX, @RX这条指令, 所以用A做数据的中转站。\n将任何无符号8位二进制数转换为BCD码的子程序, 入口参数为内部RAM单元20H, 出口参数为内部RAM单元30H和31H, 30H存放百位数, 31H存放十位数和个位数。\nCV: MOV R0, #20H MOV A, @R0 MOV B, #100 DIV AB; A除以100, 得到的百位数存在A中 MOV 30H, A MOV A, B MOV B, #10 DIV AB SWAP A ADD A, B; 也可以用ORL MOV 31H, A RET DIV AB和MUL AB的A和B之间没有逗号。\n内部RAM 30H单元存放两位十进制数 (压缩BCD码), 编写将该十进制数转换为对应ASCII码的子程序, 转换结果存放到内部RAM 40H (十位数) 和41H (个位数) 单元。\nASCII码： 30H为0, 41H为A, 61H为a\nCV: MOV A, 30H ANL A, #0FH MOV DPTR, #DATA; 或者直接用ADD A, #30H即可 MOVC A, @A+DPTR MOV 41H, A MOV A, 30H SWAP A ANL A, #0FH MOVC A, @A+DPTR MOV 40H, A RET DATA: DB 30H, 31H, 32H, 33H, 34H, 35H, 36H, 37H, 38H, 39H 8个8位数相加, 求平均值, 入口地址为30H~37H, 结果存到40H。\n把8位数相加存在溢出, 所以把相加结果以16进制存到R2、R3中, 再除以8( 右移3次), 即可求得不四舍五入的平均值。\nMOV R0, #30H MOV R1, #08H MOV R2, #00H MOV R3, #00H ; 初始化 LOOP: CLR C MOV A, @R0 ADD A, R3 MOV R3, A JNC SKIP INC R2 SKIP: INC R0 DJNZ R1, LOOP 这样结果被保存到R2、R3中, 然后需要写一个循环右移3位的程序。\nMOV R4, #03H LOOP2: RRC R2 RRC R3 DJNZ R4, LOOP2 MOV 40H, R3 ; 右移3次后R2的低4位为0, 结果保存在R3中 这样R3中求得的是不带四舍五入的结果。\n如果需要带四舍五入的话第一种方法是判断最后一次右移时最低位是否为\\(1\\)，\\((1 / 2 = 0.5)\\)。\nMOV R4, #03H LOOP2: RRC R2 RRC R3 DJNZ R4, LOOP2 JNC SKIP2 INC R3 SKIP2: MOV 40H, R3 ; 右移3次后R2肯定为0 这样是带四舍五入的结果。\n第二种方法，8个8位数相加求平均值，要求四舍五入的话，只需要在这8个数求和后再加4（0100B），之后右移3次。\nADD A, #04H MOV R3, A JNC SKIP2 INC R2 SKIP2: MOV R4, #03H LOOP2: RRC R2 RRC R3 DJNZ R4, LOOP2 结果保存在R3中。\n中断系统 8051的外部中断有低电平触发和下降沿触发两种触发方式。外部中断1的中断向量地址是0013H。\n在响应中断时, 单片机自动生成一条长调用指令LCALL addr16, 其地址为中断入口地址。\n中断源 入口地址 INT0 0003H T0 000BH INT1 0013H T1 001BH 串行口 0023H 通常在中断入口地址处放一条无条件转移指令*JMP。\n内部查询顺序同入口地址的顺序，由高到低。\n执行指令MOV IP, #0BH( #00001011B)后, 中断优先级最高者为PX0, 最低为PS。\nIP: 中断优先级寄存器, 其前3为无意义, 后5位( IP.4至IP.0)为：PS, PT1, PX1, PT0, PX0, 分别对应串行口、定时器T1、外部中断1、定时器0、外部中断0。\nD7 D6 D5 D4 D3 D2 D1 D0 IP PS PT1 PX1 PT0 PX0 单片机复位以后, IP的内容为0, 各个中断源均为低优先级中断。\n在同时收到几个同一优先级的中断请求时, 中断响应取决于内部查询顺序, 其顺序由高到低为：INT0、T0、INT1、T1、串行口。\n当中断源均为同一优先级时, 当它们同时申请中断时CPU首先响应外部中断0\n8051的晶振频率为12MHz, 则最短的外部中断响应时间为3\\(\\mu\\)s, 最长的外部中断响应时间为12\\(\\mu\\)。\n中断标记位于单片机寄存器的TCON和SCON中。\nD7 D6 D5 D4 D3 D2 D1 D0 TCON TF1 TR1 TF0 TR0 IE1 IT1 IE0 IT0 SCON SM0 SM1 SM2 REN TB8 RB8 TI RI TCON中TF1和TF0为定时器/计数器中断标志位, TR1和TR0为定时/计数启动位, IE1和IE0为外部中断标志位, IT1和IT0为选择外部中断为边沿触发(1)还是电平触发(0)方式。\nSCON中前几位与串行口有关，第1位和第2位的TI和RI(是大写字母I不是数字1)分别为串行口中断发送中断请求标志位(发送成功后置1)和接受中断请求标志位( 接受成功后置1)。串口中断无法硬件清零, 只能软件清零。\n当IE中EA为1、ES为1时，TI或RI为1时，CPU执行无条件转移指令LJMP 0023H, 执行串行口中断服务程序。\n要使8051能够响应定时器T1的中断和串行口中断, 不响应其他中断, 则中断允许寄存器IE的内容为98H(10011000B)。\n中断允许寄存器IE：\nD7 D6 D5 D4 D3 D2 D1 D0 IE EA ES ET1 EX1 ET0 EX0 EA为总控制位, 当EA为1时, CPU才可以响应中断请求。\nES为串行口中断允许位, ET1和ET0为定时器中断允许位, EX1和EX0为外部中断允许位。\n定时器和计数器 使T0工作方式1的溢出周期最长的初值是0000H。\n定时器/计数器工作在方式0为13位计数器, 由TLX的低5位和THX的高8位组成13位计数器, 最大值为\\(2^{13}-1 = 8191\\), 晶振频率12MHz下计时周期最长为8.192ms。工作在方式1时由均为8位的TLX和THX组成16位计数器, 最大值为65535, 晶振频率为12M下最长为65.536ms。\n当定时器/计数器工作在方式2时, 可以循环定时/计数。当计数溢出后, 自动将8位的THX装入8位的TLX中, 可省去重装初值的时间, 最大值为255, 晶振频率12M下计时周期最长为0.256ms。\nT1配置为方式3时, 停止计数, 方式3只适用于定时器0。\n定时器T0的方式3将其分为两个8位定时器, 其中TH0只能做定时器使用。\n设8051单片机的晶振频率为12MHz, 定时器作计数器使用时, 其计数输入信号的最高频率为500KHz。\n当定时器用作计数器时, 当检测到引脚上的负跳变时计数器的值增一。检测下降沿需要2个机器周期, 即24个震荡周期, 所以输入信号最高频率为 \\(12M \\div 24 = 500KHz\\)。\n用定时器方式2扩展一个下降沿触发的外部中断, 计数初值应为FFH。\n此处定时器2以计数器方式运行, 当检测到一个下降沿后, 计数器加一后溢出, 因此会执行定时器中断的中断子程序。\n2020年12月3日： 前两天感冒, 休息了几天(打了两天的游戏)后继续。\n串行口 串行口TXD为高电平, 表示这是数据位或停止位或空闲状态。\n串行口工作在方式1时, TXD用来发送数据、RXD用来接受数据。方式1的一帧数据为10位, 起始为为0, 停止位为1, 数据位和空闲状态均可能为0或1。\n串行口工作在方式3时, 发送的第9位数据要事先写入寄存器SCON的TB8, 接收的第9位数据被写入同一寄存器的RB8。\n串行口控制寄存器SCON：\nD7 D6 D5 D4 D3 D2 D1 D0 SCON SM0 SM1 SM2 REN TB8 RB8 TI RI 其中SM0、SM1为串口的工作方式选择位, 方式0为同步移位寄存器方式, 方式1为8位异步收发, 方式2和方式3为9位异步收发。\n波特率：串行口每秒钟传送的比特位数，单位bits/s。\n方式0的波特率固定为 \\(f_{osc}/12\\), 方式2的波特率为 \\(f_{osc}/64\\) 或 \\(f_{osc}/32\\) (由SMOD控制)。\n方式1的波特率和方式3的波特率可变, 公式为 \\((2^{SMOD} / 32) \\times 定时器T1的溢出率\\)。\nT1的溢出率为定时器T1的周期的倒数，定时器的周期为\n$$T = \\frac{12\\times (2^n - X )}{f\\_{osc}}$$ 当T1工作在方式2时，n为8，波特率为：\n$$波特率=\\frac{(2^{SMOD} \\div 32) \\times f_{osc}}{12 \\times (256 - X)}$$ \\(X\\)为定时器T1的初值。\n串口工作在方式1，波特率为2400，则每秒钟最大能发送/接收 \\(2400 \\div 10 = 240Byte\\) 的数据。\n单片机工作在方式1时, 1帧数据为1个起始位、8个数据位、1个停止位共10位。\n8051的UART工作在方式3，要求每秒钟能传送不少于900个字节的数据，则波特率应当大于 \\(900 \\times 8 = 7200bits/s\\)。\n比特率2400Kbits/s，时钟频率12M，PC机发送8个字节的数据存到单片机的30H-37H中，随后单片机发送2个确认字节55H和AAH给PC机，使用查询方式。\nORG 0000H MAIN: MOV SCON, #50H ; 串口使用方式1，且允许接收 MOV PCON, #00H ; 波特率不加倍 MOV TMOD, #20H ; 定时器1使用方式2 MOV TL1, #0F3H MOV TH1, #0F3H SETB TR1 LOOP: MOV R0, #30H MOV R1, #08H REC: JNB RI, $ MOV @R0, SBUF CLR RI ; 软件清零RI INC R0 DJNZ R1, REC MOV SBUF, #55H JNB TI, $ CLR TI MOV SBUF, #0AAH JNB TI, $ CLR TI AJMP LOOP END 单片机接收到数据后，RI被置1，代表SBUF中的数据有效，取走SBUF中的数据后需要软件清零RI（串口中断不会自动清零RI）。\n当单片机执行写SBUF操作时，串口发送开始，TI被自动置1，在发送完成后TI被自动清0。\n2020年12月7日：\nI/O口 \u0026amp; 外部存储器拓展 8051使用指令MOVX A, @R0读外部数据存储器时，不起作用的信号是WR。\n8051在使用MOVX @DPTR类指令读外部数据存储器时，P0和P2先输出外部数据的地址，单片机发出的ALE信号的负跳沿将P0口输出的地址锁存在地址锁存器(74HC573)里，之后单片机发出RD信号，读取外部数据存储器（RAM）的数据到总线再传送到P0口上。最后单片机从P0口读取数据保存到A中。\n如果是写外部数据存储器时，单片机将不发出RD信号而是WR信号，将A中的数据写入外部数据存储器中。\n存储器芯片6264需要13根地址线。\n62256的容量为 \\(256Kbit \\div 8 = 32KB = 2^{15}\\), 需要15根地址线。\n6264的容量为 \\(64Kbit \\div 8 = 8KB = 2^{13}\\)，所以需要13根地址线。\n6116容量为 \\(16Kbit \\div 8 = 2KB = 2^{11}\\), 需要11根地址线。\n计算方法是62 \\(X\\) 的 \\(容量=X \\div 8(K)\\)。\n使用16位地址模式时，8051的外部数据存储器寻址空间为64KB。\n基于8051的单片机系统能拓展的外部数据存储器容量无限制。\n有的书上说最大只能拓展64KB，实际是最大寻址空间为64KB，拓展的外部数据存储器容量无限制。\n8051的程序存储器可用来存放用户程序和数据。 例如使用DW或DB指令用来定义数据。\n所以应用程序也可以使用MOVC A, @A+DPTR访问程序存储器中的数据。\n除此之外LED数码管和外部存储器拓展、外部I/O设备拓展部分有很多需要根据线路图计算地址和DA转换的题，因为线路图源自老师提供的PDF，而老师为PDF加了密码，意味着不允许外传，所以我就不放到博客上面了，除非我自己用Porteus画一个类似的\nLED段码入口地址8004H，位选入口地址8002H，将30H-32H保存的6个压缩BCD码发送到6位共阴极数码管上显示， 要求编写延时1ms的子程序。\nMAIN: MOV R0, #30H ; R2用来计数 MOV R2, #03H ; R3用来位选 MOV R3, #01H LOOP: MOV A, @R0 SWAP A ANL A, #0FH MOV DPTR, #TAB MOVC A, @A+DPTR ; 取高4位BCD码对应的段码 MOV DPTR, #8004H MOVX A, @A+DPTR ; 先送段码 MOV A, R3 MOV DPTR, #8002H MOVX @DPTR, A RL A MOV R3, A ; 再送位选 LCALL DELAY MOV A, @R0 ANL A, #0FH MOV DPTR, #TAB MOVC A, @A+DPTR ; 取低4位BCD码对应的段码 MOV DPTR, #8004H MOVX A, @A+DPTR ; 送段码 MOV A, R3 MOV DPTR, #8002H MOVX @DPTR, A RL A MOV R3, A ; 送位选 LCALL DELAY INC R0 DJNZ R2, LOOP DELAY: MOV R7, #250 DL: NOP NOP DJNZ R7, DL RET TAB: DB 3FH, 06H, 5BH, 4FH, 66H, 6DH, 7DH, 07H, 7FH, 6FH END 打印机数据输入接口和P1直接相连，STB接口和P3.4相连，BUSY接口和P3.3相连，不使用ACK应答信号，编写将外部存储器1000H-100FH的数据发送到打印机打印的子程序。\nPRINT: MOV DPTR, #1000H MOV R2, #10H LOOP: JB P3.3, $ ; 确保打印机处于空闲状态 MOVX A, @DPTR MOV P1, A CLR P3.4 SETB P3.4 INC DPTR DJNZ R2, LOOP RET 如果打印机没有和P1直接相连，而是连接到数据锁存器上（74HC374），锁存器的时钟信号的入口地址为A000H。\n使用堆栈保护间接寻址寄存器的值。\nPRINT: MOV R2, #10H MOV DPTR, #1000H LOOP: JB P3.3, $ ; 确保打印机处于空闲状态 MOVX A, @DPTR PUSH DPL PUSH DPH MOV DPTR, #0A000H MOVX @DPTR, A POP DPH POP DPL CLR P3.4 SETB P3.4 INC DPTR DJNZ R2, LOOP RET SFR列表 87H D7 D6 D5 D4 D3 D2 D1 D0 PCON SMOD - - - - - PD IDL 88H D7 D6 D5 D4 D3 D2 D1 D0 TCON TF1 TR1 TF0 TR0 IE1 IT1 IE0 IT0 89H D7 D6 D5 D4 D3 D2 D1 D0 TMOD GATE C/T M1 M0 GATE C/T M1 M0 98H D7 D6 D5 D4 D3 D2 D1 D0 SCON SM0 SM1 SM2 REN TB8 RB8 TI RI A8H D7 D6 D5 D4 D3 D2 D1 D0 IE EA - - ES ET1 EX1 ET0 EX0 B8H D7 D6 D5 D4 D3 D2 D1 D0 IP - - - PS PT1 PX1 PT0 PX0 D0H D7 D6 D5 D4 D3 D2 D1 D0 PSW Cy Ac F0 RS1 RS0 OV - P ","permalink":"https://blog.starry-s.moe/posts/2020/learn-mcs8051/","summary":"\u003cp\u003e赶在\u003cdel\u003e期中考试\u003c/del\u003e(骑磨烤柿)前把单片机的课后习题整理出来\u0026hellip;\u003c/p\u003e\n\u003cp\u003e(实在是没什么可拿来更新博客的了, 就干脆写点复习资料吧\u0026hellip;)\u003c/p\u003e","title":"51单片机习题整理"},{"content":"自从高中毕业至今这台笔记本用了将近两年, 已经记不清当初为什么买了这台笔记本, 刚买来电脑第一次装Arch Linux时遇到了一些坑, 不过大多数的问题Google折腾一会或随着后续的软件更新基本上就都解决了, 唯独配置双显卡这个问题在用了两年后才算是找到了比较满意的解决方法（大概是）, 尽管现在这电脑已经停产了, 就算有人买了这台电脑也不一定会拿他装Arch Linux, 不过我还是打算把这个问题的解决过程记录一下（本篇讲的方法应该是适用于大多数N卡+i卡的笔记本电脑的, 只是有些细节不一样）, 以备我后续重装系统时有个参考。\n先描述一下踩坑经过 本段略微有些废话, 可以跳过\n记得在刚买来这台笔记本（2018年夏）, Linux内核还没升到5.0的时候, 使用live CD装系统时会遇到lspci卡死, 关机的时候会卡死的问题, 查系统日记都是一堆ACPI的报错。当时网上查了一下大概是内核和驱动一些bug, 没找到解决办法, Google到论坛的帖子说是在关机/重启发生卡死时只能直接长按电源关机就（找不到搜的回答了）\n装完系统后安装显卡驱动时想通过Bumblebee + bbswitch切换双显卡, 于是装了Gnome然后照着wiki配置完Bumblebee和bbswitch后重启电脑直接死机。\n经过多次重装系统的折磨后, 发现只装Bumblebee不装bbswitch不systemctl enable bumblebeed.service时, 能正常开机, 然后之前遇到的两个问题也莫名其妙就好了, 即系统重启关机不会卡死, lspci也正常了（迷）\n之后, 在不装bbswitch的情况下, 启动bumblebeed.service再用optirun和primusrun这种方式用独显运行程序都没有问题。\n当时因为电脑不装Bumblebee的话就没法正常关机, 于是就一直用着Bumblebee切换双显卡, 玩游戏性能比Windows下差一点, 别的都没啥问题。\n今年年初买了一块拓展屏想搞双显示器, 本来显示器应该插上HDMI直接就能用的, 但是因为这电脑的HDMI走的独显输出, Bumblebee不能直接用, wiki上教的创建个intel的虚拟输出啥的方法有试过但是没成功, 于是又Google了一下后卸了Bumblebee改用NVIDIA Optimus 只使用独显的方式, 这样双显示器倒是能用了, 但是如果笔记本只用电池没连着拓展屏的时候还跑着独显这也太费电了。\n所以最后找到了能切换显卡的Optimus Manager。\n查了一下这款电脑的type-c接口支持DP1.2视频输出，和HDMI 2.0一样支持4K 60fps，走的是intel集成显卡，可以在独显不通电的时候输出画面到第三方显示器。所以买一根type-c转DP线就可以点亮第三方显示器（前提是你的显示器有DP接口），但是切换显卡还是得依靠Bunblebee或Optimus Manager这类的软件。\n安装过程 照着Wiki和Optimus Manager的README。首先安装好显卡驱动相关的软件, 如果有Bumblebee的话使用systemctl disable bumblebeed停用。\n首先清除（记得备份）/etc/X11/xorg.conf.d/下的配置文件, 并删掉（记得备份）/etc/X11/xorg.conf（如果有的话）, 因为Optimus Manager会自动生成配置文件存放到/etc/X11/xorg.conf.d/里面, 所以建议安装前把显示配置相关的文件都清除掉。\n使用Arch Linux CN源或者通过AUR Helper安装optimus-manager。\n# Arch Linux CN $ sudo pacman -S optimus-manager # AUR $ yay -S optimus-manager 因为我用的Gnome, 参照README中说的卸载掉gdm并安装gdm-primeAUR。（国内下载源代码的速度极慢建议挂梯子, 或者挂梯子克隆GDM的代码到~/.cache/yay/gdm-prime/gdm下。）\n修改/etc/gdm/custom.conf, 移除WaylandEnable=false一行前面的#禁用Wayland而使用X。\n修改配置文件 $ sudo cp /usr/share/optimus-manager.conf /etc/optimus-manager/optimus-manager.conf 不要编辑/usr/share/下的文件, 编辑/etc/optimus-manager/optimus-manager.conf, 将切换方式设为switching=none, 不推荐使用bbswitch（见后续第一条）, 设置pci_power_control=yes让PCI Power Management切换显卡。\n之后根据需求来修改开机自动选择显卡：\nstartup_mode=auto startup_auto_battery_mode=intel startup_auto_extpower_mode=nvidia 这里我设置的是用电池时使用集成显卡, 用电源时使用独显。\n最后贴一下全部的配置文件, 除了上述的几处修改以外其他均为默认值, 仅供参考。\n[optimus] # This parameter defines the method used to power switch the Nvidia card. See the documentation # for a complete description of what each value does. Possible values : # # - nouveau : load the nouveau module on the Nvidia card. # - bbswitch : power off the card using the bbswitch module (requires the bbswitch dependency). # - acpi_call : try various ACPI method calls to power the card on and off (requires the acpi_call dependency) # - custom: use custom scripts at /etc/optimus-manager/nvidia-enable.sh and /etc/optimus-manager/nvidia-disable.sh # - none : do not use an external module for power management. For some laptop models it\u0026#39;s preferable to # use this option in combination with pci_power_control (see below). switching=none # Enable PCI power management in Intel mode. # This option is incompatible with acpi_call and bbswitch, so it will be ignored in those cases. pci_power_control=yes # Remove the Nvidia card from the PCI bus. # May prevent crashes caused by power switching. # Ignored if switching=nouveau or switching=bbswitch. pci_remove=yes # Reset the Nvidia card at the PCI level before reloading the nvidia module. # Ensures the card is in a fresh state before reloading the nvidia module. # May fix some switching issues. Possible values : # # - no : does not perform any reset # - function_level : perform a light \u0026#34;function-level\u0026#34; reset # - hot_reset : perform a \u0026#34;hot reset\u0026#34; of the PCI bridge. ATTENTION : this method messes with the hardware # directly, please read the online documentation of optimus-manager before using it. # Also, it will perform a PCI remove even if pci_remove=no. # pci_reset=no # Automatically log out the current desktop session when switching GPUs. # This feature is currently supported for the following DE/WM : # KDE Plasma, GNOME, XFCE, LXDE, Deepin, i3, Openbox, AwesomeWM, bspwm # If this option is disabled or you use a different desktop environment, # GPU switching only becomes effective at the next graphical session login. auto_logout=yes # GPU mode to use at computer startup. Possible values: nvidia, intel, hybrid, auto # \u0026#34;auto\u0026#34; is a special mode that auto-detects if the computer is running on battery # and selects a proper GPU mode. See the other options below. startup_mode=auto # GPU mode to select when startup_mode=auto and the computer is running on battery. # Possible values: nvidia, intel, hybrid startup_auto_battery_mode=intel # GPU mode to select when startup_mode=auto and the computer is running on external power. # Possible values: nvidia, intel, hybrid startup_auto_extpower_mode=nvidia [intel] # Driver to use for the Intel GPU. Possible values : modesetting, intel # To use the intel driver, you need to install the package \u0026#34;xf86-video-intel\u0026#34;. driver=modesetting # Acceleration method (corresponds to AccelMethod in the Xorg configuration). # Only applies to the intel driver. # Possible values : sna, xna, uxa # Leave blank for the default (no option specified) accel= # Enable TearFree option in the Xorg configuration. # Only applies to the intel driver. # Possible values : yes, no # Leave blank for the default (no option specified) tearfree= # DRI version. Possible values : 2, 3 DRI=3 # Whether or not to enable modesetting for the nouveau driver. # Does not affect modesetting for the Intel GPU driver ! # This option only matters if you use nouveau as the switching backend. modeset=yes [nvidia] # Whether or not to enable modesetting. Required for PRIME Synchronization (which prevents tearing). modeset=yes # Whether or not to enable the NVreg_UsePageAttributeTable option in the Nvidia driver. # Recommended, can cause poor CPU performance otherwise. PAT=yes # DPI value. This will be set using the Xsetup script passed to your login manager. # It will run the command # xrandr --dpi \u0026lt;DPI\u0026gt; # Leave blank for the default (the above command will not be run). DPI=96 # If you\u0026#39;re running an updated version of xorg-server (let\u0026#39;s say to get PRIME Render offload enabled), # the nvidia driver may not load because of an ABI version mismatch. Setting this flag to \u0026#34;yes\u0026#34; # will allow the loading of the nvidia driver. ignore_abi=no # Set to yes if you want to use optimus-manager with external Nvidia GPUs (experimental) allow_external_gpus=no # Comma-separated list of Nvidia-specific options to apply. # Available options : # - overclocking : enable CoolBits in the Xorg configuration, which unlocks clocking options # in the Nvidia control panel. Note: does not work in hybrid mode. # - triple_buffer : enable triple buffering. options=overclocking 食用方法 optimus-manager --switch nvidia切换到独显（nvidia）\noptimus-manager --switch intel切换到集显（intel）\n安装mesa-demos后, 使用glxinfo | grep \u0026quot;OpenGL renderer\u0026quot;查看当前正使用的显卡\n其他用法参见Usage。\n注意：\n切换显卡的过程中会自动注销登录, 所以记得保存并关掉电脑正在运行的程序。\n你可以在配置文件中修改auto_logout=false禁止自动注销以手动注销切换显卡。\nOthers 之所以不推荐使用bbswitch是因为容易遇到ACPI锁死的问题, 参考Wiki, 需要添加内核参数acpi_osi=! acpi_osi=\u0026quot;Windows 2009\u0026quot;或acpi_osi=\u0026quot;!Windows 2015\u0026quot;启动, 如果你遇到了锁死可以通过开机时在启动加载器界面编辑添加内核参数来正常进入系统, 如果你用的是efistub或者没办法编辑内核参数的话就只能用live CD救你的电脑了。\n如果用不了lspci, 电脑没法正常关机的话, 是nouveau的问题, 可添加内核参数modprobe.blacklist=nouveau禁用。\n因为前几天改配置文件时又踩了一遍锁死的坑, 于是用最新的(2020.07.01)live CD救砖时, 惊喜的发现在live环境下lspci和关机都不会卡死了, 貌似是新版内核修复了这个bug\n在切换显卡自动注销后, gdm界面有时不会自动加载出来而是一直黑屏, 这时需要手动切换到tty2再切回tty1才能加载出来。\n如果显示器支持DDC/DI，可以参考Wiki使用命令调节显示器亮度。\n(本条与配置显卡无关) 因为电脑用的intel网卡, 如果遇到蓝牙耳机无法连接的情况, 安装pulseaudio和pulseaudio-modues-bt等耳机需要的蓝牙组件, 照着Wiki上的禁用Bluetooth coexistence解决此问题。\nneofetch\n","permalink":"https://blog.starry-s.moe/posts/2021/archlinux-pavilion-gaming-laptop/","summary":"\u003cp\u003e自从高中毕业至今这台笔记本用了将近两年, 已经记不清当初为什么买了这台笔记本, 刚买来电脑第一次装Arch Linux时遇到了一些坑, 不过大多数的问题Google折腾一会或随着后续的软件更新基本上就都解决了, 唯独配置双显卡这个问题在用了两年后才算是找到了比较满意的解决方法（大概是）, \u003cdel\u003e尽管现在这电脑已经停产了, 就算有人买了这台电脑也不一定会拿他装Arch Linux, 不过我还是打算把这个问题的解决过程记录一下\u003c/del\u003e（本篇讲的方法应该是适用于大多数N卡+i卡的笔记本电脑的, 只是有些细节不一样）, 以备我后续重装系统时有个参考。\u003c/p\u003e","title":"惠普光影精灵4在Arch Linux下使用Optimus Manager配置双显卡"},{"content":"好久没有更新博客了，大一下半年一直在忙各种考试，除此之外还有一堆乱七八糟的事情要忙，更新博客的事就只好一点点往后拖了，于是拖更到了8月，后决定不继续拖更但实在没什么拿得出手的技术类文章可写，正好最近还遇到许多有趣的事情，就整理成日常写在这里吧。\n有轨电车——沈阳南站站\n现在是00:00， 很适合吹空调听音乐写博客，毕竟白天睡了一天了。\n首先是6月末去了沈阳META·TRON（梅塔·特隆）电音节，听说这是东北第一次举办的电音节，从AlanWalker入坑的电音，但Meta没请Alan，不过得知有百大DJ前十的DonDiablo（大！菠！萝！）遂非常激动觉得机会难得于是毫不犹豫的就把票买了。\n本来临近期末了除了高数和英语和程序这几科没结课就没有别的课了，但实际上因为要准备高数省统考某组织多加了几节高数课搞得每天都要上两三大节的高数，在得知考试提前到6月29号后某部门下通知要求周末不许离校必须参加全天的自习和新增的高数课和高数模拟考试（草），于是我差点成为了一个花700多块钱打水漂的带傻子。\n于是6月23号下午考完高数模拟考试就直奔地铁站，临时买了一张沈阳北站到沈阳南站的高铁票，逃掉了晚自习，踏上了追(露)逐(宿)梦(街)想(头)的追(流)梦(浪)之旅。\n买高铁票时只剩一张商务座，于是用29元超低价格体验了一次12分钟的商务舱之旅，还享有了商务舱专属候车区的服务，实在没敢问有没有免费咖啡因为怕被骂不要脸（逃\n检票时乘务员阿姨像提醒小朋友一样严肃的提醒我下一站就下车，没有返程，要是不下车就坐到大连了哈哈哈哈哈哈（噗\n没通地铁于是坐高铁去苏家屯\u0026hellip;然后从沈阳南站一路狂奔到有鬼电车一号线的站台，等了将近20分钟才等到车（班次真少），14:00就开始的电音节我20:10才迟到赶到苏家屯的会展中心\u0026hellip;\u0026hellip;\n结果完美错过了回沈北的大巴车，于是真要露宿街头了。\n实际是打车到了沈阳站太原街附近找个旅店住了一晚上第二天早起坐地铁然后换乘共享单车（迷）才赶上了第一节的高数课。\nWestLake\n暑假二刷上海，二刷了迪士冶和地铁二号线、地铁四号线、10号线、11号线、16号线和磁悬浮等景点。看了梦寐以求的BiliBili Macro Link，说实话BML的现场和看直播/回放的效果真的不一样，反正·爱死这破站 就完了。\n总之就是以后绝对不会这么热的天去迪士冶了，要出人命的。\n不过说回来还是喜欢一个人玩，人多了就是特别累，尤其是夏天这个要命的季节。\n最后附上几张在杭州小虫草堂拍的照片，当时为了去那个地方愣是顶着大太阳坐了两个多小时公交车。\n当时比较匆忙外加上好久没有用相机了一直都在用手机拍照所以拍的不是很好，光圈太大了对焦有些不准，凑和着看一下吧。\n瓶子草\n捕蝇草\n猪笼草\n猪笼草\n","permalink":"https://blog.starry-s.moe/posts/2019/shanghai-2/","summary":"\u003cp\u003e好久没有更新博客了，大一下半年一直在忙各种考试，除此之外还有一堆乱七八糟的事情要忙，更新博客的事就只好一点点往后拖了，于是拖更到了8月，后决定不继续拖更但实在没什么拿得出手的技术类文章可写，正好最近还遇到许多有趣的事情，就整理成日常写在这里吧。\u003c/p\u003e","title":"近期日常：2019.6-2019.8"},{"content":" ","permalink":"https://blog.starry-s.moe/posts/2019/spring-3/","summary":"","title":"Spring - 3"},{"content":"不要问我为什么过了这么久才把这篇文章码出来…\n很久以前就有想去上海的念头了。\n最开始是打算在下一次BW举办的时候去上海的，不过想了想要是一整个寒假哪里都没去实在是不甘心，遂定机票简单的制定了计划和预算，开始了这趟旅行。\n准确点说不全是我一个人的旅行，只有去除掉和朋友一同坐了一趟飞机和磁悬浮（火车就不算了）后就剩下的就是一人的旅行了。\n上飞机前的晚上，我硬是没买卧铺票在火车的硬座上坐着熬了一晚上…全靠看Fate Zero熬过来的…\n之所以来上海是因为我很想看一下这么一座拥有B站总部和巨多B站大佬的城市是什么样子的，某些东西可能在大多数人眼里很平淡普通吧，但是我觉得很好玩。所以去迪士尼玩、登上海之巅、到野生动物园近距离看大老虎（fǔ）吃肉这些只能被我称作是本次旅行的附赠品，我当然不是只奔着这些去上海的，但别人问你你花了那么多钱出去旅游了一趟什么也没玩的话肯定会骂我的对吧。毕竟门票不贵买了也不吃亏。\n龙阳路\n没急着用Metro大都会手机刷码捶（雾）地铁是因为我更想试一下Apple Pay是怎么操作的（所以这也是我没有办为游客准备的地铁卡的原因），现在觉得我花了60块钱充Apple Pay真的是交智商税，无数次的被卡在炸鸡口出不去有一次手机出bug双击电源键弹不出钱包界面后面排了很长的队伍是怎样的感受可想而知。\n在此之前只坐过北京地铁和沈阳地铁，在地铁上站两个小时是什么感受只在上海体验过…\n墙裂推荐看一下上海轨交的鬼畜（雾），不然第一次坐地铁很容易迷路的（谜一样的逻辑）。\n第一次自己外出，或多或少会有失误的地方，除了像算错火车票时间退票改票多花点手续费之外，旅店选在了嘉定区着实麻烦了许多…\n因为当时我只知道市区的旅店贵，又不想住青年旅舍，就选个不在市中心但是离地铁站不太远的地方（事实上需要走三十分钟）…\n到后来才知道我住的地方离江苏好近啊，要是坐11号线支线就江苏花桥了，简直…\ncat\n不过旅店的窗子对面有猫！！！每天早晨拉开窗帘看到对面房顶有猫在晒太阳的感觉真的开心死了！\n嘉定西站\n迪士尼\n所以最漫长的就是坐11号线花了很长的时间才能从上海的嘉定到上海浦东的迪士尼…\n一个人去迪士尼的好处就是排队排到最后遇到需要一人凑数的时候我就能合法插队了啊好高兴啊当时（后来我才知道有些地方我一个人是可以直接走单人通道根本不用排队…）\n玩具总动员\n和一个小姐姐一起坐的创极速光轮，小姐姐被吓够呛，我全程没敢睁眼睛死死抓住把手猫在最后一排…\n在B站上看到有人用MC还原了迪士尼的创极速光轮：av13333369\n迪士尼的吃的真的香！就算是80多一根的大鸡腿还是有人排很长的队伍去买，就是真香，花了150买了一些吃的。\n排的最长的队是七个小矮人矿车，足足站了70分钟。\n除了泡泡龙冲天赛车我没敢坐，别的知名项目基本上都玩了一遍，但很可惜只玩了一遍。\n知道晚上有烟花的时候就决定了这一天待在迪士尼里不走了。\n夜光幻影秀真的是那种能看哭的震撼。\n印象最深的就是20：30幻影秀结束后好多人站在那里不想走，还有好多人在拍照。\n迪士尼\n机智的我选择站在地铁门口等下一班车在屏蔽门打开后跑进去抢一个座，说着看起来很不要脸的行为，但是我的腿真的站不动了…\n如果是两个人一起去玩的话会更有意思么？\n上海之巅的风景很好，我去的那天不是很晴，远处的建筑看起来有些朦胧，不过不影响观景。\nVR体验区放着AlanWalker的Routine，听着自己喜欢的歌逛观光厅，很有意思的。\n陆家嘴附近的吃的是真贵，饿着肚子跑到别的地方吃的午饭\u0026hellip;\n野生动物园站\n下午坐地铁去野生动物园。\n又回到了龙阳路地铁站。\n16号线分大站车小站车，大站车不停野生动物园站，当时差一点上错车。\n之前在知乎上见过有人吐槽16号线车厢内座椅设计的，等坐上车后才感受到这是真的挤…\n在16号线上查了英语四级的成绩，压线过，成绩不高不是很满意，不过想了想考试时自己在生病住院，算作是自己为自己找的一个借口吧。\n野生动物园站离动物园门口炒鸡远，走着去太耽误时间了。\n等走到动物园的时候已经下午2点多了，开电瓶车的司机总在提醒他们马上就下班了让我们赶紧逛剩下的景点这个很烦，所以最后我又走着在园区溜达了一遍。\n基本上把所有的动物都看了一边，表示我已经见过这些动物了，在公园里溜达一大圈。\n等逛完一大圈之后动物园里已经没几个人了，\n站在桥上看下面的天鹅，附近的音响在放AlanWalker的remix过的Faded，真的我很喜欢这首歌。\n最后花五块钱买包饲料喂天鹅，又买点玉米喂鸽子…\n晚上开始下雨，坐地铁回陆家嘴去了东方明珠，由于下雨玻璃上有很多水珠所以最初隔着窗子拍的照片都有些模糊。\n东方明珠还没有学生票…\n最开始觉得好亏，花了好多钱还拍不了照片，直到后来我到了下面的空中走廊\u0026hellip;\n在迪士尼和别人撞衫就算了，第二天在东方明珠又撞衫，还是同一个人，啊世界真小。\n在东方明珠上待了很久，参观了一些其他项目，坐了一把VR过山车（正好赶上最后一趟），很晚才回到旅店。\n第三天是先坐11号线到江苏路换二号线然后换四号线然后换十号线…\n欢迎您乘坐轨道交通四号线，本线环线本线环线本线环线本线环线哈哈哈哈哈哈哈哈哈哈哈哈……\n傻乎乎的骑共享单车跑去B站总部逛了一大圈，问了一下前台小姐姐只能参观一楼大厅后去了咖啡厅花了50块钱买一杯小电视咖啡（忘记叫什么名字了）后含泪把它喝掉…\nCosta Coffee\n太好吃了呜呜呜呜呜…\n还真不是Bilibili会员购骗死肥宅钱…\n所以我什么都没有买。\n武康大楼\n下午开始下雨，懒得拿相机，也没怎么用手机拍照，就顺着地铁线路依次去了趟同济，交大，顺路去了武康大楼，参观了宋庆龄故居。最后去了师范大，没有去复旦因为时间不够了。\n逛那些校园的时候只是打着伞进去走了一圈代表哦我已经来过这里了，一张照片都没有拍。\n去同济时正赶上开学，去看了一眼樱花树还没有开，就匆匆走了。\n只不过是多抽出一些时间让自己走在街上闲逛罢了…\n好多时间都是在地铁上度过的。\n城隍庙\n想了想明天就要坐飞机回家了所以内心很是不舍晚上又坐地铁去了城隍庙（豫园），吃了豫园卖的特别难吃的小吃后（终于明白为什么上海本地人几乎不去豫园这个地方了）回旅店早早睡觉为明天早起做准备…\n因为起床晚了为了赶时间坐的磁悬浮去的普通国际姬场（雾），没有坐二号线广兰路到浦东国际机场的延线有些可惜。\n飞机即将降落时在城市上空绕了好几圈，体验了好几次失重的感觉（太好玩了我还要玩 #啪）\n","permalink":"https://blog.starry-s.moe/posts/2019/shanghai/","summary":"\u003cp\u003e不要问我为什么过了这么久才把这篇文章码出来…\u003c/p\u003e","title":"一个人的旅行 —— 上海"},{"content":"生命不息, 折腾不止\u0026hellip;\n本篇由于创作时间过于久远，部分下载链接可能失效，因长期未更新，教程仅供参考。\n准备工作 你至少需要以下工具：\n路由器本体 网线 一个已格式化为FAT/FAT32格式的U盘, 用来刷开发者固件和ssh激活工具 一根怼Reset钮的针 Windows用户需要一个SSH软件（例如：putty） 小米路由器客户端, 用来绑定你的小米账号 SSH到路由器 路由器重启后指示灯会变为蓝色, 若变为红色则为刷机失败。\n安装开发者固件并开启SSH权限：\n在MiWiFi下载页面下载所需要的路由器开发者固件（ROM -\u0026gt; ROM for R3G开发版）,命名为miwifi.bin。\n路由器断电, 将下载好的开发者固件放入U盘插入路由器USB接口, 捅住reset扭接上电源后待指示灯为黄色闪烁时松开, 数分钟后路由器会自动重启, 此过程不要乱动路由器。\n小米路由器客户端登陆小米账号绑定路由器设备, 此过程需要路由器联网。\nMiWiFi开放平台登陆小米账号下载ssh激活工具命名为miwifi_ssh.bin, 记下root密码。\n操作方式同第二步骤, 刷入ssh激活工具。\nSSH到路由器:\nWindows系统用putty, ip为191.168.31.1, 用户名：root, 密码为下载激活ssh工具时记下的密码。\nUnix/Linux系统终端执行：ssh root@191.168.31.1\n如果在ssh到路由器时遇到no matching key exchange method found错误，编辑~/.ssh/config, 加入下面两行：\nHost * KexAlgorithms +diffie-hellman-group1-sha1 刷入Bootloader（推荐/可选） 该步骤可选是因为Breed不支持直接刷入Openwrt固件, 可参考这篇帖子, 不过为了防止变砖, 还是推荐刷Breed。\nBreed原作者为hackpascal, 此处为下载地址, 文件名为breed-mt7621-xiaomi-r3g.bin\n第一种方法是ssh到路由器后通过wget下载breed文件再刷入（需要确保路由器联网）, 下载地址为https所以需要加上--no-check-certificate参数。\ncd /tmp wget --no-check-certificate https://breed.hackpascal.net/breed-mt7621-xiaomi-r3g.bin -O breed.bin mtd -r write breed.bin Bootloader 另一种方法是将breed通过U盘拷贝到路由器再刷入。\nmkdir /tmp/sdcard mount /dev/sda1 /tmp/sdcard mtd -r write /tmp/sdcard/breed.bin Bootloader 路由器刷写完毕后会自动重启, 在写入Breed的过程中不要动路由器。\n刷机 下载所需固件：\ntuna镜像站的OpenWrt下载地址：https://mirrors.tuna.tsinghua.edu.cn/lede/releases/\n官方下载地址: https://downloads.openwrt.org/releases/\n使用Breed的刷机方法 按照hackpascal的说法是：\n如果kernel0存在kernel1不存在, 那么启动kernel0 如果kernel1存在kernel0不存在, 那么启动kernel1 如果kernel0和kernel1都存在, 那么检查环境变量 xiaomi.r3g.bootfw 的值, 如果存在且值为 2, 那么启动kernel1, 否则启动kernel0\n简单来说就是：路由器有两个内核, 需要在Breed里设置环境变量让路由器启动kernel1。\n刷入Openwrt固件到Kernel1 mtd write openwrt-18.06.2-ramips-mt7621-mir3g-squashfs-kernel1.bin kernel1 mtd write openwrt-18.06.2-ramips-mt7621-mir3g-squashfs-rootfs0.bin rootfs0 路由器断电, 捅住reset按钮后通电, 待指示灯变为蓝色闪烁后用网线连接路由器到电脑, 浏览器打开网址192.168.1.1, 进入Breed界面。\n在环境变量编辑里添加xiaomi.r3g.bootfw字段, 值为2,保存后重启即可进入Openwrt。\n没有刷入Breed的刷机方法 OpenWrt官网提供的教程是在没有刷入Breed的情况下刷入OpenWrt固件的。\nssh到路由器, 导入固件后刷机。\nmtd write openwrt-18.06.2-ramips-mt7621-mir3g-squashfs-kernel1.bin kernel1 mtd write openwrt-18.06.2-ramips-mt7621-mir3g-squashfs-rootfs0.bin rootfs0 nvram set flag_try_sys1_failed=1 nvram commit reboot Others 如果刷了Breed + Pandavan/PandoraBox后想换回OpenWrt的话, 首先在Breed中刷回小米路由器开发版的官方固件, 然后SSH到路由器按照上述的使用Breed的刷机方法再刷机。\nUSB3.0会对路由器的2.4G频段信号造成干扰。\nOpenWrt默认语言为英文, 可安装luci-i18n-base-zh-cn,luci-i18n-base-zh-tw安装简体/繁体中文。\nOpenWrt-dist可拓展更多功能。\n为优化软件包安装速度, 可将opkg源改为国内：\nLuCI -\u0026gt; System -\u0026gt; Software -\u0026gt; Configuration 中将 Distribution feeds 的http://downloads.openwrt.org替换为http://mirrors.tuna.tsinghua.edu.cn/lede。\nOpenWrt可安装软件包libustream-openssl libustream-mbedtls解决wget无法访问https服务器问题。 然后建议把opkg源能改为https的都改为https。\n","permalink":"https://blog.starry-s.moe/posts/2019/xiaomi_r3g_openwrt/","summary":"\u003cp\u003e生命不息, 折腾不止\u0026hellip;\u003c/p\u003e","title":"小米路由器3G折腾之刷OpenWrt记录"},{"content":" Everything that lives is designed to end.\nWe are perpetually trapped\nin a never-ending spiral of life and death.\nIs this a curse?\nOr some kind of punishment?\nI often think about the God who blessed us with this cryptic puzzle\nand wonder if we\u0026rsquo;ll ever have the chance to kill him.\n","permalink":"https://blog.starry-s.moe/posts/2019/nier-automata/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"images/20190216233002_1.jpg\" alt=\"\" /\u003e\n\n\u003c/p\u003e","title":"Automata"},{"content":" ","permalink":"https://blog.starry-s.moe/posts/2018/life-in-sau/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"images/trip.jpg\" alt=\"Trip\" /\u003e\n\n\u003c/p\u003e","title":"Lifeline"},{"content":"终于到了暑假可以开一个Minecraft服务器和小伙伴联机的时候了！在发现我对吃鸡那类的游戏除了觉得好玩以外没有任何天赋( 没钱买鼠标？ )后打算继续玩我的世界，所以为了方便那些想玩Minecraft（非网易代理版）但是还不知道怎么操作的那些小伙伴们，这篇教程就这么诞生了。\n本篇由于创作时间过于久远，部分下载链接可能失效，因长期未更新，教程仅供参考。\n本教程将分为二个部分，第一部分将指导你如何使用HMCL启动器安装并使用Minecraft（非网易代理版），第二部分处理一些常见的问题。 本教程主要写给Windows用户，我想Linux用户不太需要我的教程了吧。。 可能有人是刚接触电脑的新人，所以我尽可能的把每一步都写详细清楚，方便大家的理解。\n本教程仅提供所述内容的下载连接，游戏的版权归Mojang所有。\n顺便说一下网易版并不支持MacOS哈哈哈哈。。。。\n第一部分： 如果你尚未在官网购买正版的Minecraft，你可以使用HMCL（Hello Minecraft Launcher )启动器下载并运行MC。\n你需要确保你的电脑已安装java8。下载java：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\n接下来你需要下载HMCL启动器。 我建议去HMCL的官方服务器 下载所需的exe文件，最好不要从贴吧/论坛下载来路不明/非最新版本的HMCL启动器。\n选择最新版本的后缀为.exe的文件下载即可。或者你可以下载后缀为.jar的文件（用于Linux，MacOS）\n新建一个文件夹（放在你喜欢的位置例如桌面），将下载的exe/jar文件复制到这里。 Windows用户直接双击exe文件运行即可，\nLinux用户你下载的是jar文件所以如果你想运行你需要新建一个可执行文件：\n$ cd 你的文件夹名称 $ echo \u0026#34;java -jar hmcl-对应的版本号.jar\u0026#34; \u0026gt; ./start.sh $ chmod 744 ./start.sh 然后在终端执行./start.sh。\n或者直接在终端执行java -jar hmcl-*.jar即可。\n设置一个你喜欢的名字并一直使用它，选择离线模式 在HMCL里点击右下角的加号下载游戏文件,建议将游戏下载到你启动器所在的文件夹内。\n如果你已购买正版Minecraft，在确保java安装好后直接去官网下载启动器再到启动器中下载游戏即可，可能会因网络原因速度慢，这是正常现象。\n请支持正版，RMB165，可使用支付宝。\n第二部分： 笔记本双显卡用户请确保你正确的安装了显卡驱动（新买的笔记本不知道什么是显卡驱动就默认已经安装好了），NVIDA显卡用户在桌面右键选择NVIDIA控制面板（没有这个选项可能是你的显卡驱动没安装好），选择 3D设置-\u0026gt;管理3D设置 ，选择添加，找到你安装的JAVA目录下的java.exe，将其设置为高性能处理器。然后保存设置并退出。（ps现在市面上新出的笔记本用集成显卡玩这个游戏也已经很流畅了） 在游戏中按F3，若右侧有NVIDIA字样就说明你已成功的使用独显运行游戏了，在左侧可以观察帧数。\nLinux用户如果可以启动HMCL但是无法启动游戏错误报告是有关OpenGL的话在确定显卡驱动配置正常后检查一下是否安装了xorg-xrandr。\n64位系统的用户不要安装32位的java，不仅影响性能而且对可使用的内存大小也有限制。\nLinux用户如果想用独显玩Minecraft而日常使用时切换回省电的集显，请参考 Linux下使Steam调用Bumblebee使用独显,当然不同的Linux Distribution方法会有不同，请linux用户自行摸索。\n相关内容： 教程/成功地启动游戏-Minecraft Wiki 官方网站|Minecraft 树莓派之我的世界服务器 如果你感兴趣想一起联机我的世界的话欢迎联系我，大家一起来Van游戏。\n","permalink":"https://blog.starry-s.moe/posts/2018/hmcl-minecraft/","summary":"\u003cp\u003e终于到了暑假可以开一个Minecraft服务器和小伙伴联机的时候了！在发现我对吃鸡那类的游戏除了觉得好玩以外没有任何天赋( \u003cdel\u003e没钱买鼠标？\u003c/del\u003e )后打算继续玩我的世界，所以为了方便那些想玩Minecraft（非网易代理版）但是还不知道怎么操作的那些小伙伴们，这篇教程就这么诞生了。\u003c/p\u003e","title":"使用HMCL启动Minecraft"},{"content":" Flowers\n春天来了。 Spring - 2 拍摄自2018-3-28\n","permalink":"https://blog.starry-s.moe/posts/2018/spring-2/","summary":"","title":"Spring - 2"},{"content":" 秒速五厘米\n","permalink":"https://blog.starry-s.moe/posts/2018/hello-2018/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"images/5cm_per_second.jpg\" alt=\"秒速5厘米\" /\u003e\n\n\u003c/p\u003e","title":"Hello 2018"},{"content":" Just A Small Update.","permalink":"https://blog.starry-s.moe/posts/2017/just-a-small-update/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"images/image4.jpg\" alt=\"\" /\u003e\n\n\u003c/p\u003e","title":"尽可能的写点什么"},{"content":"前一阵子拍的一些花，简单地用手机和电脑调了颜色，感觉蛮好看的。感觉有的照片可以当作壁纸了。\n拍摄自ipod touch6 拍摄自佳能powershot s100 ","permalink":"https://blog.starry-s.moe/posts/2017/spring/","summary":"\u003cp\u003e前一阵子拍的一些花，简单地用手机和电脑调了颜色，感觉蛮好看的。感觉有的照片可以当作壁纸了。\u003c/p\u003e","title":"Spring"},{"content":" Hello 2017!","permalink":"https://blog.starry-s.moe/posts/2017/hello-2017/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"images/image.jpg\" alt=\"Hello 2017\" /\u003e\n\n\u003c/p\u003e","title":"Hello 2017!"},{"content":"刚买树莓派3B时就想弄一个我的世界服务器，但是那时不懂Linux，服务器也就没建成。这一阵子打算把这个计划再捡起来，和同学一起联机的话树莓派还是能做到的。ARM系列的CPU性能肯定比X86_64电脑的CPU弱许多，外加上树莓派1G的运行内存，让它跑大型服务器肯定是不可能的，所以只能弄一个几个人联机的小服务器了。\n本篇由于创作时间过于久远，部分下载链接可能失效，因长期未更新，教程仅供参考。\n终于可以继续更新博客了！原计划是11月之前更新博客的。不巧电脑出了问题，重装了一遍Arch Linux,后来又发生了一些事一直没能用电脑。由于开学到现在能放假供我写博客的时间少之又少，这篇原本在11月初就能发表的文章就这样被硬生生推迟到了11月末了。\n材料以及工具 树莓派一只 （包括所需要的C10的内存卡以及刷好的固件以及5v，2.5A充电器） 一个支持DDNS的路由器（非必须） 如果不想用树莓派建服务器的话也可以按照本教程在电脑上搭建服务器。\n配置树莓派 调整GPU可使用的内存： 毕竟用树莓派开服务器不需要占用GPU，直接调低。\nRaspbian: raspi-config中将GPU内存分为16M。\nArch Linux ARM: /boot/config.txt中更改GPU显存为16\n安装JAVA Archlinux ARM:\n$ sudo pacman -S jre8-openjdk 通用方法： 前往 JAVA下载页 下载树莓派（ARM架构，32位系统）所支持的JDK。\n$ mkdir ./java $ tar -zxvf 你所下载的JDK.jar.gz -C ./java/ 在终端输入./java/jdk1.8.0/bin/java -version显示java的版本号。\n部署服务器 本篇使用Paper MC部署服务器。 除了Paper之外还有Bukkit和Spigot以及原版可选。\n使用以下命令启动服务器。\n$ echo eula=True \u0026gt; eula.txt $ ./java/jdk*/bin/java -Xms512M -Xmx1024M -jar ./spigot.jar 第一次运行会下载一些文件需要一定的时间。\n网上有很多服务器插件和Mod什么的。本章中不做过多介绍.\n用screen 保持服务器一直运行而不被关掉。 首先安装好screen。\n$ screen $ ./java/jdk1.8.0/bin/java -Xms512M -Xmx1024M -jar./paperclip.jar 在配置好你的服务器后就可以和小伙伴一起联机了。经过测试几个人简单的联机运行蛮正常的。\n","permalink":"https://blog.starry-s.moe/posts/2016/raspberrypi-mc-server/","summary":"\u003cp\u003e刚买树莓派3B时就想弄一个我的世界服务器，但是那时不懂Linux，服务器也就没建成。这一阵子打算把这个计划再捡起来，和同学一起联机的话树莓派还是能做到的。ARM系列的CPU性能肯定比X86_64电脑的CPU弱许多，外加上树莓派1G的运行内存，让它跑大型服务器肯定是不可能的，所以只能弄一个几个人联机的小服务器了。\u003c/p\u003e","title":"树莓派之我的世界服务器"},{"content":"你好，世界！\nHello World\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } ","permalink":"https://blog.starry-s.moe/posts/2016/hello-world/","summary":"\u003cp\u003e你好，世界！\u003c/p\u003e","title":"Everything is based on “Hello World”"},{"content":" West Lake\n关于本站 博客最初建于 2016 年夏，目前使用 Hugo 生成静态页托管在 GitHub Pages。\n时间久远曾弄丢过好几个域名，现用域名为 starry-s.moe。\n关于咱 是一个野生的 Arch Linux 用户，喜欢 Linux，经常写代码，研究些有意思抽象难以用语言描述的东西。 空闲时间偶尔搞点摄影，照片可以在本站的 相册 页找到。\nPGP 密钥：E8F9 2E5A C1AE 0B0F 4421 4012 9190 2000 F0C2 9BC2 Email: starry@starry-s.moe GitHub: https://github.com/STARRY-S 以下是一些咱感兴趣的东西：\nLinux：咱已经用了很久很久的 Arch Linux 和 GNOME Desktop 了，咱认为 Arch Linux 真的是一个用起来很舒服很舒服的系统（仅个人观点）。 容器、云原生相关技术：咱的工作与云原生技术相关，咱是这个领域的萌新，还在学相关的芝士。 写代码：咱会在空闲时间去鼓捣代码，写程序这玩意蛮抽象的不太好用语言文字描述，喜欢的编程语言是 C、Go、Java Script…… 摄影：目前有一台入门级 APS-C 画幅佳能 R7 和几个 Sigma 残幅镜头（画幅大小什么的并不重要），只会按快门调参数，后期和剪辑这些并不擅长。 动漫：二刺猿这个领域太广泛了，不太好向别人介绍。咱是个月厨，不过最近没什么时间追新番了，有时会去逛漫展，顺便拍拍场照。 一些咱喜欢的游戏：幻兽帕鲁、守望先锋、Minecraft (Java Edition)、NieR:Automata、Final Fantasy VII、月姬 Remake、魔法使之夜、传送门、Lethal Company…… Furry：咱是个新入坑的福瑞控，不过咱很少主动和非兽圈的人提这个事情，咱的博客不会包含很多的福瑞相关内容，但或多或少还是会有一些小动物相关的东西。有关咱的崽子的视频和照片主要是发在咱的社交平台帐号上，可能会有人觉得咱的博客和其他社交帐号的差距有一些大吧，不过这个博客记录的主要还是咱内陷的一些事情。 地铁：咱对地铁感兴趣，会收集每个城市的地铁单程票，玩 Minecraft 单机生存也主要是在存档里面修地铁。 音乐：咱喜欢听歌，种类包括娓浦大妈的曲子、型月相关的动漫和游戏背景音乐，还有电音…… 常用网易云音乐和 Apple Music。 ","permalink":"https://blog.starry-s.moe/about/","summary":"West Lake 关于本站 博客最初建于 2016 年夏，目前使用 Hugo 生成静态页托管在 GitHub Pages。 时间久远曾弄丢过好几个域名，现用域名为 starry-s.moe。 关于","title":"About"},{"content":"咱在很久很久以前就开始入坑摄影了。今年年初入手了一台入门级 APS-C 画幅的佳能 R7 和 Sigma 18-35 F1.8 \u0026amp; 50-100 F1.8 镜头用来练习摄影。\n咱会把一些旅拍和在漫展拍的高分辨率图片整理在这里，加载可能需要些时间。\n算不上什么精美作品，咱只是个业余的野生摄影\nPowered by hugo-shortcode-gallery.\n","permalink":"https://blog.starry-s.moe/gallery/","summary":"咱在很久很久以前就开始入坑摄影了。今年年初入手了一台入门级 APS-C 画幅的佳能 R7 和 Sigma 18-35 F1.8 \u0026amp; 50-100 F1.8 镜头用来练习摄影。 咱会把一些旅拍和在漫展拍的高分辨率图","title":"相册"},{"content":"","permalink":"https://blog.starry-s.moe/friends/","summary":"","title":"友情链接"}]